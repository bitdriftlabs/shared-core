# Agent Guidelines for Fuzz Tests

## Overview

This crate contains fuzz tests for various components in shared-core. Fuzz tests use the `arbitrary` crate to generate random test inputs and the `libfuzzer-sys` crate to drive the fuzzing process.

## Fuzz Test Structure

A typical fuzz test consists of three main components:

### 1. Test Case Structure (`src/`)

Define the structure of your fuzz test in `src/`:

```rust
// 1. Define edge cases (optional but recommended)
#[derive(Arbitrary, Debug, Clone)]
enum ValueEdgeCase {
  EmptyString,
  LargeString,
  MinInt,
  MaxInt,
  // ... other edge cases
}

// 2. Define operation types
#[derive(Arbitrary, Debug, Clone)]
enum OperationType {
  Insert { key: String, value: Value },
  Remove { key: String },
  Get { key: String },
  Sync,
  Reopen,
  // ... other operations
}

// 3. Define the test case (what gets generated by the fuzzer)
#[derive(Arbitrary, Debug)]
pub struct MyFuzzTestCase {
  buffer_size: u32,
  operations: Vec<OperationType>,
  // ... other config parameters
}

// 4. Define the test harness
pub struct MyFuzzTest {
  test_case: MyFuzzTestCase,
  // ... internal state tracking
  state: HashMap<String, Value>,
  temp_dir: TempDir,
}

impl MyFuzzTest {
  pub fn new(test_case: MyFuzzTestCase) -> Self {
    // Clamp/validate inputs to reasonable ranges
    let buffer_size = ((test_case.buffer_size % 1_048_576) + 1024) as usize;
    
    Self {
      test_case,
      state: HashMap::default(),
      // ... initialize state
    }
  }

  pub fn run(self) {
    // For async tests, create a runtime
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(self.run_async());
  }

  async fn run_async(mut self) {
    // Initialize the system under test
    let mut system = initialize_system();

    // Execute each operation
    for operation in self.test_case.operations {
      match operation {
        OperationType::Insert { key, value } => {
          // Execute operation on real system
          let result = system.insert(&key, value).await;
          
          // Update shadow state
          self.state.insert(key, value);
          
          // Validate invariants
          self.verify_invariants(&system);
        },
        // ... handle other operations
      }
    }
  }

  fn verify_invariants(&self, system: &System) {
    // Check that system state matches shadow state
    // Add assertions that should always hold
  }
}

// 5. Add a test that runs all corpus files
#[test]
fn run_all_corpus() {
  crate::run_all_corpus(
    "corpus/my_fuzz_test",
    |input: MyFuzzTestCase| {
      MyFuzzTest::new(input).run();
    },
  );
}
```

### 2. Fuzz Target (`fuzz_targets/`)

Create a minimal fuzz target that connects libfuzzer to your test harness:

```rust
// fuzz_targets/my_fuzz_test.rs
#![no_main]

use fuzz::my_module::{MyFuzzTest, MyFuzzTestCase};

libfuzzer_sys::fuzz_target!(|input: MyFuzzTestCase| {
  MyFuzzTest::new(input).run();
});
```

### 3. Module Registration (`src/lib.rs`)

Add your fuzz test module to `src/lib.rs`:

```rust
pub mod my_fuzz_test;
```

## Key Patterns and Best Practices

### Input Validation and Clamping

Always clamp/validate fuzzer-generated inputs to reasonable ranges:

```rust
// Clamp buffer size to 1KB - 1MB range
let buffer_size = ((test_case.buffer_size % 1_048_576) + 1024) as usize;

// Clamp ratio to [0.0, 1.0] and ensure it's finite
let ratio = test_case.ratio.and_then(|r| {
  let clamped = r.clamp(0.0, 1.0);
  if clamped.is_finite() { Some(clamped) } else { None }
});
```

### Edge Case Coverage

Add explicit edge cases to increase coverage of interesting values:

```rust
impl<'a> Arbitrary<'a> for ArbitraryValue {
  fn arbitrary(u: &mut Unstructured<'a>) -> arbitrary::Result<Self> {
    let variant: u8 = u.arbitrary()?;
    
    // 10% chance of edge case, 90% chance of normal arbitrary value
    if variant.is_multiple_of(10) {
      let edge_case: ValueEdgeCase = u.arbitrary()?;
      return Ok(Self(edge_case.to_value()));
    }
    
    // Generate normal arbitrary value
    // ...
  }
}
```

### Shadow State Tracking

Maintain a shadow state to validate system behavior:

```rust
pub struct MyFuzzTest {
  state: HashMap<String, Value>,  // Shadow state
  system: RealSystem,              // System under test
}

// After each operation, verify that system matches shadow state
fn verify_invariants(&self) {
  for (key, expected_value) in &self.state {
    let actual_value = self.system.get(key);
    assert_eq!(actual_value, Some(expected_value));
  }
}
```

### Related Operations

When operations depend on each other, consider tracking selections to ensure that values are reused.
For example, when generating values that are inserted then read back, the below ensures that the fuzzer
is more likley to pick existing values to read.

```rust
struct KeyPool {
  keys: Vec<String>,
}

#[derive(Arbitrary)]
enum KeyStrategy {
  Existing(u8),  // Index into key pool
  New(String),   // Generate new key
}

impl KeyPool {
  fn key_for_write(&mut self, strategy: &KeyStrategy) -> String {
    match strategy {
      KeyStrategy::Existing(index) => {
        if self.keys.is_empty() {
          let new_key = format!("key_{}", self.keys.len());
          self.keys.push(new_key.clone());
          new_key
        } else {
          let idx = (*index as usize) % self.keys.len();
          self.keys[idx].clone()
        }
      },
      KeyStrategy::New(key) => {
        let new_key = format!("{}_{:x}", key, self.keys.len());
        self.keys.push(new_key.clone());
        new_key
      },
    }
  }
}
```

### Graceful Error Handling

Handle expected errors gracefully and continue fuzzing:

```rust
match system.insert(&key, value).await {
  Ok(_) => {
    // Success - update shadow state
    self.state.insert(key, value);
  },
  Err(e) if e.to_string().contains("Buffer too small") => {
    // Expected error - buffer is full
    self.is_full = true;
    continue;
  },
  Err(e) => {
    // Unexpected error - panic to report bug
    panic!("Unexpected error: {}", e);
  }
}
```

### Corruption Testing

For persistence testing, add corruption operations:

```rust
#[derive(Arbitrary, Debug, Clone)]
enum CorruptionType {
  FlipBytes { count: u8 },
  Truncate { size: u32 },
  ZeroRegion { offset: u32, length: u16 },
}

#[derive(Arbitrary, Debug, Clone)]
enum OperationType {
  // ... normal operations
  ReopenWithCorruption {
    corruption: CorruptionType,
    target: CorruptionTarget,
  },
}

// In the operation handler:
OperationType::ReopenWithCorruption { corruption, target } => {
  store.sync();
  let path = store.file_path();
  drop(store);
  
  // Apply corruption to file
  let mut data = std::fs::read(&path)?;
  apply_corruption(&mut data, &corruption, &target);
  std::fs::write(&path, data)?;
  
  // Reopen and verify error handling
  let result = System::open(path).await;
  // Verify system handles corruption gracefully
}
```

## Running Fuzz Tests

### Run a specific fuzz target:
```bash
fuzz/scripts/run_fuzzer.sh my_fuzz_test
```

### Run corpus tests (in normal cargo test):
```bash
cargo nextext run -p fuzz my_fuzz_test
```

This runs the `run_all_corpus()` test which validates all saved corpus files.

## Examples

See existing fuzz tests for reference:
- `versioned_kv_journal.rs` - Complex stateful fuzzing with shadow state, key pooling, corruption testing, and capacity error handling
- `buffer_corruption_fuzz_test.rs` - Simpler fuzz test that customizes a base test case
- `spsc_buffer_fuzz_test.rs` - Single-producer single-consumer buffer fuzzing with action filtering

## Debugging Fuzz Failures

When a fuzz test finds a crash:

1. The failing input is saved to `fuzz/artifacts/my_fuzz_test/crash-<hash>`
2. Reproduce locally:
   ```bash
   cargo +nightly fuzz run my_fuzz_test fuzz/artifacts/my_fuzz_test/crash-<hash>
   ```
3. Add the failing case to the corpus after fixing the bug to prevent regression

## Common Pitfalls

1. **Not clamping inputs**: Fuzzer can generate extreme values (e.g., u32::MAX buffer size). Always clamp to reasonable ranges.

2. **Infinite loops**: Make sure operations can complete. Avoid waiting on conditions that may never be satisfied.

3. **Resource exhaustion**: Use temporary directories and clean up resources. Don't accumulate unbounded state.

4. **Panicking on expected errors**: Only panic on unexpected errors. Expected errors (like "buffer full") should be handled gracefully.

5. **Not maintaining invariants**: After each operation, verify that invariants hold. This catches bugs early.

6. **Forgetting the corpus test**: Always add a `run_all_corpus()` test so corpus files are validated in CI.
