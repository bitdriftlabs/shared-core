// shared-core - bitdrift's common client/server libraries
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code is governed by a source available license that can be found in the
// LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// Copyright (C) 2024 Bitdrift, Inc.
// SPDX-License-Identifier: Apache-2.0 OR PolyForm-Shield-1.0.0
// You may obtain a copy of the license at
// https://www.apache.org/licenses/LICENSE-2.0
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

//! Runtime helper functions used by proc-macro-generated code.
//!
//! These functions are called from code generated by the `#[proto_serializable]` macro
//! and should not typically be used directly.

use anyhow::Result;
use protobuf::CodedInputStream;
use protobuf::rt::WireType;

/// Reads a length-delimited nested message from the protobuf stream.
///
/// The visitor closure is called for each field within the nested message.
/// - If the visitor returns `Ok(true)`, it means the field was handled (read)
/// - If the visitor returns `Ok(false)`, the field is skipped using the wire type
///
/// This function is used by the proc macro for deserializing nested messages.
pub fn read_nested(
  is: &mut CodedInputStream<'_>,
  mut visitor: impl FnMut(&mut CodedInputStream<'_>, u32, WireType) -> Result<bool>,
) -> Result<()> {
  let len = is.read_raw_varint32()?;
  let old_limit = is.push_limit(u64::from(len))?;

  while !is.eof()? {
    let tag = is.read_raw_varint32()?;
    let field_number = tag >> 3;
    let wire_type_bits = tag & 0x07;
    let wire_type = match wire_type_bits {
      0 => WireType::Varint,
      1 => WireType::Fixed64,
      2 => WireType::LengthDelimited,
      3 => WireType::StartGroup,
      4 => WireType::EndGroup,
      5 => WireType::Fixed32,
      _ => {
        return Err(anyhow::anyhow!(
          "Unknown wire type {wire_type_bits} (tag={tag}, field={field_number})"
        ));
      },
    };

    if !visitor(is, field_number, wire_type)? {
      is.skip_field(wire_type)?;
    }
  }

  is.pop_limit(old_limit);
  Ok(())
}

/// Merges repeated field occurrences by extending the target collection.
///
/// This is used by the proc macro for repeated fields. Each time a repeated field appears
/// in the protobuf stream, `deserialize` is called and returns a collection with one or more
/// items. This function merges those items into the target collection.
///
/// # Examples
///
/// For a repeated field:
/// ```ignore
/// repeated string tags = 1;
/// ```
///
/// Each occurrence of field 1 in the stream will call `Vec::deserialize()` which returns
/// a `Vec` with a single string. This function extends the main `Vec` with that single item.
pub fn merge_repeated<T, I>(target: &mut T, source: I)
where
  T: Extend<I::Item>,
  I: IntoIterator,
{
  target.extend(source);
}
