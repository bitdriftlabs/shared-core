// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod bitdrift_public {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod fbs {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod issue_reporting {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod v_1 {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REPORT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REPORT_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REPORT_TYPE: [ReportType; 7] = [
  ReportType::Unknown,
  ReportType::AppNotResponding,
  ReportType::HandledError,
  ReportType::JVMCrash,
  ReportType::MemoryTermination,
  ReportType::NativeCrash,
  ReportType::StrictModeViolation,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReportType(pub i8);
#[allow(non_upper_case_globals)]
impl ReportType {
  pub const Unknown: Self = Self(0);
  pub const AppNotResponding: Self = Self(1);
  pub const HandledError: Self = Self(2);
  pub const JVMCrash: Self = Self(3);
  pub const MemoryTermination: Self = Self(4);
  pub const NativeCrash: Self = Self(5);
  pub const StrictModeViolation: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::AppNotResponding,
    Self::HandledError,
    Self::JVMCrash,
    Self::MemoryTermination,
    Self::NativeCrash,
    Self::StrictModeViolation,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::AppNotResponding => Some("AppNotResponding"),
      Self::HandledError => Some("HandledError"),
      Self::JVMCrash => Some("JVMCrash"),
      Self::MemoryTermination => Some("MemoryTermination"),
      Self::NativeCrash => Some("NativeCrash"),
      Self::StrictModeViolation => Some("StrictModeViolation"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReportType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReportType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReportType {
    type Output = ReportType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReportType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReportType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReportType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLATFORM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLATFORM: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLATFORM: [Platform; 4] = [
  Platform::Unknown,
  Platform::Android,
  Platform::iOS,
  Platform::macOS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Platform(pub i8);
#[allow(non_upper_case_globals)]
impl Platform {
  pub const Unknown: Self = Self(0);
  pub const Android: Self = Self(1);
  pub const iOS: Self = Self(2);
  pub const macOS: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Android,
    Self::iOS,
    Self::macOS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Android => Some("Android"),
      Self::iOS => Some("iOS"),
      Self::macOS => Some("macOS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Platform {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Platform {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Platform {
    type Output = Platform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Platform {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Platform {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Platform {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ARCHITECTURE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ARCHITECTURE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ARCHITECTURE: [Architecture; 5] = [
  Architecture::Unknown,
  Architecture::arm32,
  Architecture::arm64,
  Architecture::x86,
  Architecture::x86_64,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Architecture(pub i8);
#[allow(non_upper_case_globals)]
impl Architecture {
  pub const Unknown: Self = Self(0);
  pub const arm32: Self = Self(1);
  pub const arm64: Self = Self(2);
  pub const x86: Self = Self(3);
  pub const x86_64: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::arm32,
    Self::arm64,
    Self::x86,
    Self::x86_64,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::arm32 => Some("arm32"),
      Self::arm64 => Some("arm64"),
      Self::x86 => Some("x86"),
      Self::x86_64 => Some("x86_64"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Architecture {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Architecture {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Architecture {
    type Output = Architecture;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Architecture {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Architecture {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Architecture {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FRAME_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FRAME_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FRAME_TYPE: [FrameType; 4] = [
  FrameType::Unknown,
  FrameType::JVM,
  FrameType::DWARF,
  FrameType::AndroidNative,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FrameType(pub i8);
#[allow(non_upper_case_globals)]
impl FrameType {
  pub const Unknown: Self = Self(0);
  pub const JVM: Self = Self(1);
  pub const DWARF: Self = Self(2);
  pub const AndroidNative: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::JVM,
    Self::DWARF,
    Self::AndroidNative,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::JVM => Some("JVM"),
      Self::DWARF => Some("DWARF"),
      Self::AndroidNative => Some("AndroidNative"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FrameType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FrameType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FrameType {
    type Output = FrameType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FrameType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FrameType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FrameType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ERROR_RELATION: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ERROR_RELATION: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ERROR_RELATION: [ErrorRelation; 1] = [
  ErrorRelation::CausedBy,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ErrorRelation(pub i8);
#[allow(non_upper_case_globals)]
impl ErrorRelation {
  pub const CausedBy: Self = Self(1);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CausedBy,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CausedBy => Some("CausedBy"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ErrorRelation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ErrorRelation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ErrorRelation {
    type Output = ErrorRelation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ErrorRelation {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ErrorRelation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ErrorRelation {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_POWER_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_POWER_STATE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_POWER_STATE: [PowerState; 5] = [
  PowerState::Unknown,
  PowerState::RunningOnBattery,
  PowerState::PluggedInNoBattery,
  PowerState::PluggedInCharging,
  PowerState::PluggedInCharged,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PowerState(pub i8);
#[allow(non_upper_case_globals)]
impl PowerState {
  pub const Unknown: Self = Self(0);
  pub const RunningOnBattery: Self = Self(1);
  pub const PluggedInNoBattery: Self = Self(2);
  pub const PluggedInCharging: Self = Self(3);
  pub const PluggedInCharged: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::RunningOnBattery,
    Self::PluggedInNoBattery,
    Self::PluggedInCharging,
    Self::PluggedInCharged,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::RunningOnBattery => Some("RunningOnBattery"),
      Self::PluggedInNoBattery => Some("PluggedInNoBattery"),
      Self::PluggedInCharging => Some("PluggedInCharging"),
      Self::PluggedInCharged => Some("PluggedInCharged"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PowerState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PowerState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PowerState {
    type Output = PowerState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PowerState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PowerState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PowerState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_NETWORK_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_NETWORK_STATE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NETWORK_STATE: [NetworkState; 4] = [
  NetworkState::Unknown,
  NetworkState::Disconnected,
  NetworkState::Cellular,
  NetworkState::WiFi,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NetworkState(pub i8);
#[allow(non_upper_case_globals)]
impl NetworkState {
  pub const Unknown: Self = Self(0);
  pub const Disconnected: Self = Self(1);
  pub const Cellular: Self = Self(2);
  pub const WiFi: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Disconnected,
    Self::Cellular,
    Self::WiFi,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Disconnected => Some("Disconnected"),
      Self::Cellular => Some("Cellular"),
      Self::WiFi => Some("WiFi"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for NetworkState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for NetworkState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for NetworkState {
    type Output = NetworkState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NetworkState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for NetworkState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for NetworkState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ROTATION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ROTATION: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ROTATION: [Rotation; 5] = [
  Rotation::Unknown,
  Rotation::Portrait,
  Rotation::LandscapeRight,
  Rotation::LandscapeLeft,
  Rotation::PortraitUpsideDown,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Rotation(pub i8);
#[allow(non_upper_case_globals)]
impl Rotation {
  pub const Unknown: Self = Self(0);
  pub const Portrait: Self = Self(1);
  pub const LandscapeRight: Self = Self(2);
  pub const LandscapeLeft: Self = Self(3);
  pub const PortraitUpsideDown: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Portrait,
    Self::LandscapeRight,
    Self::LandscapeLeft,
    Self::PortraitUpsideDown,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Portrait => Some("Portrait"),
      Self::LandscapeRight => Some("LandscapeRight"),
      Self::LandscapeLeft => Some("LandscapeLeft"),
      Self::PortraitUpsideDown => Some("PortraitUpsideDown"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Rotation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Rotation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Rotation {
    type Output = Rotation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Rotation {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Rotation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Rotation {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FRAME_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FRAME_STATUS: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FRAME_STATUS: [FrameStatus; 5] = [
  FrameStatus::Missing,
  FrameStatus::Symbolicated,
  FrameStatus::MissingSymbol,
  FrameStatus::UnknownImage,
  FrameStatus::Malformed,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FrameStatus(pub i8);
#[allow(non_upper_case_globals)]
impl FrameStatus {
  pub const Missing: Self = Self(0);
  pub const Symbolicated: Self = Self(1);
  pub const MissingSymbol: Self = Self(2);
  pub const UnknownImage: Self = Self(3);
  pub const Malformed: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Missing,
    Self::Symbolicated,
    Self::MissingSymbol,
    Self::UnknownImage,
    Self::Malformed,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Missing => Some("Missing"),
      Self::Symbolicated => Some("Symbolicated"),
      Self::MissingSymbol => Some("MissingSymbol"),
      Self::UnknownImage => Some("UnknownImage"),
      Self::Malformed => Some("Malformed"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FrameStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FrameStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FrameStatus {
    type Output = FrameStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FrameStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FrameStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FrameStatus {}
// struct Timestamp, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Timestamp(pub [u8; 16]);
impl Default for Timestamp { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Timestamp {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Timestamp")
      .field("seconds", &self.seconds())
      .field("nanos", &self.nanos())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Timestamp as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for Timestamp {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Timestamp {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    seconds: u64,
    nanos: u32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_seconds(seconds);
    s.set_nanos(nanos);
    s
  }

  pub fn seconds(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_seconds(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn nanos(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_nanos(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Memory, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Memory(pub [u8; 24]);
impl Default for Memory { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for Memory {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Memory")
      .field("total", &self.total())
      .field("free", &self.free())
      .field("used", &self.used())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Memory {}
impl<'a> flatbuffers::Follow<'a> for Memory {
  type Inner = &'a Memory;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Memory>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Memory {
  type Inner = &'a Memory;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Memory>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Memory {
    type Output = Memory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Memory as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for Memory {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Memory {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    total: u64,
    free: u64,
    used: u64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_total(total);
    s.set_free(free);
    s.set_used(used);
    s
  }

  pub fn total(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_total(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn free(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_free(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn used(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_used(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum AppBuildNumberOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppBuildNumber<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppBuildNumber<'a> {
  type Inner = AppBuildNumber<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppBuildNumber<'a> {
  pub const VT_VERSION_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_CF_BUNDLE_VERSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppBuildNumber { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppBuildNumberArgs<'args>
  ) -> flatbuffers::WIPOffset<AppBuildNumber<'bldr>> {
    let mut builder = AppBuildNumberBuilder::new(_fbb);
    builder.add_version_code(args.version_code);
    if let Some(x) = args.cf_bundle_version { builder.add_cf_bundle_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version_code(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AppBuildNumber::VT_VERSION_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cf_bundle_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppBuildNumber::VT_CF_BUNDLE_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for AppBuildNumber<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("version_code", Self::VT_VERSION_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cf_bundle_version", Self::VT_CF_BUNDLE_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct AppBuildNumberArgs<'a> {
    pub version_code: i64,
    pub cf_bundle_version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AppBuildNumberArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppBuildNumberArgs {
      version_code: 0,
      cf_bundle_version: None,
    }
  }
}

pub struct AppBuildNumberBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppBuildNumberBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version_code(&mut self, version_code: i64) {
    self.fbb_.push_slot::<i64>(AppBuildNumber::VT_VERSION_CODE, version_code, 0);
  }
  #[inline]
  pub fn add_cf_bundle_version(&mut self, cf_bundle_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppBuildNumber::VT_CF_BUNDLE_VERSION, cf_bundle_version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppBuildNumberBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppBuildNumberBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppBuildNumber<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppBuildNumber<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppBuildNumber");
      ds.field("version_code", &self.version_code());
      ds.field("cf_bundle_version", &self.cf_bundle_version());
      ds.finish()
  }
}
pub enum ProcessorUsageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ProcessorUsage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProcessorUsage<'a> {
  type Inner = ProcessorUsage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProcessorUsage<'a> {
  pub const VT_DURATION_SECONDS: flatbuffers::VOffsetT = 4;
  pub const VT_USED_PERCENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProcessorUsage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProcessorUsageArgs
  ) -> flatbuffers::WIPOffset<ProcessorUsage<'bldr>> {
    let mut builder = ProcessorUsageBuilder::new(_fbb);
    builder.add_duration_seconds(args.duration_seconds);
    builder.add_used_percent(args.used_percent);
    builder.finish()
  }


  #[inline]
  pub fn duration_seconds(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ProcessorUsage::VT_DURATION_SECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn used_percent(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ProcessorUsage::VT_USED_PERCENT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProcessorUsage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("duration_seconds", Self::VT_DURATION_SECONDS, false)?
     .visit_field::<u8>("used_percent", Self::VT_USED_PERCENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ProcessorUsageArgs {
    pub duration_seconds: u64,
    pub used_percent: u8,
}
impl<'a> Default for ProcessorUsageArgs {
  #[inline]
  fn default() -> Self {
    ProcessorUsageArgs {
      duration_seconds: 0,
      used_percent: 0,
    }
  }
}

pub struct ProcessorUsageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProcessorUsageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_duration_seconds(&mut self, duration_seconds: u64) {
    self.fbb_.push_slot::<u64>(ProcessorUsage::VT_DURATION_SECONDS, duration_seconds, 0);
  }
  #[inline]
  pub fn add_used_percent(&mut self, used_percent: u8) {
    self.fbb_.push_slot::<u8>(ProcessorUsage::VT_USED_PERCENT, used_percent, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProcessorUsageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProcessorUsageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProcessorUsage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProcessorUsage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProcessorUsage");
      ds.field("duration_seconds", &self.duration_seconds());
      ds.field("used_percent", &self.used_percent());
      ds.finish()
  }
}
pub enum AppMetricsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppMetrics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppMetrics<'a> {
  type Inner = AppMetrics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppMetrics<'a> {
  pub const VT_APP_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MEMORY: flatbuffers::VOffsetT = 6;
  pub const VT_VERSION: flatbuffers::VOffsetT = 8;
  pub const VT_BUILD_NUMBER: flatbuffers::VOffsetT = 10;
  pub const VT_RUNNING_STATE: flatbuffers::VOffsetT = 12;
  pub const VT_PROCESS_ID: flatbuffers::VOffsetT = 14;
  pub const VT_REGION_FORMAT: flatbuffers::VOffsetT = 16;
  pub const VT_CPU_USAGE: flatbuffers::VOffsetT = 18;
  pub const VT_LIFECYCLE_EVENT: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppMetrics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppMetricsArgs<'args>
  ) -> flatbuffers::WIPOffset<AppMetrics<'bldr>> {
    let mut builder = AppMetricsBuilder::new(_fbb);
    if let Some(x) = args.lifecycle_event { builder.add_lifecycle_event(x); }
    if let Some(x) = args.cpu_usage { builder.add_cpu_usage(x); }
    if let Some(x) = args.region_format { builder.add_region_format(x); }
    builder.add_process_id(args.process_id);
    if let Some(x) = args.running_state { builder.add_running_state(x); }
    if let Some(x) = args.build_number { builder.add_build_number(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    if let Some(x) = args.memory { builder.add_memory(x); }
    if let Some(x) = args.app_id { builder.add_app_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn app_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppMetrics::VT_APP_ID, None)}
  }
  #[inline]
  pub fn memory(&self) -> Option<&'a Memory> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Memory>(AppMetrics::VT_MEMORY, None)}
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppMetrics::VT_VERSION, None)}
  }
  #[inline]
  pub fn build_number(&self) -> Option<AppBuildNumber<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppBuildNumber>>(AppMetrics::VT_BUILD_NUMBER, None)}
  }
  #[inline]
  pub fn running_state(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppMetrics::VT_RUNNING_STATE, None)}
  }
  #[inline]
  pub fn process_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(AppMetrics::VT_PROCESS_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn region_format(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppMetrics::VT_REGION_FORMAT, None)}
  }
  #[inline]
  pub fn cpu_usage(&self) -> Option<ProcessorUsage<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProcessorUsage>>(AppMetrics::VT_CPU_USAGE, None)}
  }
  #[inline]
  pub fn lifecycle_event(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppMetrics::VT_LIFECYCLE_EVENT, None)}
  }
}

impl flatbuffers::Verifiable for AppMetrics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("app_id", Self::VT_APP_ID, false)?
     .visit_field::<Memory>("memory", Self::VT_MEMORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppBuildNumber>>("build_number", Self::VT_BUILD_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("running_state", Self::VT_RUNNING_STATE, false)?
     .visit_field::<u32>("process_id", Self::VT_PROCESS_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("region_format", Self::VT_REGION_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProcessorUsage>>("cpu_usage", Self::VT_CPU_USAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lifecycle_event", Self::VT_LIFECYCLE_EVENT, false)?
     .finish();
    Ok(())
  }
}
pub struct AppMetricsArgs<'a> {
    pub app_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub memory: Option<&'a Memory>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub build_number: Option<flatbuffers::WIPOffset<AppBuildNumber<'a>>>,
    pub running_state: Option<flatbuffers::WIPOffset<&'a str>>,
    pub process_id: u32,
    pub region_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub cpu_usage: Option<flatbuffers::WIPOffset<ProcessorUsage<'a>>>,
    pub lifecycle_event: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AppMetricsArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppMetricsArgs {
      app_id: None,
      memory: None,
      version: None,
      build_number: None,
      running_state: None,
      process_id: 0,
      region_format: None,
      cpu_usage: None,
      lifecycle_event: None,
    }
  }
}

pub struct AppMetricsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppMetricsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_app_id(&mut self, app_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppMetrics::VT_APP_ID, app_id);
  }
  #[inline]
  pub fn add_memory(&mut self, memory: &Memory) {
    self.fbb_.push_slot_always::<&Memory>(AppMetrics::VT_MEMORY, memory);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppMetrics::VT_VERSION, version);
  }
  #[inline]
  pub fn add_build_number(&mut self, build_number: flatbuffers::WIPOffset<AppBuildNumber<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppBuildNumber>>(AppMetrics::VT_BUILD_NUMBER, build_number);
  }
  #[inline]
  pub fn add_running_state(&mut self, running_state: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppMetrics::VT_RUNNING_STATE, running_state);
  }
  #[inline]
  pub fn add_process_id(&mut self, process_id: u32) {
    self.fbb_.push_slot::<u32>(AppMetrics::VT_PROCESS_ID, process_id, 0);
  }
  #[inline]
  pub fn add_region_format(&mut self, region_format: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppMetrics::VT_REGION_FORMAT, region_format);
  }
  #[inline]
  pub fn add_cpu_usage(&mut self, cpu_usage: flatbuffers::WIPOffset<ProcessorUsage<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProcessorUsage>>(AppMetrics::VT_CPU_USAGE, cpu_usage);
  }
  #[inline]
  pub fn add_lifecycle_event(&mut self, lifecycle_event: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppMetrics::VT_LIFECYCLE_EVENT, lifecycle_event);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppMetricsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppMetricsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppMetrics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppMetrics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppMetrics");
      ds.field("app_id", &self.app_id());
      ds.field("memory", &self.memory());
      ds.field("version", &self.version());
      ds.field("build_number", &self.build_number());
      ds.field("running_state", &self.running_state());
      ds.field("process_id", &self.process_id());
      ds.field("region_format", &self.region_format());
      ds.field("cpu_usage", &self.cpu_usage());
      ds.field("lifecycle_event", &self.lifecycle_event());
      ds.finish()
  }
}
pub enum OSBuildOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OSBuild<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OSBuild<'a> {
  type Inner = OSBuild<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OSBuild<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_BRAND: flatbuffers::VOffsetT = 6;
  pub const VT_FINGERPRINT: flatbuffers::VOffsetT = 8;
  pub const VT_KERN_OSVERSION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OSBuild { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OSBuildArgs<'args>
  ) -> flatbuffers::WIPOffset<OSBuild<'bldr>> {
    let mut builder = OSBuildBuilder::new(_fbb);
    if let Some(x) = args.kern_osversion { builder.add_kern_osversion(x); }
    if let Some(x) = args.fingerprint { builder.add_fingerprint(x); }
    if let Some(x) = args.brand { builder.add_brand(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OSBuild::VT_VERSION, None)}
  }
  #[inline]
  pub fn brand(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OSBuild::VT_BRAND, None)}
  }
  #[inline]
  pub fn fingerprint(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OSBuild::VT_FINGERPRINT, None)}
  }
  #[inline]
  pub fn kern_osversion(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OSBuild::VT_KERN_OSVERSION, None)}
  }
}

impl flatbuffers::Verifiable for OSBuild<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("brand", Self::VT_BRAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fingerprint", Self::VT_FINGERPRINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("kern_osversion", Self::VT_KERN_OSVERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct OSBuildArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub brand: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fingerprint: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kern_osversion: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OSBuildArgs<'a> {
  #[inline]
  fn default() -> Self {
    OSBuildArgs {
      version: None,
      brand: None,
      fingerprint: None,
      kern_osversion: None,
    }
  }
}

pub struct OSBuildBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OSBuildBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OSBuild::VT_VERSION, version);
  }
  #[inline]
  pub fn add_brand(&mut self, brand: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OSBuild::VT_BRAND, brand);
  }
  #[inline]
  pub fn add_fingerprint(&mut self, fingerprint: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OSBuild::VT_FINGERPRINT, fingerprint);
  }
  #[inline]
  pub fn add_kern_osversion(&mut self, kern_osversion: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OSBuild::VT_KERN_OSVERSION, kern_osversion);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OSBuildBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OSBuildBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OSBuild<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OSBuild<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OSBuild");
      ds.field("version", &self.version());
      ds.field("brand", &self.brand());
      ds.field("fingerprint", &self.fingerprint());
      ds.field("kern_osversion", &self.kern_osversion());
      ds.finish()
  }
}
pub enum PowerMetricsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PowerMetrics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PowerMetrics<'a> {
  type Inner = PowerMetrics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PowerMetrics<'a> {
  pub const VT_POWER_STATE: flatbuffers::VOffsetT = 4;
  pub const VT_CHARGE_PERCENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PowerMetrics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PowerMetricsArgs
  ) -> flatbuffers::WIPOffset<PowerMetrics<'bldr>> {
    let mut builder = PowerMetricsBuilder::new(_fbb);
    builder.add_charge_percent(args.charge_percent);
    builder.add_power_state(args.power_state);
    builder.finish()
  }


  #[inline]
  pub fn power_state(&self) -> PowerState {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PowerState>(PowerMetrics::VT_POWER_STATE, Some(PowerState::Unknown)).unwrap()}
  }
  #[inline]
  pub fn charge_percent(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PowerMetrics::VT_CHARGE_PERCENT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PowerMetrics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<PowerState>("power_state", Self::VT_POWER_STATE, false)?
     .visit_field::<u8>("charge_percent", Self::VT_CHARGE_PERCENT, false)?
     .finish();
    Ok(())
  }
}
pub struct PowerMetricsArgs {
    pub power_state: PowerState,
    pub charge_percent: u8,
}
impl<'a> Default for PowerMetricsArgs {
  #[inline]
  fn default() -> Self {
    PowerMetricsArgs {
      power_state: PowerState::Unknown,
      charge_percent: 0,
    }
  }
}

pub struct PowerMetricsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PowerMetricsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_power_state(&mut self, power_state: PowerState) {
    self.fbb_.push_slot::<PowerState>(PowerMetrics::VT_POWER_STATE, power_state, PowerState::Unknown);
  }
  #[inline]
  pub fn add_charge_percent(&mut self, charge_percent: u8) {
    self.fbb_.push_slot::<u8>(PowerMetrics::VT_CHARGE_PERCENT, charge_percent, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PowerMetricsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PowerMetricsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PowerMetrics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PowerMetrics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PowerMetrics");
      ds.field("power_state", &self.power_state());
      ds.field("charge_percent", &self.charge_percent());
      ds.finish()
  }
}
pub enum DisplayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Display<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Display<'a> {
  type Inner = Display<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Display<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_DENSITY_DPI: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Display { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DisplayArgs
  ) -> flatbuffers::WIPOffset<Display<'bldr>> {
    let mut builder = DisplayBuilder::new(_fbb);
    builder.add_density_dpi(args.density_dpi);
    builder.add_width(args.width);
    builder.add_height(args.height);
    builder.finish()
  }


  #[inline]
  pub fn height(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Display::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Display::VT_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn density_dpi(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Display::VT_DENSITY_DPI, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Display<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<u32>("width", Self::VT_WIDTH, false)?
     .visit_field::<u32>("density_dpi", Self::VT_DENSITY_DPI, false)?
     .finish();
    Ok(())
  }
}
pub struct DisplayArgs {
    pub height: u32,
    pub width: u32,
    pub density_dpi: u32,
}
impl<'a> Default for DisplayArgs {
  #[inline]
  fn default() -> Self {
    DisplayArgs {
      height: 0,
      width: 0,
      density_dpi: 0,
    }
  }
}

pub struct DisplayBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DisplayBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_height(&mut self, height: u32) {
    self.fbb_.push_slot::<u32>(Display::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_width(&mut self, width: u32) {
    self.fbb_.push_slot::<u32>(Display::VT_WIDTH, width, 0);
  }
  #[inline]
  pub fn add_density_dpi(&mut self, density_dpi: u32) {
    self.fbb_.push_slot::<u32>(Display::VT_DENSITY_DPI, density_dpi, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DisplayBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DisplayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Display<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Display<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Display");
      ds.field("height", &self.height());
      ds.field("width", &self.width());
      ds.field("density_dpi", &self.density_dpi());
      ds.finish()
  }
}
pub enum DeviceMetricsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DeviceMetrics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeviceMetrics<'a> {
  type Inner = DeviceMetrics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DeviceMetrics<'a> {
  pub const VT_TIME: flatbuffers::VOffsetT = 4;
  pub const VT_TIMEZONE: flatbuffers::VOffsetT = 6;
  pub const VT_POWER_METRICS: flatbuffers::VOffsetT = 8;
  pub const VT_NETWORK_STATE: flatbuffers::VOffsetT = 10;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 12;
  pub const VT_ARCH: flatbuffers::VOffsetT = 14;
  pub const VT_DISPLAY: flatbuffers::VOffsetT = 16;
  pub const VT_MANUFACTURER: flatbuffers::VOffsetT = 18;
  pub const VT_MODEL: flatbuffers::VOffsetT = 20;
  pub const VT_OS_BUILD: flatbuffers::VOffsetT = 22;
  pub const VT_PLATFORM: flatbuffers::VOffsetT = 24;
  pub const VT_CPU_ABIS: flatbuffers::VOffsetT = 26;
  pub const VT_LOW_POWER_MODE_ENABLED: flatbuffers::VOffsetT = 28;
  pub const VT_CPU_USAGE: flatbuffers::VOffsetT = 30;
  pub const VT_THERMAL_STATE: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DeviceMetrics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DeviceMetricsArgs<'args>
  ) -> flatbuffers::WIPOffset<DeviceMetrics<'bldr>> {
    let mut builder = DeviceMetricsBuilder::new(_fbb);
    if let Some(x) = args.cpu_usage { builder.add_cpu_usage(x); }
    if let Some(x) = args.cpu_abis { builder.add_cpu_abis(x); }
    if let Some(x) = args.os_build { builder.add_os_build(x); }
    if let Some(x) = args.model { builder.add_model(x); }
    if let Some(x) = args.manufacturer { builder.add_manufacturer(x); }
    if let Some(x) = args.display { builder.add_display(x); }
    if let Some(x) = args.power_metrics { builder.add_power_metrics(x); }
    if let Some(x) = args.timezone { builder.add_timezone(x); }
    if let Some(x) = args.time { builder.add_time(x); }
    builder.add_thermal_state(args.thermal_state);
    builder.add_low_power_mode_enabled(args.low_power_mode_enabled);
    builder.add_platform(args.platform);
    builder.add_arch(args.arch);
    builder.add_rotation(args.rotation);
    builder.add_network_state(args.network_state);
    builder.finish()
  }


  #[inline]
  pub fn time(&self) -> Option<&'a Timestamp> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Timestamp>(DeviceMetrics::VT_TIME, None)}
  }
  #[inline]
  pub fn timezone(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeviceMetrics::VT_TIMEZONE, None)}
  }
  #[inline]
  pub fn power_metrics(&self) -> Option<PowerMetrics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PowerMetrics>>(DeviceMetrics::VT_POWER_METRICS, None)}
  }
  #[inline]
  pub fn network_state(&self) -> NetworkState {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NetworkState>(DeviceMetrics::VT_NETWORK_STATE, Some(NetworkState::Unknown)).unwrap()}
  }
  #[inline]
  pub fn rotation(&self) -> Rotation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rotation>(DeviceMetrics::VT_ROTATION, Some(Rotation::Unknown)).unwrap()}
  }
  #[inline]
  pub fn arch(&self) -> Architecture {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Architecture>(DeviceMetrics::VT_ARCH, Some(Architecture::Unknown)).unwrap()}
  }
  #[inline]
  pub fn display(&self) -> Option<Display<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Display>>(DeviceMetrics::VT_DISPLAY, None)}
  }
  #[inline]
  pub fn manufacturer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeviceMetrics::VT_MANUFACTURER, None)}
  }
  #[inline]
  pub fn model(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DeviceMetrics::VT_MODEL, None)}
  }
  #[inline]
  pub fn os_build(&self) -> Option<OSBuild<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<OSBuild>>(DeviceMetrics::VT_OS_BUILD, None)}
  }
  #[inline]
  pub fn platform(&self) -> Platform {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Platform>(DeviceMetrics::VT_PLATFORM, Some(Platform::Unknown)).unwrap()}
  }
  #[inline]
  pub fn cpu_abis(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DeviceMetrics::VT_CPU_ABIS, None)}
  }
  #[inline]
  pub fn low_power_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DeviceMetrics::VT_LOW_POWER_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn cpu_usage(&self) -> Option<ProcessorUsage<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ProcessorUsage>>(DeviceMetrics::VT_CPU_USAGE, None)}
  }
  #[inline]
  pub fn thermal_state(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DeviceMetrics::VT_THERMAL_STATE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DeviceMetrics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Timestamp>("time", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("timezone", Self::VT_TIMEZONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PowerMetrics>>("power_metrics", Self::VT_POWER_METRICS, false)?
     .visit_field::<NetworkState>("network_state", Self::VT_NETWORK_STATE, false)?
     .visit_field::<Rotation>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<Architecture>("arch", Self::VT_ARCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Display>>("display", Self::VT_DISPLAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("manufacturer", Self::VT_MANUFACTURER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("model", Self::VT_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OSBuild>>("os_build", Self::VT_OS_BUILD, false)?
     .visit_field::<Platform>("platform", Self::VT_PLATFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("cpu_abis", Self::VT_CPU_ABIS, false)?
     .visit_field::<bool>("low_power_mode_enabled", Self::VT_LOW_POWER_MODE_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ProcessorUsage>>("cpu_usage", Self::VT_CPU_USAGE, false)?
     .visit_field::<u8>("thermal_state", Self::VT_THERMAL_STATE, false)?
     .finish();
    Ok(())
  }
}
pub struct DeviceMetricsArgs<'a> {
    pub time: Option<&'a Timestamp>,
    pub timezone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub power_metrics: Option<flatbuffers::WIPOffset<PowerMetrics<'a>>>,
    pub network_state: NetworkState,
    pub rotation: Rotation,
    pub arch: Architecture,
    pub display: Option<flatbuffers::WIPOffset<Display<'a>>>,
    pub manufacturer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub model: Option<flatbuffers::WIPOffset<&'a str>>,
    pub os_build: Option<flatbuffers::WIPOffset<OSBuild<'a>>>,
    pub platform: Platform,
    pub cpu_abis: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub low_power_mode_enabled: bool,
    pub cpu_usage: Option<flatbuffers::WIPOffset<ProcessorUsage<'a>>>,
    pub thermal_state: u8,
}
impl<'a> Default for DeviceMetricsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeviceMetricsArgs {
      time: None,
      timezone: None,
      power_metrics: None,
      network_state: NetworkState::Unknown,
      rotation: Rotation::Unknown,
      arch: Architecture::Unknown,
      display: None,
      manufacturer: None,
      model: None,
      os_build: None,
      platform: Platform::Unknown,
      cpu_abis: None,
      low_power_mode_enabled: false,
      cpu_usage: None,
      thermal_state: 0,
    }
  }
}

pub struct DeviceMetricsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DeviceMetricsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_time(&mut self, time: &Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(DeviceMetrics::VT_TIME, time);
  }
  #[inline]
  pub fn add_timezone(&mut self, timezone: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceMetrics::VT_TIMEZONE, timezone);
  }
  #[inline]
  pub fn add_power_metrics(&mut self, power_metrics: flatbuffers::WIPOffset<PowerMetrics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PowerMetrics>>(DeviceMetrics::VT_POWER_METRICS, power_metrics);
  }
  #[inline]
  pub fn add_network_state(&mut self, network_state: NetworkState) {
    self.fbb_.push_slot::<NetworkState>(DeviceMetrics::VT_NETWORK_STATE, network_state, NetworkState::Unknown);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: Rotation) {
    self.fbb_.push_slot::<Rotation>(DeviceMetrics::VT_ROTATION, rotation, Rotation::Unknown);
  }
  #[inline]
  pub fn add_arch(&mut self, arch: Architecture) {
    self.fbb_.push_slot::<Architecture>(DeviceMetrics::VT_ARCH, arch, Architecture::Unknown);
  }
  #[inline]
  pub fn add_display(&mut self, display: flatbuffers::WIPOffset<Display<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Display>>(DeviceMetrics::VT_DISPLAY, display);
  }
  #[inline]
  pub fn add_manufacturer(&mut self, manufacturer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceMetrics::VT_MANUFACTURER, manufacturer);
  }
  #[inline]
  pub fn add_model(&mut self, model: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceMetrics::VT_MODEL, model);
  }
  #[inline]
  pub fn add_os_build(&mut self, os_build: flatbuffers::WIPOffset<OSBuild<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<OSBuild>>(DeviceMetrics::VT_OS_BUILD, os_build);
  }
  #[inline]
  pub fn add_platform(&mut self, platform: Platform) {
    self.fbb_.push_slot::<Platform>(DeviceMetrics::VT_PLATFORM, platform, Platform::Unknown);
  }
  #[inline]
  pub fn add_cpu_abis(&mut self, cpu_abis: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DeviceMetrics::VT_CPU_ABIS, cpu_abis);
  }
  #[inline]
  pub fn add_low_power_mode_enabled(&mut self, low_power_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(DeviceMetrics::VT_LOW_POWER_MODE_ENABLED, low_power_mode_enabled, false);
  }
  #[inline]
  pub fn add_cpu_usage(&mut self, cpu_usage: flatbuffers::WIPOffset<ProcessorUsage<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ProcessorUsage>>(DeviceMetrics::VT_CPU_USAGE, cpu_usage);
  }
  #[inline]
  pub fn add_thermal_state(&mut self, thermal_state: u8) {
    self.fbb_.push_slot::<u8>(DeviceMetrics::VT_THERMAL_STATE, thermal_state, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DeviceMetricsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DeviceMetricsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeviceMetrics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DeviceMetrics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DeviceMetrics");
      ds.field("time", &self.time());
      ds.field("timezone", &self.timezone());
      ds.field("power_metrics", &self.power_metrics());
      ds.field("network_state", &self.network_state());
      ds.field("rotation", &self.rotation());
      ds.field("arch", &self.arch());
      ds.field("display", &self.display());
      ds.field("manufacturer", &self.manufacturer());
      ds.field("model", &self.model());
      ds.field("os_build", &self.os_build());
      ds.field("platform", &self.platform());
      ds.field("cpu_abis", &self.cpu_abis());
      ds.field("low_power_mode_enabled", &self.low_power_mode_enabled());
      ds.field("cpu_usage", &self.cpu_usage());
      ds.field("thermal_state", &self.thermal_state());
      ds.finish()
  }
}
pub enum SourceFileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SourceFile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceFile<'a> {
  type Inner = SourceFile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SourceFile<'a> {
  pub const VT_PATH: flatbuffers::VOffsetT = 4;
  pub const VT_LINE: flatbuffers::VOffsetT = 6;
  pub const VT_COLUMN: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SourceFile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SourceFileArgs<'args>
  ) -> flatbuffers::WIPOffset<SourceFile<'bldr>> {
    let mut builder = SourceFileBuilder::new(_fbb);
    builder.add_column(args.column);
    builder.add_line(args.line);
    if let Some(x) = args.path { builder.add_path(x); }
    builder.finish()
  }


  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SourceFile::VT_PATH, None)}
  }
  #[inline]
  pub fn line(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SourceFile::VT_LINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn column(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SourceFile::VT_COLUMN, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SourceFile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<i64>("line", Self::VT_LINE, false)?
     .visit_field::<i64>("column", Self::VT_COLUMN, false)?
     .finish();
    Ok(())
  }
}
pub struct SourceFileArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub line: i64,
    pub column: i64,
}
impl<'a> Default for SourceFileArgs<'a> {
  #[inline]
  fn default() -> Self {
    SourceFileArgs {
      path: None,
      line: 0,
      column: 0,
    }
  }
}

pub struct SourceFileBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SourceFileBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SourceFile::VT_PATH, path);
  }
  #[inline]
  pub fn add_line(&mut self, line: i64) {
    self.fbb_.push_slot::<i64>(SourceFile::VT_LINE, line, 0);
  }
  #[inline]
  pub fn add_column(&mut self, column: i64) {
    self.fbb_.push_slot::<i64>(SourceFile::VT_COLUMN, column, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SourceFileBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SourceFileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SourceFile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SourceFile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SourceFile");
      ds.field("path", &self.path());
      ds.field("line", &self.line());
      ds.field("column", &self.column());
      ds.finish()
  }
}
pub enum CPURegisterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CPURegister<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CPURegister<'a> {
  type Inner = CPURegister<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CPURegister<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CPURegister { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CPURegisterArgs<'args>
  ) -> flatbuffers::WIPOffset<CPURegister<'bldr>> {
    let mut builder = CPURegisterBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CPURegister::VT_NAME, None)}
  }
  #[inline]
  pub fn value(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CPURegister::VT_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CPURegister<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CPURegisterArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: u64,
}
impl<'a> Default for CPURegisterArgs<'a> {
  #[inline]
  fn default() -> Self {
    CPURegisterArgs {
      name: None,
      value: 0,
    }
  }
}

pub struct CPURegisterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CPURegisterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CPURegister::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: u64) {
    self.fbb_.push_slot::<u64>(CPURegister::VT_VALUE, value, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CPURegisterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CPURegisterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CPURegister<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CPURegister<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CPURegister");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum FrameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Frame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
  type Inner = Frame<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Frame<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_CLASS_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_SYMBOL_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_SOURCE_FILE: flatbuffers::VOffsetT = 10;
  pub const VT_IMAGE_ID: flatbuffers::VOffsetT = 12;
  pub const VT_FRAME_ADDRESS: flatbuffers::VOffsetT = 14;
  pub const VT_SYMBOL_ADDRESS: flatbuffers::VOffsetT = 16;
  pub const VT_REGISTERS: flatbuffers::VOffsetT = 18;
  pub const VT_STATE: flatbuffers::VOffsetT = 20;
  pub const VT_FRAME_STATUS: flatbuffers::VOffsetT = 22;
  pub const VT_ORIGINAL_INDEX: flatbuffers::VOffsetT = 24;
  pub const VT_IN_APP: flatbuffers::VOffsetT = 26;
  pub const VT_SYMBOLICATED_NAME: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Frame { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FrameArgs<'args>
  ) -> flatbuffers::WIPOffset<Frame<'bldr>> {
    let mut builder = FrameBuilder::new(_fbb);
    builder.add_original_index(args.original_index);
    builder.add_symbol_address(args.symbol_address);
    builder.add_frame_address(args.frame_address);
    if let Some(x) = args.symbolicated_name { builder.add_symbolicated_name(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.registers { builder.add_registers(x); }
    if let Some(x) = args.image_id { builder.add_image_id(x); }
    if let Some(x) = args.source_file { builder.add_source_file(x); }
    if let Some(x) = args.symbol_name { builder.add_symbol_name(x); }
    if let Some(x) = args.class_name { builder.add_class_name(x); }
    builder.add_in_app(args.in_app);
    builder.add_frame_status(args.frame_status);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> FrameType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FrameType>(Frame::VT_TYPE_, Some(FrameType::Unknown)).unwrap()}
  }
  #[inline]
  pub fn class_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Frame::VT_CLASS_NAME, None)}
  }
  #[inline]
  pub fn symbol_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Frame::VT_SYMBOL_NAME, None)}
  }
  #[inline]
  pub fn source_file(&self) -> Option<SourceFile<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SourceFile>>(Frame::VT_SOURCE_FILE, None)}
  }
  #[inline]
  pub fn image_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Frame::VT_IMAGE_ID, None)}
  }
  #[inline]
  pub fn frame_address(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Frame::VT_FRAME_ADDRESS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn symbol_address(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Frame::VT_SYMBOL_ADDRESS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn registers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CPURegister<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CPURegister>>>>(Frame::VT_REGISTERS, None)}
  }
  #[inline]
  pub fn state(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Frame::VT_STATE, None)}
  }
  #[inline]
  pub fn frame_status(&self) -> FrameStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FrameStatus>(Frame::VT_FRAME_STATUS, Some(FrameStatus::Missing)).unwrap()}
  }
  #[inline]
  pub fn original_index(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Frame::VT_ORIGINAL_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_app(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Frame::VT_IN_APP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn symbolicated_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Frame::VT_SYMBOLICATED_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Frame<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<FrameType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("class_name", Self::VT_CLASS_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("symbol_name", Self::VT_SYMBOL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SourceFile>>("source_file", Self::VT_SOURCE_FILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image_id", Self::VT_IMAGE_ID, false)?
     .visit_field::<u64>("frame_address", Self::VT_FRAME_ADDRESS, false)?
     .visit_field::<u64>("symbol_address", Self::VT_SYMBOL_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CPURegister>>>>("registers", Self::VT_REGISTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("state", Self::VT_STATE, false)?
     .visit_field::<FrameStatus>("frame_status", Self::VT_FRAME_STATUS, false)?
     .visit_field::<u64>("original_index", Self::VT_ORIGINAL_INDEX, false)?
     .visit_field::<bool>("in_app", Self::VT_IN_APP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("symbolicated_name", Self::VT_SYMBOLICATED_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct FrameArgs<'a> {
    pub type_: FrameType,
    pub class_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub symbol_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source_file: Option<flatbuffers::WIPOffset<SourceFile<'a>>>,
    pub image_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frame_address: u64,
    pub symbol_address: u64,
    pub registers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CPURegister<'a>>>>>,
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frame_status: FrameStatus,
    pub original_index: u64,
    pub in_app: bool,
    pub symbolicated_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FrameArgs<'a> {
  #[inline]
  fn default() -> Self {
    FrameArgs {
      type_: FrameType::Unknown,
      class_name: None,
      symbol_name: None,
      source_file: None,
      image_id: None,
      frame_address: 0,
      symbol_address: 0,
      registers: None,
      state: None,
      frame_status: FrameStatus::Missing,
      original_index: 0,
      in_app: false,
      symbolicated_name: None,
    }
  }
}

pub struct FrameBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FrameBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: FrameType) {
    self.fbb_.push_slot::<FrameType>(Frame::VT_TYPE_, type_, FrameType::Unknown);
  }
  #[inline]
  pub fn add_class_name(&mut self, class_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_CLASS_NAME, class_name);
  }
  #[inline]
  pub fn add_symbol_name(&mut self, symbol_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_SYMBOL_NAME, symbol_name);
  }
  #[inline]
  pub fn add_source_file(&mut self, source_file: flatbuffers::WIPOffset<SourceFile<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SourceFile>>(Frame::VT_SOURCE_FILE, source_file);
  }
  #[inline]
  pub fn add_image_id(&mut self, image_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_IMAGE_ID, image_id);
  }
  #[inline]
  pub fn add_frame_address(&mut self, frame_address: u64) {
    self.fbb_.push_slot::<u64>(Frame::VT_FRAME_ADDRESS, frame_address, 0);
  }
  #[inline]
  pub fn add_symbol_address(&mut self, symbol_address: u64) {
    self.fbb_.push_slot::<u64>(Frame::VT_SYMBOL_ADDRESS, symbol_address, 0);
  }
  #[inline]
  pub fn add_registers(&mut self, registers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CPURegister<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_REGISTERS, registers);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_STATE, state);
  }
  #[inline]
  pub fn add_frame_status(&mut self, frame_status: FrameStatus) {
    self.fbb_.push_slot::<FrameStatus>(Frame::VT_FRAME_STATUS, frame_status, FrameStatus::Missing);
  }
  #[inline]
  pub fn add_original_index(&mut self, original_index: u64) {
    self.fbb_.push_slot::<u64>(Frame::VT_ORIGINAL_INDEX, original_index, 0);
  }
  #[inline]
  pub fn add_in_app(&mut self, in_app: bool) {
    self.fbb_.push_slot::<bool>(Frame::VT_IN_APP, in_app, false);
  }
  #[inline]
  pub fn add_symbolicated_name(&mut self, symbolicated_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_SYMBOLICATED_NAME, symbolicated_name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FrameBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Frame<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Frame");
      ds.field("type_", &self.type_());
      ds.field("class_name", &self.class_name());
      ds.field("symbol_name", &self.symbol_name());
      ds.field("source_file", &self.source_file());
      ds.field("image_id", &self.image_id());
      ds.field("frame_address", &self.frame_address());
      ds.field("symbol_address", &self.symbol_address());
      ds.field("registers", &self.registers());
      ds.field("state", &self.state());
      ds.field("frame_status", &self.frame_status());
      ds.field("original_index", &self.original_index());
      ds.field("in_app", &self.in_app());
      ds.field("symbolicated_name", &self.symbolicated_name());
      ds.finish()
  }
}
pub enum ThreadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Thread<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Thread<'a> {
  type Inner = Thread<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Thread<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ACTIVE: flatbuffers::VOffsetT = 6;
  pub const VT_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_STATE: flatbuffers::VOffsetT = 10;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 12;
  pub const VT_QUALITY_OF_SERVICE: flatbuffers::VOffsetT = 14;
  pub const VT_STACK_TRACE: flatbuffers::VOffsetT = 16;
  pub const VT_SUMMARY: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Thread { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ThreadArgs<'args>
  ) -> flatbuffers::WIPOffset<Thread<'bldr>> {
    let mut builder = ThreadBuilder::new(_fbb);
    if let Some(x) = args.summary { builder.add_summary(x); }
    if let Some(x) = args.stack_trace { builder.add_stack_trace(x); }
    builder.add_priority(args.priority);
    if let Some(x) = args.state { builder.add_state(x); }
    builder.add_index(args.index);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_quality_of_service(args.quality_of_service);
    builder.add_active(args.active);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Thread::VT_NAME, None)}
  }
  #[inline]
  pub fn active(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Thread::VT_ACTIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Thread::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn state(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Thread::VT_STATE, None)}
  }
  #[inline]
  pub fn priority(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Thread::VT_PRIORITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn quality_of_service(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Thread::VT_QUALITY_OF_SERVICE, Some(-1)).unwrap()}
  }
  #[inline]
  pub fn stack_trace(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame>>>>(Thread::VT_STACK_TRACE, None)}
  }
  #[inline]
  pub fn summary(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Thread::VT_SUMMARY, None)}
  }
}

impl flatbuffers::Verifiable for Thread<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<bool>("active", Self::VT_ACTIVE, false)?
     .visit_field::<u32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("state", Self::VT_STATE, false)?
     .visit_field::<f32>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<i8>("quality_of_service", Self::VT_QUALITY_OF_SERVICE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Frame>>>>("stack_trace", Self::VT_STACK_TRACE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("summary", Self::VT_SUMMARY, false)?
     .finish();
    Ok(())
  }
}
pub struct ThreadArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub active: bool,
    pub index: u32,
    pub state: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: f32,
    pub quality_of_service: i8,
    pub stack_trace: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame<'a>>>>>,
    pub summary: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ThreadArgs<'a> {
  #[inline]
  fn default() -> Self {
    ThreadArgs {
      name: None,
      active: false,
      index: 0,
      state: None,
      priority: 0.0,
      quality_of_service: -1,
      stack_trace: None,
      summary: None,
    }
  }
}

pub struct ThreadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ThreadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Thread::VT_NAME, name);
  }
  #[inline]
  pub fn add_active(&mut self, active: bool) {
    self.fbb_.push_slot::<bool>(Thread::VT_ACTIVE, active, false);
  }
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(Thread::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Thread::VT_STATE, state);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: f32) {
    self.fbb_.push_slot::<f32>(Thread::VT_PRIORITY, priority, 0.0);
  }
  #[inline]
  pub fn add_quality_of_service(&mut self, quality_of_service: i8) {
    self.fbb_.push_slot::<i8>(Thread::VT_QUALITY_OF_SERVICE, quality_of_service, -1);
  }
  #[inline]
  pub fn add_stack_trace(&mut self, stack_trace: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Frame<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Thread::VT_STACK_TRACE, stack_trace);
  }
  #[inline]
  pub fn add_summary(&mut self, summary: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Thread::VT_SUMMARY, summary);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ThreadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ThreadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Thread<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Thread<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Thread");
      ds.field("name", &self.name());
      ds.field("active", &self.active());
      ds.field("index", &self.index());
      ds.field("state", &self.state());
      ds.field("priority", &self.priority());
      ds.field("quality_of_service", &self.quality_of_service());
      ds.field("stack_trace", &self.stack_trace());
      ds.field("summary", &self.summary());
      ds.finish()
  }
}
pub enum ThreadDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ThreadDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ThreadDetails<'a> {
  type Inner = ThreadDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ThreadDetails<'a> {
  pub const VT_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_THREADS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ThreadDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ThreadDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<ThreadDetails<'bldr>> {
    let mut builder = ThreadDetailsBuilder::new(_fbb);
    if let Some(x) = args.threads { builder.add_threads(x); }
    builder.add_count(args.count);
    builder.finish()
  }


  #[inline]
  pub fn count(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ThreadDetails::VT_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn threads(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Thread<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Thread>>>>(ThreadDetails::VT_THREADS, None)}
  }
}

impl flatbuffers::Verifiable for ThreadDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("count", Self::VT_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Thread>>>>("threads", Self::VT_THREADS, false)?
     .finish();
    Ok(())
  }
}
pub struct ThreadDetailsArgs<'a> {
    pub count: u16,
    pub threads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Thread<'a>>>>>,
}
impl<'a> Default for ThreadDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ThreadDetailsArgs {
      count: 0,
      threads: None,
    }
  }
}

pub struct ThreadDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ThreadDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_count(&mut self, count: u16) {
    self.fbb_.push_slot::<u16>(ThreadDetails::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn add_threads(&mut self, threads: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Thread<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ThreadDetails::VT_THREADS, threads);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ThreadDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ThreadDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ThreadDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ThreadDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ThreadDetails");
      ds.field("count", &self.count());
      ds.field("threads", &self.threads());
      ds.finish()
  }
}
pub enum ErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Error<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Error<'a> {
  type Inner = Error<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Error<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_REASON: flatbuffers::VOffsetT = 6;
  pub const VT_STACK_TRACE: flatbuffers::VOffsetT = 8;
  pub const VT_RELATION_TO_NEXT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Error { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ErrorArgs<'args>
  ) -> flatbuffers::WIPOffset<Error<'bldr>> {
    let mut builder = ErrorBuilder::new(_fbb);
    if let Some(x) = args.stack_trace { builder.add_stack_trace(x); }
    if let Some(x) = args.reason { builder.add_reason(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_relation_to_next(args.relation_to_next);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_NAME, None)}
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Error::VT_REASON, None)}
  }
  #[inline]
  pub fn stack_trace(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame>>>>(Error::VT_STACK_TRACE, None)}
  }
  #[inline]
  pub fn relation_to_next(&self) -> ErrorRelation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ErrorRelation>(Error::VT_RELATION_TO_NEXT, Some(ErrorRelation::CausedBy)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Error<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Frame>>>>("stack_trace", Self::VT_STACK_TRACE, false)?
     .visit_field::<ErrorRelation>("relation_to_next", Self::VT_RELATION_TO_NEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct ErrorArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_trace: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Frame<'a>>>>>,
    pub relation_to_next: ErrorRelation,
}
impl<'a> Default for ErrorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ErrorArgs {
      name: None,
      reason: None,
      stack_trace: None,
      relation_to_next: ErrorRelation::CausedBy,
    }
  }
}

pub struct ErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ErrorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_NAME, name);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_REASON, reason);
  }
  #[inline]
  pub fn add_stack_trace(&mut self, stack_trace: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Frame<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Error::VT_STACK_TRACE, stack_trace);
  }
  #[inline]
  pub fn add_relation_to_next(&mut self, relation_to_next: ErrorRelation) {
    self.fbb_.push_slot::<ErrorRelation>(Error::VT_RELATION_TO_NEXT, relation_to_next, ErrorRelation::CausedBy);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ErrorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Error<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Error");
      ds.field("name", &self.name());
      ds.field("reason", &self.reason());
      ds.field("stack_trace", &self.stack_trace());
      ds.field("relation_to_next", &self.relation_to_next());
      ds.finish()
  }
}
pub enum BinaryImageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryImage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryImage<'a> {
  type Inner = BinaryImage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryImage<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PATH: flatbuffers::VOffsetT = 6;
  pub const VT_LOAD_ADDRESS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryImage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryImageArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryImage<'bldr>> {
    let mut builder = BinaryImageBuilder::new(_fbb);
    builder.add_load_address(args.load_address);
    if let Some(x) = args.path { builder.add_path(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryImage::VT_ID, None)}
  }
  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryImage::VT_PATH, None)}
  }
  #[inline]
  pub fn load_address(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BinaryImage::VT_LOAD_ADDRESS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryImage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<u64>("load_address", Self::VT_LOAD_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryImageArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub load_address: u64,
}
impl<'a> Default for BinaryImageArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryImageArgs {
      id: None,
      path: None,
      load_address: 0,
    }
  }
}

pub struct BinaryImageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryImageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryImage::VT_ID, id);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryImage::VT_PATH, path);
  }
  #[inline]
  pub fn add_load_address(&mut self, load_address: u64) {
    self.fbb_.push_slot::<u64>(BinaryImage::VT_LOAD_ADDRESS, load_address, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryImageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryImageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryImage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryImage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryImage");
      ds.field("id", &self.id());
      ds.field("path", &self.path());
      ds.field("load_address", &self.load_address());
      ds.finish()
  }
}
pub enum SDKInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SDKInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SDKInfo<'a> {
  type Inner = SDKInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SDKInfo<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SDKInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SDKInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<SDKInfo<'bldr>> {
    let mut builder = SDKInfoBuilder::new(_fbb);
    if let Some(x) = args.version { builder.add_version(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SDKInfo::VT_ID, None)}
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SDKInfo::VT_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for SDKInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct SDKInfoArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SDKInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    SDKInfoArgs {
      id: None,
      version: None,
    }
  }
}

pub struct SDKInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SDKInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDKInfo::VT_ID, id);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SDKInfo::VT_VERSION, version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SDKInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SDKInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SDKInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SDKInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SDKInfo");
      ds.field("id", &self.id());
      ds.field("version", &self.version());
      ds.finish()
  }
}
pub enum FeatureFlagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FeatureFlag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FeatureFlag<'a> {
  type Inner = FeatureFlag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FeatureFlag<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FeatureFlag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FeatureFlagArgs<'args>
  ) -> flatbuffers::WIPOffset<FeatureFlag<'bldr>> {
    let mut builder = FeatureFlagBuilder::new(_fbb);
    if let Some(x) = args.timestamp { builder.add_timestamp(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FeatureFlag::VT_NAME, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FeatureFlag::VT_VALUE, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> Option<super::super::common::v_1::Timestamp<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::super::common::v_1::Timestamp>>(FeatureFlag::VT_TIMESTAMP, None)}
  }
}

impl flatbuffers::Verifiable for FeatureFlag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::super::common::v_1::Timestamp>>("timestamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct FeatureFlagArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: Option<flatbuffers::WIPOffset<super::super::common::v_1::Timestamp<'a>>>,
}
impl<'a> Default for FeatureFlagArgs<'a> {
  #[inline]
  fn default() -> Self {
    FeatureFlagArgs {
      name: None,
      value: None,
      timestamp: None,
    }
  }
}

pub struct FeatureFlagBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FeatureFlagBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FeatureFlag::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FeatureFlag::VT_VALUE, value);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: flatbuffers::WIPOffset<super::super::common::v_1::Timestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::super::common::v_1::Timestamp>>(FeatureFlag::VT_TIMESTAMP, timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FeatureFlagBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FeatureFlagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FeatureFlag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FeatureFlag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FeatureFlag");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.field("timestamp", &self.timestamp());
      ds.finish()
  }
}
pub enum ReportOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Report<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Report<'a> {
  type Inner = Report<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Report<'a> {
  pub const VT_SDK: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_APP_METRICS: flatbuffers::VOffsetT = 8;
  pub const VT_DEVICE_METRICS: flatbuffers::VOffsetT = 10;
  pub const VT_ERRORS: flatbuffers::VOffsetT = 12;
  pub const VT_THREAD_DETAILS: flatbuffers::VOffsetT = 14;
  pub const VT_BINARY_IMAGES: flatbuffers::VOffsetT = 16;
  pub const VT_STATE: flatbuffers::VOffsetT = 18;
  pub const VT_FEATURE_FLAGS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Report { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ReportArgs<'args>
  ) -> flatbuffers::WIPOffset<Report<'bldr>> {
    let mut builder = ReportBuilder::new(_fbb);
    if let Some(x) = args.feature_flags { builder.add_feature_flags(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    if let Some(x) = args.binary_images { builder.add_binary_images(x); }
    if let Some(x) = args.thread_details { builder.add_thread_details(x); }
    if let Some(x) = args.errors { builder.add_errors(x); }
    if let Some(x) = args.device_metrics { builder.add_device_metrics(x); }
    if let Some(x) = args.app_metrics { builder.add_app_metrics(x); }
    if let Some(x) = args.sdk { builder.add_sdk(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn sdk(&self) -> Option<SDKInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SDKInfo>>(Report::VT_SDK, None)}
  }
  #[inline]
  pub fn type_(&self) -> ReportType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReportType>(Report::VT_TYPE_, Some(ReportType::Unknown)).unwrap()}
  }
  #[inline]
  pub fn app_metrics(&self) -> Option<AppMetrics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppMetrics>>(Report::VT_APP_METRICS, None)}
  }
  #[inline]
  pub fn device_metrics(&self) -> Option<DeviceMetrics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DeviceMetrics>>(Report::VT_DEVICE_METRICS, None)}
  }
  #[inline]
  pub fn errors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Error<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Error>>>>(Report::VT_ERRORS, None)}
  }
  #[inline]
  pub fn thread_details(&self) -> Option<ThreadDetails<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ThreadDetails>>(Report::VT_THREAD_DETAILS, None)}
  }
  #[inline]
  pub fn binary_images(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryImage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryImage>>>>(Report::VT_BINARY_IMAGES, None)}
  }
  #[inline]
  pub fn state(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::super::common::v_1::Field<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::super::common::v_1::Field>>>>(Report::VT_STATE, None)}
  }
  #[inline]
  pub fn feature_flags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureFlag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureFlag>>>>(Report::VT_FEATURE_FLAGS, None)}
  }
}

impl flatbuffers::Verifiable for Report<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SDKInfo>>("sdk", Self::VT_SDK, false)?
     .visit_field::<ReportType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppMetrics>>("app_metrics", Self::VT_APP_METRICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DeviceMetrics>>("device_metrics", Self::VT_DEVICE_METRICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Error>>>>("errors", Self::VT_ERRORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ThreadDetails>>("thread_details", Self::VT_THREAD_DETAILS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryImage>>>>("binary_images", Self::VT_BINARY_IMAGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<super::super::common::v_1::Field>>>>("state", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FeatureFlag>>>>("feature_flags", Self::VT_FEATURE_FLAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct ReportArgs<'a> {
    pub sdk: Option<flatbuffers::WIPOffset<SDKInfo<'a>>>,
    pub type_: ReportType,
    pub app_metrics: Option<flatbuffers::WIPOffset<AppMetrics<'a>>>,
    pub device_metrics: Option<flatbuffers::WIPOffset<DeviceMetrics<'a>>>,
    pub errors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Error<'a>>>>>,
    pub thread_details: Option<flatbuffers::WIPOffset<ThreadDetails<'a>>>,
    pub binary_images: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryImage<'a>>>>>,
    pub state: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<super::super::common::v_1::Field<'a>>>>>,
    pub feature_flags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureFlag<'a>>>>>,
}
impl<'a> Default for ReportArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReportArgs {
      sdk: None,
      type_: ReportType::Unknown,
      app_metrics: None,
      device_metrics: None,
      errors: None,
      thread_details: None,
      binary_images: None,
      state: None,
      feature_flags: None,
    }
  }
}

pub struct ReportBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReportBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sdk(&mut self, sdk: flatbuffers::WIPOffset<SDKInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SDKInfo>>(Report::VT_SDK, sdk);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ReportType) {
    self.fbb_.push_slot::<ReportType>(Report::VT_TYPE_, type_, ReportType::Unknown);
  }
  #[inline]
  pub fn add_app_metrics(&mut self, app_metrics: flatbuffers::WIPOffset<AppMetrics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppMetrics>>(Report::VT_APP_METRICS, app_metrics);
  }
  #[inline]
  pub fn add_device_metrics(&mut self, device_metrics: flatbuffers::WIPOffset<DeviceMetrics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DeviceMetrics>>(Report::VT_DEVICE_METRICS, device_metrics);
  }
  #[inline]
  pub fn add_errors(&mut self, errors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Error<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Report::VT_ERRORS, errors);
  }
  #[inline]
  pub fn add_thread_details(&mut self, thread_details: flatbuffers::WIPOffset<ThreadDetails<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ThreadDetails>>(Report::VT_THREAD_DETAILS, thread_details);
  }
  #[inline]
  pub fn add_binary_images(&mut self, binary_images: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryImage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Report::VT_BINARY_IMAGES, binary_images);
  }
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::super::common::v_1::Field<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Report::VT_STATE, state);
  }
  #[inline]
  pub fn add_feature_flags(&mut self, feature_flags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FeatureFlag<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Report::VT_FEATURE_FLAGS, feature_flags);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ReportBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ReportBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Report<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Report<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Report");
      ds.field("sdk", &self.sdk());
      ds.field("type_", &self.type_());
      ds.field("app_metrics", &self.app_metrics());
      ds.field("device_metrics", &self.device_metrics());
      ds.field("errors", &self.errors());
      ds.field("thread_details", &self.thread_details());
      ds.field("binary_images", &self.binary_images());
      ds.field("state", &self.state());
      ds.field("feature_flags", &self.feature_flags());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Report`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_report_unchecked`.
pub fn root_as_report(buf: &[u8]) -> Result<Report, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Report>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Report` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_report_unchecked`.
pub fn size_prefixed_root_as_report(buf: &[u8]) -> Result<Report, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Report>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Report` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_report_unchecked`.
pub fn root_as_report_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Report<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Report<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Report` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_report_unchecked`.
pub fn size_prefixed_root_as_report_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Report<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Report<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Report and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Report`.
pub unsafe fn root_as_report_unchecked(buf: &[u8]) -> Report {
  flatbuffers::root_unchecked::<Report>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Report and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Report`.
pub unsafe fn size_prefixed_root_as_report_unchecked(buf: &[u8]) -> Report {
  flatbuffers::size_prefixed_root_unchecked::<Report>(buf)
}
#[inline]
pub fn finish_report_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Report<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_report_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Report<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod v1
}  // pub mod issue_reporting
}  // pub mod fbs
}  // pub mod bitdrift_public

