// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 29.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/client/v1/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ClientKillFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientKillFile {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ClientKillFile.api_key_hash)
    pub api_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ClientKillFile.kill_until)
    pub kill_until: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ClientKillFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientKillFile {
    fn default() -> &'a ClientKillFile {
        <ClientKillFile as ::protobuf::Message>::default_instance()
    }
}

impl ClientKillFile {
    pub fn new() -> ClientKillFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_key_hash",
            |m: &ClientKillFile| { &m.api_key_hash },
            |m: &mut ClientKillFile| { &mut m.api_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "kill_until",
            |m: &ClientKillFile| { &m.kill_until },
            |m: &mut ClientKillFile| { &mut m.kill_until },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientKillFile>(
            "ClientKillFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientKillFile {
    const NAME: &'static str = "ClientKillFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.api_key_hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kill_until)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.api_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.api_key_hash);
        }
        if let Some(v) = self.kill_until.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.api_key_hash.is_empty() {
            os.write_bytes(1, &self.api_key_hash)?;
        }
        if let Some(v) = self.kill_until.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientKillFile {
        ClientKillFile::new()
    }

    fn clear(&mut self) {
        self.api_key_hash.clear();
        self.kill_until.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientKillFile {
        static instance: ClientKillFile = ClientKillFile {
            api_key_hash: ::std::vec::Vec::new(),
            kill_until: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientKillFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientKillFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientKillFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientKillFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HandshakeRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.static_device_metadata)
    pub static_device_metadata: ::std::collections::HashMap<::std::string::String, super::payload::Data>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.configuration_version_nonce)
    pub configuration_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.runtime_version_nonce)
    pub runtime_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.previous_disconnect_reason)
    pub previous_disconnect_reason: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.sleep_mode)
    pub sleep_mode: bool,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeRequest {
    fn default() -> &'a HandshakeRequest {
        <HandshakeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeRequest {
    pub fn new() -> HandshakeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "static_device_metadata",
            |m: &HandshakeRequest| { &m.static_device_metadata },
            |m: &mut HandshakeRequest| { &mut m.static_device_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "configuration_version_nonce",
            |m: &HandshakeRequest| { &m.configuration_version_nonce },
            |m: &mut HandshakeRequest| { &mut m.configuration_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runtime_version_nonce",
            |m: &HandshakeRequest| { &m.runtime_version_nonce },
            |m: &mut HandshakeRequest| { &mut m.runtime_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "previous_disconnect_reason",
            |m: &HandshakeRequest| { &m.previous_disconnect_reason },
            |m: &mut HandshakeRequest| { &mut m.previous_disconnect_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sleep_mode",
            |m: &HandshakeRequest| { &m.sleep_mode },
            |m: &mut HandshakeRequest| { &mut m.sleep_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeRequest>(
            "HandshakeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeRequest {
    const NAME: &'static str = "HandshakeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.static_device_metadata.insert(key, value);
                },
                26 => {
                    self.configuration_version_nonce = is.read_string()?;
                },
                34 => {
                    self.runtime_version_nonce = is.read_string()?;
                },
                50 => {
                    self.previous_disconnect_reason = is.read_string()?;
                },
                56 => {
                    self.sleep_mode = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.static_device_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.configuration_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.configuration_version_nonce);
        }
        if !self.runtime_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.runtime_version_nonce);
        }
        if !self.previous_disconnect_reason.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.previous_disconnect_reason);
        }
        if self.sleep_mode != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.static_device_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.configuration_version_nonce.is_empty() {
            os.write_string(3, &self.configuration_version_nonce)?;
        }
        if !self.runtime_version_nonce.is_empty() {
            os.write_string(4, &self.runtime_version_nonce)?;
        }
        if !self.previous_disconnect_reason.is_empty() {
            os.write_string(6, &self.previous_disconnect_reason)?;
        }
        if self.sleep_mode != false {
            os.write_bool(7, self.sleep_mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeRequest {
        HandshakeRequest::new()
    }

    fn clear(&mut self) {
        self.static_device_metadata.clear();
        self.configuration_version_nonce.clear();
        self.runtime_version_nonce.clear();
        self.previous_disconnect_reason.clear();
        self.sleep_mode = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeRequest {
        static instance: ::protobuf::rt::Lazy<HandshakeRequest> = ::protobuf::rt::Lazy::new();
        instance.get(HandshakeRequest::new)
    }
}

impl ::protobuf::MessageFull for HandshakeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadIntentRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.log_count)
    pub log_count: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.byte_count)
    pub byte_count: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.buffer_id)
    pub buffer_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.session_id)
    pub session_id: ::std::string::String,
    // message oneof groups
    pub intent_type: ::std::option::Option<log_upload_intent_request::Intent_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadIntentRequest {
    fn default() -> &'a LogUploadIntentRequest {
        <LogUploadIntentRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadIntentRequest {
    pub fn new() -> LogUploadIntentRequest {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload workflow_action_upload = 5;

    pub fn workflow_action_upload(&self) -> &log_upload_intent_request::WorkflowActionUpload {
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v)) => v,
            _ => <log_upload_intent_request::WorkflowActionUpload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_workflow_action_upload(&mut self) {
        self.intent_type = ::std::option::Option::None;
    }

    pub fn has_workflow_action_upload(&self) -> bool {
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_workflow_action_upload(&mut self, v: log_upload_intent_request::WorkflowActionUpload) {
        self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_workflow_action_upload(&mut self) -> &mut log_upload_intent_request::WorkflowActionUpload {
        if let ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(_)) = self.intent_type {
        } else {
            self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(log_upload_intent_request::WorkflowActionUpload::new()));
        }
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_workflow_action_upload(&mut self) -> log_upload_intent_request::WorkflowActionUpload {
        if self.has_workflow_action_upload() {
            match self.intent_type.take() {
                ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_request::WorkflowActionUpload::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log_count",
            |m: &LogUploadIntentRequest| { &m.log_count },
            |m: &mut LogUploadIntentRequest| { &mut m.log_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "byte_count",
            |m: &LogUploadIntentRequest| { &m.byte_count },
            |m: &mut LogUploadIntentRequest| { &mut m.byte_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buffer_id",
            |m: &LogUploadIntentRequest| { &m.buffer_id },
            |m: &mut LogUploadIntentRequest| { &mut m.buffer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &LogUploadIntentRequest| { &m.intent_uuid },
            |m: &mut LogUploadIntentRequest| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &LogUploadIntentRequest| { &m.session_id },
            |m: &mut LogUploadIntentRequest| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_request::WorkflowActionUpload>(
            "workflow_action_upload",
            LogUploadIntentRequest::has_workflow_action_upload,
            LogUploadIntentRequest::workflow_action_upload,
            LogUploadIntentRequest::mut_workflow_action_upload,
            LogUploadIntentRequest::set_workflow_action_upload,
        ));
        oneofs.push(log_upload_intent_request::Intent_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadIntentRequest>(
            "LogUploadIntentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadIntentRequest {
    const NAME: &'static str = "LogUploadIntentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.log_count = is.read_uint32()?;
                },
                16 => {
                    self.byte_count = is.read_uint32()?;
                },
                26 => {
                    self.buffer_id = is.read_string()?;
                },
                34 => {
                    self.intent_uuid = is.read_string()?;
                },
                50 => {
                    self.session_id = is.read_string()?;
                },
                42 => {
                    self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.log_count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.log_count);
        }
        if self.byte_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.byte_count);
        }
        if !self.buffer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.buffer_id);
        }
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.intent_uuid);
        }
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.session_id);
        }
        if let ::std::option::Option::Some(ref v) = self.intent_type {
            match v {
                &log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.log_count != 0 {
            os.write_uint32(1, self.log_count)?;
        }
        if self.byte_count != 0 {
            os.write_uint32(2, self.byte_count)?;
        }
        if !self.buffer_id.is_empty() {
            os.write_string(3, &self.buffer_id)?;
        }
        if !self.intent_uuid.is_empty() {
            os.write_string(4, &self.intent_uuid)?;
        }
        if !self.session_id.is_empty() {
            os.write_string(6, &self.session_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.intent_type {
            match v {
                &log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadIntentRequest {
        LogUploadIntentRequest::new()
    }

    fn clear(&mut self) {
        self.log_count = 0;
        self.byte_count = 0;
        self.buffer_id.clear();
        self.intent_uuid.clear();
        self.session_id.clear();
        self.intent_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadIntentRequest {
        static instance: LogUploadIntentRequest = LogUploadIntentRequest {
            log_count: 0,
            byte_count: 0,
            buffer_id: ::std::string::String::new(),
            intent_uuid: ::std::string::String::new(),
            session_id: ::std::string::String::new(),
            intent_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadIntentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadIntentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadIntentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadIntentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogUploadIntentRequest`
pub mod log_upload_intent_request {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.intent_type)
    pub enum Intent_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.workflow_action_upload)
        WorkflowActionUpload(WorkflowActionUpload),
    }

    impl ::protobuf::Oneof for Intent_type {
    }

    impl ::protobuf::OneofFull for Intent_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogUploadIntentRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("intent_type").unwrap()).clone()
        }
    }

    impl Intent_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Intent_type>("intent_type")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkflowActionUpload {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload.workflow_action_ids)
        pub workflow_action_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkflowActionUpload {
        fn default() -> &'a WorkflowActionUpload {
            <WorkflowActionUpload as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkflowActionUpload {
        pub fn new() -> WorkflowActionUpload {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "workflow_action_ids",
                |m: &WorkflowActionUpload| { &m.workflow_action_ids },
                |m: &mut WorkflowActionUpload| { &mut m.workflow_action_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowActionUpload>(
                "LogUploadIntentRequest.WorkflowActionUpload",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkflowActionUpload {
        const NAME: &'static str = "WorkflowActionUpload";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.workflow_action_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.workflow_action_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.workflow_action_ids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkflowActionUpload {
            WorkflowActionUpload::new()
        }

        fn clear(&mut self) {
            self.workflow_action_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkflowActionUpload {
            static instance: WorkflowActionUpload = WorkflowActionUpload {
                workflow_action_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkflowActionUpload {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentRequest.WorkflowActionUpload").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkflowActionUpload {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkflowActionUpload {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadIntentResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // message oneof groups
    pub decision: ::std::option::Option<log_upload_intent_response::Decision>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadIntentResponse {
    fn default() -> &'a LogUploadIntentResponse {
        <LogUploadIntentResponse as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadIntentResponse {
    pub fn new() -> LogUploadIntentResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately upload_immediately = 2;

    pub fn upload_immediately(&self) -> &log_upload_intent_response::UploadImmediately {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(ref v)) => v,
            _ => <log_upload_intent_response::UploadImmediately as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upload_immediately(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_upload_immediately(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_immediately(&mut self, v: log_upload_intent_response::UploadImmediately) {
        self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_immediately(&mut self) -> &mut log_upload_intent_response::UploadImmediately {
        if let ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(log_upload_intent_response::UploadImmediately::new()));
        }
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_immediately(&mut self) -> log_upload_intent_response::UploadImmediately {
        if self.has_upload_immediately() {
            match self.decision.take() {
                ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_response::UploadImmediately::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop drop = 3;

    pub fn drop(&self) -> &log_upload_intent_response::Drop {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(ref v)) => v,
            _ => <log_upload_intent_response::Drop as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_drop(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_drop(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: log_upload_intent_response::Drop) {
        self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut log_upload_intent_response::Drop {
        if let ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(log_upload_intent_response::Drop::new()));
        }
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_drop(&mut self) -> log_upload_intent_response::Drop {
        if self.has_drop() {
            match self.decision.take() {
                ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_response::Drop::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &LogUploadIntentResponse| { &m.intent_uuid },
            |m: &mut LogUploadIntentResponse| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_response::UploadImmediately>(
            "upload_immediately",
            LogUploadIntentResponse::has_upload_immediately,
            LogUploadIntentResponse::upload_immediately,
            LogUploadIntentResponse::mut_upload_immediately,
            LogUploadIntentResponse::set_upload_immediately,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_response::Drop>(
            "drop",
            LogUploadIntentResponse::has_drop,
            LogUploadIntentResponse::drop,
            LogUploadIntentResponse::mut_drop,
            LogUploadIntentResponse::set_drop,
        ));
        oneofs.push(log_upload_intent_response::Decision::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadIntentResponse>(
            "LogUploadIntentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadIntentResponse {
    const NAME: &'static str = "LogUploadIntentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                18 => {
                    self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(is.read_message()?));
                },
                26 => {
                    self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &log_upload_intent_response::Decision::UploadImmediately(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_upload_intent_response::Decision::Drop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &log_upload_intent_response::Decision::UploadImmediately(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &log_upload_intent_response::Decision::Drop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadIntentResponse {
        LogUploadIntentResponse::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.decision = ::std::option::Option::None;
        self.decision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadIntentResponse {
        static instance: LogUploadIntentResponse = LogUploadIntentResponse {
            intent_uuid: ::std::string::String::new(),
            decision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadIntentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadIntentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadIntentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadIntentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogUploadIntentResponse`
pub mod log_upload_intent_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.decision)
    pub enum Decision {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.upload_immediately)
        UploadImmediately(UploadImmediately),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.drop)
        Drop(Drop),
    }

    impl ::protobuf::Oneof for Decision {
    }

    impl ::protobuf::OneofFull for Decision {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogUploadIntentResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("decision").unwrap()).clone()
        }
    }

    impl Decision {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Decision>("decision")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UploadImmediately {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UploadImmediately {
        fn default() -> &'a UploadImmediately {
            <UploadImmediately as ::protobuf::Message>::default_instance()
        }
    }

    impl UploadImmediately {
        pub fn new() -> UploadImmediately {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadImmediately>(
                "LogUploadIntentResponse.UploadImmediately",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UploadImmediately {
        const NAME: &'static str = "UploadImmediately";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UploadImmediately {
            UploadImmediately::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UploadImmediately {
            static instance: UploadImmediately = UploadImmediately {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UploadImmediately {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentResponse.UploadImmediately").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UploadImmediately {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UploadImmediately {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drop {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drop {
        fn default() -> &'a Drop {
            <Drop as ::protobuf::Message>::default_instance()
        }
    }

    impl Drop {
        pub fn new() -> Drop {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Drop>(
                "LogUploadIntentResponse.Drop",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Drop {
        const NAME: &'static str = "Drop";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drop {
            Drop::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drop {
            static instance: Drop = Drop {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Drop {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentResponse.Drop").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Drop {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Drop {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.logs)
    pub logs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.buffer_uuid)
    pub buffer_uuid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadRequest {
    fn default() -> &'a LogUploadRequest {
        <LogUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadRequest {
    pub fn new() -> LogUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &LogUploadRequest| { &m.upload_uuid },
            |m: &mut LogUploadRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &LogUploadRequest| { &m.logs },
            |m: &mut LogUploadRequest| { &mut m.logs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buffer_uuid",
            |m: &LogUploadRequest| { &m.buffer_uuid },
            |m: &mut LogUploadRequest| { &mut m.buffer_uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadRequest>(
            "LogUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadRequest {
    const NAME: &'static str = "LogUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.logs.push(is.read_bytes()?);
                },
                26 => {
                    self.buffer_uuid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        for value in &self.logs {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.buffer_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.buffer_uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        for v in &self.logs {
            os.write_bytes(2, &v)?;
        };
        if !self.buffer_uuid.is_empty() {
            os.write_string(3, &self.buffer_uuid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadRequest {
        LogUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.logs.clear();
        self.buffer_uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadRequest {
        static instance: LogUploadRequest = LogUploadRequest {
            upload_uuid: ::std::string::String::new(),
            logs: ::std::vec::Vec::new(),
            buffer_uuid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.PingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.PingRequest.sleep_mode)
    pub sleep_mode: bool,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sleep_mode",
            |m: &PingRequest| { &m.sleep_mode },
            |m: &mut PingRequest| { &mut m.sleep_mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sleep_mode = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.sleep_mode != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.sleep_mode != false {
            os.write_bool(1, self.sleep_mode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.sleep_mode = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            sleep_mode: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigurationUpdateAck {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.last_applied_version_nonce)
    pub last_applied_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.nack)
    pub nack: ::protobuf::MessageField<configuration_update_ack::Nack>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigurationUpdateAck {
    fn default() -> &'a ConfigurationUpdateAck {
        <ConfigurationUpdateAck as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationUpdateAck {
    pub fn new() -> ConfigurationUpdateAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_applied_version_nonce",
            |m: &ConfigurationUpdateAck| { &m.last_applied_version_nonce },
            |m: &mut ConfigurationUpdateAck| { &mut m.last_applied_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, configuration_update_ack::Nack>(
            "nack",
            |m: &ConfigurationUpdateAck| { &m.nack },
            |m: &mut ConfigurationUpdateAck| { &mut m.nack },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationUpdateAck>(
            "ConfigurationUpdateAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigurationUpdateAck {
    const NAME: &'static str = "ConfigurationUpdateAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.last_applied_version_nonce = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nack)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.last_applied_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.last_applied_version_nonce);
        }
        if let Some(v) = self.nack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.last_applied_version_nonce.is_empty() {
            os.write_string(1, &self.last_applied_version_nonce)?;
        }
        if let Some(v) = self.nack.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigurationUpdateAck {
        ConfigurationUpdateAck::new()
    }

    fn clear(&mut self) {
        self.last_applied_version_nonce.clear();
        self.nack.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigurationUpdateAck {
        static instance: ConfigurationUpdateAck = ConfigurationUpdateAck {
            last_applied_version_nonce: ::std::string::String::new(),
            nack: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigurationUpdateAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigurationUpdateAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigurationUpdateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationUpdateAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigurationUpdateAck`
pub mod configuration_update_ack {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Nack {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.version_nonce)
        pub version_nonce: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.error_details)
        pub error_details: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Nack {
        fn default() -> &'a Nack {
            <Nack as ::protobuf::Message>::default_instance()
        }
    }

    impl Nack {
        pub fn new() -> Nack {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "version_nonce",
                |m: &Nack| { &m.version_nonce },
                |m: &mut Nack| { &mut m.version_nonce },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "error_details",
                |m: &Nack| { &m.error_details },
                |m: &mut Nack| { &mut m.error_details },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nack>(
                "ConfigurationUpdateAck.Nack",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Nack {
        const NAME: &'static str = "Nack";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.version_nonce = is.read_string()?;
                    },
                    18 => {
                        self.error_details = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.version_nonce.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
            }
            if !self.error_details.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.error_details);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.version_nonce.is_empty() {
                os.write_string(1, &self.version_nonce)?;
            }
            if !self.error_details.is_empty() {
                os.write_string(2, &self.error_details)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Nack {
            Nack::new()
        }

        fn clear(&mut self) {
            self.version_nonce.clear();
            self.error_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Nack {
            static instance: Nack = Nack {
                version_nonce: ::std::string::String::new(),
                error_details: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Nack {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConfigurationUpdateAck.Nack").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Nack {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Nack {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ApiRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApiRequest {
    // message oneof groups
    pub request_type: ::std::option::Option<api_request::Request_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ApiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiRequest {
    fn default() -> &'a ApiRequest {
        <ApiRequest as ::protobuf::Message>::default_instance()
    }
}

impl ApiRequest {
    pub fn new() -> ApiRequest {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.HandshakeRequest handshake = 1;

    pub fn handshake(&self) -> &HandshakeRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(ref v)) => v,
            _ => <HandshakeRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_handshake(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_handshake(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake(&mut self, v: HandshakeRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake(&mut self) -> &mut HandshakeRequest {
        if let ::std::option::Option::Some(api_request::Request_type::Handshake(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(HandshakeRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake(&mut self) -> HandshakeRequest {
        if self.has_handshake() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentRequest log_upload_intent = 7;

    pub fn log_upload_intent(&self) -> &LogUploadIntentRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(ref v)) => v,
            _ => <LogUploadIntentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload_intent(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_log_upload_intent(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload_intent(&mut self, v: LogUploadIntentRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload_intent(&mut self) -> &mut LogUploadIntentRequest {
        if let ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(LogUploadIntentRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload_intent(&mut self) -> LogUploadIntentRequest {
        if self.has_log_upload_intent() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadIntentRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadRequest log_upload = 2;

    pub fn log_upload(&self) -> &LogUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(ref v)) => v,
            _ => <LogUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_log_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload(&mut self, v: LogUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload(&mut self) -> &mut LogUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::LogUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(LogUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload(&mut self) -> LogUploadRequest {
        if self.has_log_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::LogUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.StatsUploadRequest stats_upload = 6;

    pub fn stats_upload(&self) -> &StatsUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(ref v)) => v,
            _ => <StatsUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stats_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_stats_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stats_upload(&mut self, v: StatsUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stats_upload(&mut self) -> &mut StatsUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::StatsUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(StatsUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stats_upload(&mut self) -> StatsUploadRequest {
        if self.has_stats_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::StatsUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            StatsUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.PingRequest ping = 3;

    pub fn ping(&self) -> &PingRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(ref v)) => v,
            _ => <PingRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: PingRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut PingRequest {
        if let ::std::option::Option::Some(api_request::Request_type::Ping(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(PingRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> PingRequest {
        if self.has_ping() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::Ping(v)) => v,
                _ => panic!(),
            }
        } else {
            PingRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck configuration_update_ack = 4;

    pub fn configuration_update_ack(&self) -> &ConfigurationUpdateAck {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ref v)) => v,
            _ => <ConfigurationUpdateAck as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_configuration_update_ack(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_configuration_update_ack(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_configuration_update_ack(&mut self, v: ConfigurationUpdateAck) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_configuration_update_ack(&mut self) -> &mut ConfigurationUpdateAck {
        if let ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ConfigurationUpdateAck::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_configuration_update_ack(&mut self) -> ConfigurationUpdateAck {
        if self.has_configuration_update_ack() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdateAck::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck runtime_update_ack = 5;

    pub fn runtime_update_ack(&self) -> &ConfigurationUpdateAck {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ref v)) => v,
            _ => <ConfigurationUpdateAck as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_runtime_update_ack(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_runtime_update_ack(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_update_ack(&mut self, v: ConfigurationUpdateAck) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_update_ack(&mut self) -> &mut ConfigurationUpdateAck {
        if let ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ConfigurationUpdateAck::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_update_ack(&mut self) -> ConfigurationUpdateAck {
        if self.has_runtime_update_ack() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdateAck::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest sankey_path_upload = 10;

    pub fn sankey_path_upload(&self) -> &SankeyPathUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(ref v)) => v,
            _ => <SankeyPathUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_path_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_sankey_path_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_path_upload(&mut self, v: SankeyPathUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_path_upload(&mut self) -> &mut SankeyPathUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(SankeyPathUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_path_upload(&mut self) -> SankeyPathUploadRequest {
        if self.has_sankey_path_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyPathUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentRequest sankey_intent = 11;

    pub fn sankey_intent(&self) -> &SankeyIntentRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(ref v)) => v,
            _ => <SankeyIntentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_intent(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_sankey_intent(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_intent(&mut self, v: SankeyIntentRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_intent(&mut self) -> &mut SankeyIntentRequest {
        if let ::std::option::Option::Some(api_request::Request_type::SankeyIntent(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(SankeyIntentRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_intent(&mut self) -> SankeyIntentRequest {
        if self.has_sankey_intent() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::SankeyIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyIntentRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactRequest artifact_upload = 12;

    pub fn artifact_upload(&self) -> &UploadArtifactRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(ref v)) => v,
            _ => <UploadArtifactRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_artifact_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_artifact_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_upload(&mut self, v: UploadArtifactRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_upload(&mut self) -> &mut UploadArtifactRequest {
        if let ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(UploadArtifactRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_upload(&mut self) -> UploadArtifactRequest {
        if self.has_artifact_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            UploadArtifactRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest artifact_intent = 13;

    pub fn artifact_intent(&self) -> &UploadArtifactIntentRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(ref v)) => v,
            _ => <UploadArtifactIntentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_artifact_intent(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_artifact_intent(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_intent(&mut self, v: UploadArtifactIntentRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_intent(&mut self) -> &mut UploadArtifactIntentRequest {
        if let ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(UploadArtifactIntentRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_intent(&mut self) -> UploadArtifactIntentRequest {
        if self.has_artifact_intent() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            UploadArtifactIntentRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HandshakeRequest>(
            "handshake",
            ApiRequest::has_handshake,
            ApiRequest::handshake,
            ApiRequest::mut_handshake,
            ApiRequest::set_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadIntentRequest>(
            "log_upload_intent",
            ApiRequest::has_log_upload_intent,
            ApiRequest::log_upload_intent,
            ApiRequest::mut_log_upload_intent,
            ApiRequest::set_log_upload_intent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadRequest>(
            "log_upload",
            ApiRequest::has_log_upload,
            ApiRequest::log_upload,
            ApiRequest::mut_log_upload,
            ApiRequest::set_log_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatsUploadRequest>(
            "stats_upload",
            ApiRequest::has_stats_upload,
            ApiRequest::stats_upload,
            ApiRequest::mut_stats_upload,
            ApiRequest::set_stats_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PingRequest>(
            "ping",
            ApiRequest::has_ping,
            ApiRequest::ping,
            ApiRequest::mut_ping,
            ApiRequest::set_ping,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdateAck>(
            "configuration_update_ack",
            ApiRequest::has_configuration_update_ack,
            ApiRequest::configuration_update_ack,
            ApiRequest::mut_configuration_update_ack,
            ApiRequest::set_configuration_update_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdateAck>(
            "runtime_update_ack",
            ApiRequest::has_runtime_update_ack,
            ApiRequest::runtime_update_ack,
            ApiRequest::mut_runtime_update_ack,
            ApiRequest::set_runtime_update_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyPathUploadRequest>(
            "sankey_path_upload",
            ApiRequest::has_sankey_path_upload,
            ApiRequest::sankey_path_upload,
            ApiRequest::mut_sankey_path_upload,
            ApiRequest::set_sankey_path_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyIntentRequest>(
            "sankey_intent",
            ApiRequest::has_sankey_intent,
            ApiRequest::sankey_intent,
            ApiRequest::mut_sankey_intent,
            ApiRequest::set_sankey_intent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UploadArtifactRequest>(
            "artifact_upload",
            ApiRequest::has_artifact_upload,
            ApiRequest::artifact_upload,
            ApiRequest::mut_artifact_upload,
            ApiRequest::set_artifact_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UploadArtifactIntentRequest>(
            "artifact_intent",
            ApiRequest::has_artifact_intent,
            ApiRequest::artifact_intent,
            ApiRequest::mut_artifact_intent,
            ApiRequest::set_artifact_intent,
        ));
        oneofs.push(api_request::Request_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiRequest>(
            "ApiRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiRequest {
    const NAME: &'static str = "ApiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(is.read_message()?));
                },
                58 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(is.read_message()?));
                },
                18 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(is.read_message()?));
                },
                50 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(is.read_message()?));
                },
                26 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(is.read_message()?));
                },
                34 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(is.read_message()?));
                },
                42 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(is.read_message()?));
                },
                82 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyPathUpload(is.read_message()?));
                },
                90 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(is.read_message()?));
                },
                98 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactUpload(is.read_message()?));
                },
                106 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::ArtifactIntent(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request_type {
            match v {
                &api_request::Request_type::Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::LogUploadIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::LogUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::StatsUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::Ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::ConfigurationUpdateAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::RuntimeUpdateAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::SankeyPathUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::SankeyIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::ArtifactUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::ArtifactIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request_type {
            match v {
                &api_request::Request_type::Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &api_request::Request_type::LogUploadIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &api_request::Request_type::LogUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &api_request::Request_type::StatsUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &api_request::Request_type::Ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &api_request::Request_type::ConfigurationUpdateAck(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &api_request::Request_type::RuntimeUpdateAck(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &api_request::Request_type::SankeyPathUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &api_request::Request_type::SankeyIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &api_request::Request_type::ArtifactUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &api_request::Request_type::ArtifactIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiRequest {
        ApiRequest::new()
    }

    fn clear(&mut self) {
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiRequest {
        static instance: ApiRequest = ApiRequest {
            request_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApiRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ApiRequest`
pub mod api_request {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ApiRequest.request_type)
    pub enum Request_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.handshake)
        Handshake(super::HandshakeRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.log_upload_intent)
        LogUploadIntent(super::LogUploadIntentRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.log_upload)
        LogUpload(super::LogUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.stats_upload)
        StatsUpload(super::StatsUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.ping)
        Ping(super::PingRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.configuration_update_ack)
        ConfigurationUpdateAck(super::ConfigurationUpdateAck),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.runtime_update_ack)
        RuntimeUpdateAck(super::ConfigurationUpdateAck),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.sankey_path_upload)
        SankeyPathUpload(super::SankeyPathUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.sankey_intent)
        SankeyIntent(super::SankeyIntentRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.artifact_upload)
        ArtifactUpload(super::UploadArtifactRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.artifact_intent)
        ArtifactIntent(super::UploadArtifactIntentRequest),
    }

    impl ::protobuf::Oneof for Request_type {
    }

    impl ::protobuf::OneofFull for Request_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ApiRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request_type").unwrap()).clone()
        }
    }

    impl Request_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request_type>("request_type")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyPathUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.path_id)
    pub path_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.nodes)
    pub nodes: ::std::vec::Vec<sankey_path_upload_request::Node>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyPathUploadRequest {
    fn default() -> &'a SankeyPathUploadRequest {
        <SankeyPathUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl SankeyPathUploadRequest {
    pub fn new() -> SankeyPathUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &SankeyPathUploadRequest| { &m.upload_uuid },
            |m: &mut SankeyPathUploadRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SankeyPathUploadRequest| { &m.id },
            |m: &mut SankeyPathUploadRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_id",
            |m: &SankeyPathUploadRequest| { &m.path_id },
            |m: &mut SankeyPathUploadRequest| { &mut m.path_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &SankeyPathUploadRequest| { &m.nodes },
            |m: &mut SankeyPathUploadRequest| { &mut m.nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyPathUploadRequest>(
            "SankeyPathUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyPathUploadRequest {
    const NAME: &'static str = "SankeyPathUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    self.upload_uuid = is.read_string()?;
                },
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.path_id = is.read_string()?;
                },
                26 => {
                    self.nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.upload_uuid);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.path_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(4, &self.upload_uuid)?;
        }
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.path_id.is_empty() {
            os.write_string(2, &self.path_id)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyPathUploadRequest {
        SankeyPathUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.id.clear();
        self.path_id.clear();
        self.nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyPathUploadRequest {
        static instance: SankeyPathUploadRequest = SankeyPathUploadRequest {
            upload_uuid: ::std::string::String::new(),
            id: ::std::string::String::new(),
            path_id: ::std::string::String::new(),
            nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyPathUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyPathUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyPathUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyPathUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SankeyPathUploadRequest`
pub mod sankey_path_upload_request {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.Node)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Node {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.Node.extracted_value)
        pub extracted_value: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyPathUploadRequest.Node.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Node {
        fn default() -> &'a Node {
            <Node as ::protobuf::Message>::default_instance()
        }
    }

    impl Node {
        pub fn new() -> Node {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "extracted_value",
                |m: &Node| { &m.extracted_value },
                |m: &mut Node| { &mut m.extracted_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
                "SankeyPathUploadRequest.Node",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Node {
        const NAME: &'static str = "Node";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.extracted_value = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.extracted_value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.extracted_value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.extracted_value.is_empty() {
                os.write_string(1, &self.extracted_value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Node {
            Node::new()
        }

        fn clear(&mut self) {
            self.extracted_value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Node {
            static instance: Node = Node {
                extracted_value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Node {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SankeyPathUploadRequest.Node").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Node {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Node {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyIntentRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.path_id)
    pub path_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.sankey_diagram_id)
    pub sankey_diagram_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyIntentRequest {
    fn default() -> &'a SankeyIntentRequest {
        <SankeyIntentRequest as ::protobuf::Message>::default_instance()
    }
}

impl SankeyIntentRequest {
    pub fn new() -> SankeyIntentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &SankeyIntentRequest| { &m.intent_uuid },
            |m: &mut SankeyIntentRequest| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_id",
            |m: &SankeyIntentRequest| { &m.path_id },
            |m: &mut SankeyIntentRequest| { &mut m.path_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sankey_diagram_id",
            |m: &SankeyIntentRequest| { &m.sankey_diagram_id },
            |m: &mut SankeyIntentRequest| { &mut m.sankey_diagram_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyIntentRequest>(
            "SankeyIntentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyIntentRequest {
    const NAME: &'static str = "SankeyIntentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                18 => {
                    self.path_id = is.read_string()?;
                },
                26 => {
                    self.sankey_diagram_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if !self.path_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_id);
        }
        if !self.sankey_diagram_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sankey_diagram_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if !self.path_id.is_empty() {
            os.write_string(2, &self.path_id)?;
        }
        if !self.sankey_diagram_id.is_empty() {
            os.write_string(3, &self.sankey_diagram_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyIntentRequest {
        SankeyIntentRequest::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.path_id.clear();
        self.sankey_diagram_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyIntentRequest {
        static instance: SankeyIntentRequest = SankeyIntentRequest {
            intent_uuid: ::std::string::String::new(),
            path_id: ::std::string::String::new(),
            sankey_diagram_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyIntentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyIntentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyIntentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyIntentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UploadArtifactIntentRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.type_id)
    pub type_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.metadata)
    pub metadata: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.artifact_id)
    pub artifact_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UploadArtifactIntentRequest {
    fn default() -> &'a UploadArtifactIntentRequest {
        <UploadArtifactIntentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadArtifactIntentRequest {
    pub fn new() -> UploadArtifactIntentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &UploadArtifactIntentRequest| { &m.intent_uuid },
            |m: &mut UploadArtifactIntentRequest| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &UploadArtifactIntentRequest| { &m.type_id },
            |m: &mut UploadArtifactIntentRequest| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metadata",
            |m: &UploadArtifactIntentRequest| { &m.metadata },
            |m: &mut UploadArtifactIntentRequest| { &mut m.metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "artifact_id",
            |m: &UploadArtifactIntentRequest| { &m.artifact_id },
            |m: &mut UploadArtifactIntentRequest| { &mut m.artifact_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &UploadArtifactIntentRequest| { &m.time },
            |m: &mut UploadArtifactIntentRequest| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadArtifactIntentRequest>(
            "UploadArtifactIntentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UploadArtifactIntentRequest {
    const NAME: &'static str = "UploadArtifactIntentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                18 => {
                    self.type_id = is.read_string()?;
                },
                26 => {
                    self.metadata = is.read_bytes()?;
                },
                34 => {
                    self.artifact_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if !self.type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_id);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.metadata);
        }
        if !self.artifact_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.artifact_id);
        }
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if !self.type_id.is_empty() {
            os.write_string(2, &self.type_id)?;
        }
        if !self.metadata.is_empty() {
            os.write_bytes(3, &self.metadata)?;
        }
        if !self.artifact_id.is_empty() {
            os.write_string(4, &self.artifact_id)?;
        }
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UploadArtifactIntentRequest {
        UploadArtifactIntentRequest::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.type_id.clear();
        self.metadata.clear();
        self.artifact_id.clear();
        self.time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UploadArtifactIntentRequest {
        static instance: UploadArtifactIntentRequest = UploadArtifactIntentRequest {
            intent_uuid: ::std::string::String::new(),
            type_id: ::std::string::String::new(),
            metadata: ::std::vec::Vec::new(),
            artifact_id: ::std::string::String::new(),
            time: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UploadArtifactIntentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UploadArtifactIntentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UploadArtifactIntentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadArtifactIntentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UploadArtifactIntentResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // message oneof groups
    pub decision: ::std::option::Option<upload_artifact_intent_response::Decision>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UploadArtifactIntentResponse {
    fn default() -> &'a UploadArtifactIntentResponse {
        <UploadArtifactIntentResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadArtifactIntentResponse {
    pub fn new() -> UploadArtifactIntentResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.UploadImmediately upload_immediately = 3;

    pub fn upload_immediately(&self) -> &upload_artifact_intent_response::UploadImmediately {
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(ref v)) => v,
            _ => <upload_artifact_intent_response::UploadImmediately as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upload_immediately(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_upload_immediately(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_immediately(&mut self, v: upload_artifact_intent_response::UploadImmediately) {
        self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_immediately(&mut self) -> &mut upload_artifact_intent_response::UploadImmediately {
        if let ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(upload_artifact_intent_response::UploadImmediately::new()));
        }
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_immediately(&mut self) -> upload_artifact_intent_response::UploadImmediately {
        if self.has_upload_immediately() {
            match self.decision.take() {
                ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(v)) => v,
                _ => panic!(),
            }
        } else {
            upload_artifact_intent_response::UploadImmediately::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.Drop drop = 4;

    pub fn drop(&self) -> &upload_artifact_intent_response::Drop {
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(ref v)) => v,
            _ => <upload_artifact_intent_response::Drop as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_drop(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_drop(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: upload_artifact_intent_response::Drop) {
        self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut upload_artifact_intent_response::Drop {
        if let ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(upload_artifact_intent_response::Drop::new()));
        }
        match self.decision {
            ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_drop(&mut self) -> upload_artifact_intent_response::Drop {
        if self.has_drop() {
            match self.decision.take() {
                ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(v)) => v,
                _ => panic!(),
            }
        } else {
            upload_artifact_intent_response::Drop::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &UploadArtifactIntentResponse| { &m.intent_uuid },
            |m: &mut UploadArtifactIntentResponse| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, upload_artifact_intent_response::UploadImmediately>(
            "upload_immediately",
            UploadArtifactIntentResponse::has_upload_immediately,
            UploadArtifactIntentResponse::upload_immediately,
            UploadArtifactIntentResponse::mut_upload_immediately,
            UploadArtifactIntentResponse::set_upload_immediately,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, upload_artifact_intent_response::Drop>(
            "drop",
            UploadArtifactIntentResponse::has_drop,
            UploadArtifactIntentResponse::drop,
            UploadArtifactIntentResponse::mut_drop,
            UploadArtifactIntentResponse::set_drop,
        ));
        oneofs.push(upload_artifact_intent_response::Decision::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadArtifactIntentResponse>(
            "UploadArtifactIntentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UploadArtifactIntentResponse {
    const NAME: &'static str = "UploadArtifactIntentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                26 => {
                    self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::UploadImmediately(is.read_message()?));
                },
                34 => {
                    self.decision = ::std::option::Option::Some(upload_artifact_intent_response::Decision::Drop(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &upload_artifact_intent_response::Decision::UploadImmediately(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &upload_artifact_intent_response::Decision::Drop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &upload_artifact_intent_response::Decision::UploadImmediately(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &upload_artifact_intent_response::Decision::Drop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UploadArtifactIntentResponse {
        UploadArtifactIntentResponse::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.decision = ::std::option::Option::None;
        self.decision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UploadArtifactIntentResponse {
        static instance: UploadArtifactIntentResponse = UploadArtifactIntentResponse {
            intent_uuid: ::std::string::String::new(),
            decision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UploadArtifactIntentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UploadArtifactIntentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UploadArtifactIntentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadArtifactIntentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UploadArtifactIntentResponse`
pub mod upload_artifact_intent_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.decision)
    pub enum Decision {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.upload_immediately)
        UploadImmediately(UploadImmediately),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.drop)
        Drop(Drop),
    }

    impl ::protobuf::Oneof for Decision {
    }

    impl ::protobuf::OneofFull for Decision {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::UploadArtifactIntentResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("decision").unwrap()).clone()
        }
    }

    impl Decision {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Decision>("decision")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.UploadImmediately)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UploadImmediately {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.UploadImmediately.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UploadImmediately {
        fn default() -> &'a UploadImmediately {
            <UploadImmediately as ::protobuf::Message>::default_instance()
        }
    }

    impl UploadImmediately {
        pub fn new() -> UploadImmediately {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadImmediately>(
                "UploadArtifactIntentResponse.UploadImmediately",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UploadImmediately {
        const NAME: &'static str = "UploadImmediately";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UploadImmediately {
            UploadImmediately::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UploadImmediately {
            static instance: UploadImmediately = UploadImmediately {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UploadImmediately {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UploadArtifactIntentResponse.UploadImmediately").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UploadImmediately {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UploadImmediately {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.Drop)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drop {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse.Drop.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drop {
        fn default() -> &'a Drop {
            <Drop as ::protobuf::Message>::default_instance()
        }
    }

    impl Drop {
        pub fn new() -> Drop {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Drop>(
                "UploadArtifactIntentResponse.Drop",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Drop {
        const NAME: &'static str = "Drop";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drop {
            Drop::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drop {
            static instance: Drop = Drop {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Drop {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UploadArtifactIntentResponse.Drop").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Drop {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Drop {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UploadArtifactRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.type_id)
    pub type_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.contents)
    pub contents: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.artifact_id)
    pub artifact_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.state_metadata)
    pub state_metadata: ::std::collections::HashMap<::std::string::String, super::payload::Data>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.time)
    pub time: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.session_id)
    pub session_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UploadArtifactRequest {
    fn default() -> &'a UploadArtifactRequest {
        <UploadArtifactRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadArtifactRequest {
    pub fn new() -> UploadArtifactRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &UploadArtifactRequest| { &m.upload_uuid },
            |m: &mut UploadArtifactRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &UploadArtifactRequest| { &m.type_id },
            |m: &mut UploadArtifactRequest| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contents",
            |m: &UploadArtifactRequest| { &m.contents },
            |m: &mut UploadArtifactRequest| { &mut m.contents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "artifact_id",
            |m: &UploadArtifactRequest| { &m.artifact_id },
            |m: &mut UploadArtifactRequest| { &mut m.artifact_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "state_metadata",
            |m: &UploadArtifactRequest| { &m.state_metadata },
            |m: &mut UploadArtifactRequest| { &mut m.state_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "time",
            |m: &UploadArtifactRequest| { &m.time },
            |m: &mut UploadArtifactRequest| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &UploadArtifactRequest| { &m.session_id },
            |m: &mut UploadArtifactRequest| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadArtifactRequest>(
            "UploadArtifactRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UploadArtifactRequest {
    const NAME: &'static str = "UploadArtifactRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.type_id = is.read_string()?;
                },
                26 => {
                    self.contents = is.read_bytes()?;
                },
                34 => {
                    self.artifact_id = is.read_string()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.state_metadata.insert(key, value);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.time)?;
                },
                58 => {
                    self.session_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.type_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.type_id);
        }
        if !self.contents.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.contents);
        }
        if !self.artifact_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.artifact_id);
        }
        for (k, v) in &self.state_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.session_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.type_id.is_empty() {
            os.write_string(2, &self.type_id)?;
        }
        if !self.contents.is_empty() {
            os.write_bytes(3, &self.contents)?;
        }
        if !self.artifact_id.is_empty() {
            os.write_string(4, &self.artifact_id)?;
        }
        for (k, v) in &self.state_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if !self.session_id.is_empty() {
            os.write_string(7, &self.session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UploadArtifactRequest {
        UploadArtifactRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.type_id.clear();
        self.contents.clear();
        self.artifact_id.clear();
        self.state_metadata.clear();
        self.time.clear();
        self.session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UploadArtifactRequest {
        static instance: ::protobuf::rt::Lazy<UploadArtifactRequest> = ::protobuf::rt::Lazy::new();
        instance.get(UploadArtifactRequest::new)
    }
}

impl ::protobuf::MessageFull for UploadArtifactRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UploadArtifactRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UploadArtifactRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadArtifactRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.UploadArtifactResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UploadArtifactResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.UploadArtifactResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.UploadArtifactResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UploadArtifactResponse {
    fn default() -> &'a UploadArtifactResponse {
        <UploadArtifactResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadArtifactResponse {
    pub fn new() -> UploadArtifactResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &UploadArtifactResponse| { &m.upload_uuid },
            |m: &mut UploadArtifactResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &UploadArtifactResponse| { &m.error },
            |m: &mut UploadArtifactResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadArtifactResponse>(
            "UploadArtifactResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UploadArtifactResponse {
    const NAME: &'static str = "UploadArtifactResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UploadArtifactResponse {
        UploadArtifactResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UploadArtifactResponse {
        static instance: UploadArtifactResponse = UploadArtifactResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UploadArtifactResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UploadArtifactResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UploadArtifactResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadArtifactResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HandshakeResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeResponse.stream_settings)
    pub stream_settings: ::protobuf::MessageField<handshake_response::StreamSettings>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeResponse.configuration_update_status)
    pub configuration_update_status: u32,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse {
    fn default() -> &'a HandshakeResponse {
        <HandshakeResponse as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse {
    pub fn new() -> HandshakeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, handshake_response::StreamSettings>(
            "stream_settings",
            |m: &HandshakeResponse| { &m.stream_settings },
            |m: &mut HandshakeResponse| { &mut m.stream_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "configuration_update_status",
            |m: &HandshakeResponse| { &m.configuration_update_status },
            |m: &mut HandshakeResponse| { &mut m.configuration_update_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeResponse>(
            "HandshakeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeResponse {
    const NAME: &'static str = "HandshakeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stream_settings)?;
                },
                16 => {
                    self.configuration_update_status = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.configuration_update_status != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.configuration_update_status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stream_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.configuration_update_status != 0 {
            os.write_uint32(2, self.configuration_update_status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeResponse {
        HandshakeResponse::new()
    }

    fn clear(&mut self) {
        self.stream_settings.clear();
        self.configuration_update_status = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeResponse {
        static instance: HandshakeResponse = HandshakeResponse {
            stream_settings: ::protobuf::MessageField::none(),
            configuration_update_status: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HandshakeResponse`
pub mod handshake_response {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StreamSettings {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings.ping_interval)
        pub ping_interval: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StreamSettings {
        fn default() -> &'a StreamSettings {
            <StreamSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl StreamSettings {
        pub fn new() -> StreamSettings {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "ping_interval",
                |m: &StreamSettings| { &m.ping_interval },
                |m: &mut StreamSettings| { &mut m.ping_interval },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamSettings>(
                "HandshakeResponse.StreamSettings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StreamSettings {
        const NAME: &'static str = "StreamSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_interval)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ping_interval.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ping_interval.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StreamSettings {
            StreamSettings::new()
        }

        fn clear(&mut self) {
            self.ping_interval.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StreamSettings {
            static instance: StreamSettings = StreamSettings {
                ping_interval: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StreamSettings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HandshakeResponse.StreamSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StreamSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StreamSettings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.RateLimited)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RateLimited {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.RateLimited.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RateLimited {
    fn default() -> &'a RateLimited {
        <RateLimited as ::protobuf::Message>::default_instance()
    }
}

impl RateLimited {
    pub fn new() -> RateLimited {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RateLimited>(
            "RateLimited",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RateLimited {
    const NAME: &'static str = "RateLimited";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RateLimited {
        RateLimited::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RateLimited {
        static instance: RateLimited = RateLimited {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RateLimited {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RateLimited").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RateLimited {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimited {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.logs_dropped)
    pub logs_dropped: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.rate_limited)
    pub rate_limited: ::protobuf::MessageField<RateLimited>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadResponse {
    fn default() -> &'a LogUploadResponse {
        <LogUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadResponse {
    pub fn new() -> LogUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &LogUploadResponse| { &m.upload_uuid },
            |m: &mut LogUploadResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &LogUploadResponse| { &m.error },
            |m: &mut LogUploadResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_dropped",
            |m: &LogUploadResponse| { &m.logs_dropped },
            |m: &mut LogUploadResponse| { &mut m.logs_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateLimited>(
            "rate_limited",
            |m: &LogUploadResponse| { &m.rate_limited },
            |m: &mut LogUploadResponse| { &mut m.rate_limited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadResponse>(
            "LogUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadResponse {
    const NAME: &'static str = "LogUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.logs_dropped = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rate_limited)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.logs_dropped != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.logs_dropped);
        }
        if let Some(v) = self.rate_limited.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.logs_dropped != 0 {
            os.write_uint32(3, self.logs_dropped)?;
        }
        if let Some(v) = self.rate_limited.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadResponse {
        LogUploadResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.logs_dropped = 0;
        self.rate_limited.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadResponse {
        static instance: LogUploadResponse = LogUploadResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            logs_dropped: 0,
            rate_limited: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatsUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.snapshot)
    pub snapshot: ::std::vec::Vec<stats_upload_request::Snapshot>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.sent_at)
    pub sent_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsUploadRequest {
    fn default() -> &'a StatsUploadRequest {
        <StatsUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsUploadRequest {
    pub fn new() -> StatsUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &StatsUploadRequest| { &m.upload_uuid },
            |m: &mut StatsUploadRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot",
            |m: &StatsUploadRequest| { &m.snapshot },
            |m: &mut StatsUploadRequest| { &mut m.snapshot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "sent_at",
            |m: &StatsUploadRequest| { &m.sent_at },
            |m: &mut StatsUploadRequest| { &mut m.sent_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsUploadRequest>(
            "StatsUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsUploadRequest {
    const NAME: &'static str = "StatsUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.snapshot.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sent_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        for value in &self.snapshot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.sent_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        for v in &self.snapshot {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.sent_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsUploadRequest {
        StatsUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.snapshot.clear();
        self.sent_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsUploadRequest {
        static instance: StatsUploadRequest = StatsUploadRequest {
            upload_uuid: ::std::string::String::new(),
            snapshot: ::std::vec::Vec::new(),
            sent_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StatsUploadRequest`
pub mod stats_upload_request {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Snapshot {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.metric_id_overflows)
        pub metric_id_overflows: ::std::collections::HashMap<::std::string::String, u64>,
        // message oneof groups
        pub snapshot_type: ::std::option::Option<snapshot::Snapshot_type>,
        pub occurred_at: ::std::option::Option<snapshot::Occurred_at>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Snapshot {
        fn default() -> &'a Snapshot {
            <Snapshot as ::protobuf::Message>::default_instance()
        }
    }

    impl Snapshot {
        pub fn new() -> Snapshot {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.client.v1.MetricsList metrics = 1;

        pub fn metrics(&self) -> &super::super::metric::MetricsList {
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(ref v)) => v,
                _ => <super::super::metric::MetricsList as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_metrics(&mut self) {
            self.snapshot_type = ::std::option::Option::None;
        }

        pub fn has_metrics(&self) -> bool {
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_metrics(&mut self, v: super::super::metric::MetricsList) {
            self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(v))
        }

        // Mutable pointer to the field.
        pub fn mut_metrics(&mut self) -> &mut super::super::metric::MetricsList {
            if let ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(_)) = self.snapshot_type {
            } else {
                self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(super::super::metric::MetricsList::new()));
            }
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_metrics(&mut self) -> super::super::metric::MetricsList {
            if self.has_metrics() {
                match self.snapshot_type.take() {
                    ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::super::metric::MetricsList::new()
            }
        }

        // .bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated aggregated = 2;

        pub fn aggregated(&self) -> &snapshot::Aggregated {
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(ref v)) => v,
                _ => <snapshot::Aggregated as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_aggregated(&mut self) {
            self.occurred_at = ::std::option::Option::None;
        }

        pub fn has_aggregated(&self) -> bool {
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_aggregated(&mut self, v: snapshot::Aggregated) {
            self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(v))
        }

        // Mutable pointer to the field.
        pub fn mut_aggregated(&mut self) -> &mut snapshot::Aggregated {
            if let ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(_)) = self.occurred_at {
            } else {
                self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(snapshot::Aggregated::new()));
            }
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_aggregated(&mut self) -> snapshot::Aggregated {
            if self.has_aggregated() {
                match self.occurred_at.take() {
                    ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(v)) => v,
                    _ => panic!(),
                }
            } else {
                snapshot::Aggregated::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(2);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::metric::MetricsList>(
                "metrics",
                Snapshot::has_metrics,
                Snapshot::metrics,
                Snapshot::mut_metrics,
                Snapshot::set_metrics,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, snapshot::Aggregated>(
                "aggregated",
                Snapshot::has_aggregated,
                Snapshot::aggregated,
                Snapshot::mut_aggregated,
                Snapshot::set_aggregated,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "metric_id_overflows",
                |m: &Snapshot| { &m.metric_id_overflows },
                |m: &mut Snapshot| { &mut m.metric_id_overflows },
            ));
            oneofs.push(snapshot::Snapshot_type::generated_oneof_descriptor_data());
            oneofs.push(snapshot::Occurred_at::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Snapshot>(
                "StatsUploadRequest.Snapshot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Snapshot {
        const NAME: &'static str = "Snapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(is.read_message()?));
                    },
                    18 => {
                        self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(is.read_message()?));
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                16 => value = is.read_uint64()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.metric_id_overflows.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for (k, v) in &self.metric_id_overflows {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::uint64_size(2, *v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if let ::std::option::Option::Some(ref v) = self.snapshot_type {
                match v {
                    &snapshot::Snapshot_type::Metrics(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            if let ::std::option::Option::Some(ref v) = self.occurred_at {
                match v {
                    &snapshot::Occurred_at::Aggregated(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for (k, v) in &self.metric_id_overflows {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::uint64_size(2, *v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_uint64(2, *v)?;
            };
            if let ::std::option::Option::Some(ref v) = self.snapshot_type {
                match v {
                    &snapshot::Snapshot_type::Metrics(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                };
            }
            if let ::std::option::Option::Some(ref v) = self.occurred_at {
                match v {
                    &snapshot::Occurred_at::Aggregated(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Snapshot {
            Snapshot::new()
        }

        fn clear(&mut self) {
            self.snapshot_type = ::std::option::Option::None;
            self.occurred_at = ::std::option::Option::None;
            self.metric_id_overflows.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Snapshot {
            static instance: ::protobuf::rt::Lazy<Snapshot> = ::protobuf::rt::Lazy::new();
            instance.get(Snapshot::new)
        }
    }

    impl ::protobuf::MessageFull for Snapshot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StatsUploadRequest.Snapshot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Snapshot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Snapshot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Snapshot`
    pub mod snapshot {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.snapshot_type)
        pub enum Snapshot_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.metrics)
            Metrics(super::super::super::metric::MetricsList),
        }

        impl ::protobuf::Oneof for Snapshot_type {
        }

        impl ::protobuf::OneofFull for Snapshot_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Snapshot as ::protobuf::MessageFull>::descriptor().oneof_by_name("snapshot_type").unwrap()).clone()
            }
        }

        impl Snapshot_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Snapshot_type>("snapshot_type")
            }
        }

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.occurred_at)
        pub enum Occurred_at {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.aggregated)
            Aggregated(Aggregated),
        }

        impl ::protobuf::Oneof for Occurred_at {
        }

        impl ::protobuf::OneofFull for Occurred_at {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Snapshot as ::protobuf::MessageFull>::descriptor().oneof_by_name("occurred_at").unwrap()).clone()
            }
        }

        impl Occurred_at {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Occurred_at>("occurred_at")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Aggregated {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.period_start)
            pub period_start: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.period_end)
            pub period_end: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Aggregated {
            fn default() -> &'a Aggregated {
                <Aggregated as ::protobuf::Message>::default_instance()
            }
        }

        impl Aggregated {
            pub fn new() -> Aggregated {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                    "period_start",
                    |m: &Aggregated| { &m.period_start },
                    |m: &mut Aggregated| { &mut m.period_start },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                    "period_end",
                    |m: &Aggregated| { &m.period_end },
                    |m: &mut Aggregated| { &mut m.period_end },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Aggregated>(
                    "StatsUploadRequest.Snapshot.Aggregated",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Aggregated {
            const NAME: &'static str = "Aggregated";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        34 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.period_start)?;
                        },
                        42 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.period_end)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.period_start.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.period_end.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.period_start.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                }
                if let Some(v) = self.period_end.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Aggregated {
                Aggregated::new()
            }

            fn clear(&mut self) {
                self.period_start.clear();
                self.period_end.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Aggregated {
                static instance: Aggregated = Aggregated {
                    period_start: ::protobuf::MessageField::none(),
                    period_end: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Aggregated {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StatsUploadRequest.Snapshot.Aggregated").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Aggregated {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Aggregated {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatsUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.metrics_dropped)
    pub metrics_dropped: u32,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsUploadResponse {
    fn default() -> &'a StatsUploadResponse {
        <StatsUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsUploadResponse {
    pub fn new() -> StatsUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &StatsUploadResponse| { &m.upload_uuid },
            |m: &mut StatsUploadResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &StatsUploadResponse| { &m.error },
            |m: &mut StatsUploadResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_dropped",
            |m: &StatsUploadResponse| { &m.metrics_dropped },
            |m: &mut StatsUploadResponse| { &mut m.metrics_dropped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsUploadResponse>(
            "StatsUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsUploadResponse {
    const NAME: &'static str = "StatsUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.metrics_dropped = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.metrics_dropped != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.metrics_dropped);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.metrics_dropped != 0 {
            os.write_uint32(3, self.metrics_dropped)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsUploadResponse {
        StatsUploadResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.metrics_dropped = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsUploadResponse {
        static instance: StatsUploadResponse = StatsUploadResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            metrics_dropped: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.PongResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PongResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.PongResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PongResponse {
    fn default() -> &'a PongResponse {
        <PongResponse as ::protobuf::Message>::default_instance()
    }
}

impl PongResponse {
    pub fn new() -> PongResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PongResponse>(
            "PongResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PongResponse {
    const NAME: &'static str = "PongResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PongResponse {
        PongResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PongResponse {
        static instance: PongResponse = PongResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PongResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PongResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PongResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PongResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigurationUpdate {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.version_nonce)
    pub version_nonce: ::std::string::String,
    // message oneof groups
    pub update_type: ::std::option::Option<configuration_update::Update_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigurationUpdate {
    fn default() -> &'a ConfigurationUpdate {
        <ConfigurationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationUpdate {
    pub fn new() -> ConfigurationUpdate {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld state_of_the_world = 2;

    pub fn state_of_the_world(&self) -> &configuration_update::StateOfTheWorld {
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(ref v)) => v,
            _ => <configuration_update::StateOfTheWorld as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_state_of_the_world(&mut self) {
        self.update_type = ::std::option::Option::None;
    }

    pub fn has_state_of_the_world(&self) -> bool {
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state_of_the_world(&mut self, v: configuration_update::StateOfTheWorld) {
        self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state_of_the_world(&mut self) -> &mut configuration_update::StateOfTheWorld {
        if let ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(_)) = self.update_type {
        } else {
            self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(configuration_update::StateOfTheWorld::new()));
        }
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state_of_the_world(&mut self) -> configuration_update::StateOfTheWorld {
        if self.has_state_of_the_world() {
            match self.update_type.take() {
                ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(v)) => v,
                _ => panic!(),
            }
        } else {
            configuration_update::StateOfTheWorld::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_nonce",
            |m: &ConfigurationUpdate| { &m.version_nonce },
            |m: &mut ConfigurationUpdate| { &mut m.version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, configuration_update::StateOfTheWorld>(
            "state_of_the_world",
            ConfigurationUpdate::has_state_of_the_world,
            ConfigurationUpdate::state_of_the_world,
            ConfigurationUpdate::mut_state_of_the_world,
            ConfigurationUpdate::set_state_of_the_world,
        ));
        oneofs.push(configuration_update::Update_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationUpdate>(
            "ConfigurationUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigurationUpdate {
    const NAME: &'static str = "ConfigurationUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_nonce = is.read_string()?;
                },
                18 => {
                    self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
        }
        if let ::std::option::Option::Some(ref v) = self.update_type {
            match v {
                &configuration_update::Update_type::StateOfTheWorld(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_nonce.is_empty() {
            os.write_string(1, &self.version_nonce)?;
        }
        if let ::std::option::Option::Some(ref v) = self.update_type {
            match v {
                &configuration_update::Update_type::StateOfTheWorld(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigurationUpdate {
        ConfigurationUpdate::new()
    }

    fn clear(&mut self) {
        self.version_nonce.clear();
        self.update_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigurationUpdate {
        static instance: ConfigurationUpdate = ConfigurationUpdate {
            version_nonce: ::std::string::String::new(),
            update_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigurationUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigurationUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigurationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigurationUpdate`
pub mod configuration_update {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.update_type)
    pub enum Update_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.state_of_the_world)
        StateOfTheWorld(StateOfTheWorld),
    }

    impl ::protobuf::Oneof for Update_type {
    }

    impl ::protobuf::OneofFull for Update_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ConfigurationUpdate as ::protobuf::MessageFull>::descriptor().oneof_by_name("update_type").unwrap()).clone()
        }
    }

    impl Update_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Update_type>("update_type")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StateOfTheWorld {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.buffer_config_list)
        pub buffer_config_list: ::protobuf::MessageField<super::super::config::BufferConfigList>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.workflows_configuration)
        pub workflows_configuration: ::protobuf::MessageField<super::super::workflow::WorkflowsConfiguration>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.bdtail_configuration)
        pub bdtail_configuration: ::protobuf::MessageField<super::super::bdtail_config::BdTailConfigurations>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.filters_configuration)
        pub filters_configuration: ::protobuf::MessageField<super::super::filter::FiltersConfiguration>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StateOfTheWorld {
        fn default() -> &'a StateOfTheWorld {
            <StateOfTheWorld as ::protobuf::Message>::default_instance()
        }
    }

    impl StateOfTheWorld {
        pub fn new() -> StateOfTheWorld {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::config::BufferConfigList>(
                "buffer_config_list",
                |m: &StateOfTheWorld| { &m.buffer_config_list },
                |m: &mut StateOfTheWorld| { &mut m.buffer_config_list },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::workflow::WorkflowsConfiguration>(
                "workflows_configuration",
                |m: &StateOfTheWorld| { &m.workflows_configuration },
                |m: &mut StateOfTheWorld| { &mut m.workflows_configuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::bdtail_config::BdTailConfigurations>(
                "bdtail_configuration",
                |m: &StateOfTheWorld| { &m.bdtail_configuration },
                |m: &mut StateOfTheWorld| { &mut m.bdtail_configuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::filter::FiltersConfiguration>(
                "filters_configuration",
                |m: &StateOfTheWorld| { &m.filters_configuration },
                |m: &mut StateOfTheWorld| { &mut m.filters_configuration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateOfTheWorld>(
                "ConfigurationUpdate.StateOfTheWorld",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StateOfTheWorld {
        const NAME: &'static str = "StateOfTheWorld";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.buffer_config_list)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflows_configuration)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.bdtail_configuration)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.filters_configuration)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.buffer_config_list.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.workflows_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.bdtail_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.filters_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.buffer_config_list.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.workflows_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.bdtail_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.filters_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StateOfTheWorld {
            StateOfTheWorld::new()
        }

        fn clear(&mut self) {
            self.buffer_config_list.clear();
            self.workflows_configuration.clear();
            self.bdtail_configuration.clear();
            self.filters_configuration.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StateOfTheWorld {
            static instance: StateOfTheWorld = StateOfTheWorld {
                buffer_config_list: ::protobuf::MessageField::none(),
                workflows_configuration: ::protobuf::MessageField::none(),
                bdtail_configuration: ::protobuf::MessageField::none(),
                filters_configuration: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StateOfTheWorld {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConfigurationUpdate.StateOfTheWorld").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StateOfTheWorld {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StateOfTheWorld {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.RuntimeUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RuntimeUpdate {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.version_nonce)
    pub version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.runtime)
    pub runtime: ::protobuf::MessageField<super::runtime::Runtime>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuntimeUpdate {
    fn default() -> &'a RuntimeUpdate {
        <RuntimeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeUpdate {
    pub fn new() -> RuntimeUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_nonce",
            |m: &RuntimeUpdate| { &m.version_nonce },
            |m: &mut RuntimeUpdate| { &mut m.version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::runtime::Runtime>(
            "runtime",
            |m: &RuntimeUpdate| { &m.runtime },
            |m: &mut RuntimeUpdate| { &mut m.runtime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeUpdate>(
            "RuntimeUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuntimeUpdate {
    const NAME: &'static str = "RuntimeUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_nonce = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runtime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
        }
        if let Some(v) = self.runtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_nonce.is_empty() {
            os.write_string(1, &self.version_nonce)?;
        }
        if let Some(v) = self.runtime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuntimeUpdate {
        RuntimeUpdate::new()
    }

    fn clear(&mut self) {
        self.version_nonce.clear();
        self.runtime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuntimeUpdate {
        static instance: RuntimeUpdate = RuntimeUpdate {
            version_nonce: ::std::string::String::new(),
            runtime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuntimeUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuntimeUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuntimeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ErrorShutdown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ErrorShutdown {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ErrorShutdown.grpc_status)
    pub grpc_status: i32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ErrorShutdown.grpc_message)
    pub grpc_message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ErrorShutdown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ErrorShutdown {
    fn default() -> &'a ErrorShutdown {
        <ErrorShutdown as ::protobuf::Message>::default_instance()
    }
}

impl ErrorShutdown {
    pub fn new() -> ErrorShutdown {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_status",
            |m: &ErrorShutdown| { &m.grpc_status },
            |m: &mut ErrorShutdown| { &mut m.grpc_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_message",
            |m: &ErrorShutdown| { &m.grpc_message },
            |m: &mut ErrorShutdown| { &mut m.grpc_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorShutdown>(
            "ErrorShutdown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ErrorShutdown {
    const NAME: &'static str = "ErrorShutdown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.grpc_status = is.read_int32()?;
                },
                18 => {
                    self.grpc_message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.grpc_status != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.grpc_status);
        }
        if !self.grpc_message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.grpc_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.grpc_status != 0 {
            os.write_int32(1, self.grpc_status)?;
        }
        if !self.grpc_message.is_empty() {
            os.write_string(2, &self.grpc_message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ErrorShutdown {
        ErrorShutdown::new()
    }

    fn clear(&mut self) {
        self.grpc_status = 0;
        self.grpc_message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ErrorShutdown {
        static instance: ErrorShutdown = ErrorShutdown {
            grpc_status: 0,
            grpc_message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ErrorShutdown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ErrorShutdown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ErrorShutdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorShutdown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.FlushBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlushBuffers {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.FlushBuffers.buffer_id_list)
    pub buffer_id_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.FlushBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlushBuffers {
    fn default() -> &'a FlushBuffers {
        <FlushBuffers as ::protobuf::Message>::default_instance()
    }
}

impl FlushBuffers {
    pub fn new() -> FlushBuffers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffer_id_list",
            |m: &FlushBuffers| { &m.buffer_id_list },
            |m: &mut FlushBuffers| { &mut m.buffer_id_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlushBuffers>(
            "FlushBuffers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlushBuffers {
    const NAME: &'static str = "FlushBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buffer_id_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buffer_id_list {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buffer_id_list {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlushBuffers {
        FlushBuffers::new()
    }

    fn clear(&mut self) {
        self.buffer_id_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlushBuffers {
        static instance: FlushBuffers = FlushBuffers {
            buffer_id_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlushBuffers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlushBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlushBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlushBuffers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyPathUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyPathUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyPathUploadResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyPathUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyPathUploadResponse {
    fn default() -> &'a SankeyPathUploadResponse {
        <SankeyPathUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl SankeyPathUploadResponse {
    pub fn new() -> SankeyPathUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &SankeyPathUploadResponse| { &m.upload_uuid },
            |m: &mut SankeyPathUploadResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &SankeyPathUploadResponse| { &m.error },
            |m: &mut SankeyPathUploadResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyPathUploadResponse>(
            "SankeyPathUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyPathUploadResponse {
    const NAME: &'static str = "SankeyPathUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyPathUploadResponse {
        SankeyPathUploadResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyPathUploadResponse {
        static instance: SankeyPathUploadResponse = SankeyPathUploadResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyPathUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyPathUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyPathUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyPathUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyIntentResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // message oneof groups
    pub decision: ::std::option::Option<sankey_intent_response::Decision>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyIntentResponse {
    fn default() -> &'a SankeyIntentResponse {
        <SankeyIntentResponse as ::protobuf::Message>::default_instance()
    }
}

impl SankeyIntentResponse {
    pub fn new() -> SankeyIntentResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentResponse.UploadImmediately upload_immediately = 3;

    pub fn upload_immediately(&self) -> &sankey_intent_response::UploadImmediately {
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(ref v)) => v,
            _ => <sankey_intent_response::UploadImmediately as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upload_immediately(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_upload_immediately(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_immediately(&mut self, v: sankey_intent_response::UploadImmediately) {
        self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_immediately(&mut self) -> &mut sankey_intent_response::UploadImmediately {
        if let ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(sankey_intent_response::UploadImmediately::new()));
        }
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_immediately(&mut self) -> sankey_intent_response::UploadImmediately {
        if self.has_upload_immediately() {
            match self.decision.take() {
                ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(v)) => v,
                _ => panic!(),
            }
        } else {
            sankey_intent_response::UploadImmediately::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Drop drop = 4;

    pub fn drop(&self) -> &sankey_intent_response::Drop {
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::Drop(ref v)) => v,
            _ => <sankey_intent_response::Drop as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_drop(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_drop(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::Drop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: sankey_intent_response::Drop) {
        self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::Drop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut sankey_intent_response::Drop {
        if let ::std::option::Option::Some(sankey_intent_response::Decision::Drop(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::Drop(sankey_intent_response::Drop::new()));
        }
        match self.decision {
            ::std::option::Option::Some(sankey_intent_response::Decision::Drop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_drop(&mut self) -> sankey_intent_response::Drop {
        if self.has_drop() {
            match self.decision.take() {
                ::std::option::Option::Some(sankey_intent_response::Decision::Drop(v)) => v,
                _ => panic!(),
            }
        } else {
            sankey_intent_response::Drop::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &SankeyIntentResponse| { &m.intent_uuid },
            |m: &mut SankeyIntentResponse| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, sankey_intent_response::UploadImmediately>(
            "upload_immediately",
            SankeyIntentResponse::has_upload_immediately,
            SankeyIntentResponse::upload_immediately,
            SankeyIntentResponse::mut_upload_immediately,
            SankeyIntentResponse::set_upload_immediately,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, sankey_intent_response::Drop>(
            "drop",
            SankeyIntentResponse::has_drop,
            SankeyIntentResponse::drop,
            SankeyIntentResponse::mut_drop,
            SankeyIntentResponse::set_drop,
        ));
        oneofs.push(sankey_intent_response::Decision::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyIntentResponse>(
            "SankeyIntentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyIntentResponse {
    const NAME: &'static str = "SankeyIntentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                26 => {
                    self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::UploadImmediately(is.read_message()?));
                },
                34 => {
                    self.decision = ::std::option::Option::Some(sankey_intent_response::Decision::Drop(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &sankey_intent_response::Decision::UploadImmediately(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &sankey_intent_response::Decision::Drop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &sankey_intent_response::Decision::UploadImmediately(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &sankey_intent_response::Decision::Drop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyIntentResponse {
        SankeyIntentResponse::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.decision = ::std::option::Option::None;
        self.decision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyIntentResponse {
        static instance: SankeyIntentResponse = SankeyIntentResponse {
            intent_uuid: ::std::string::String::new(),
            decision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyIntentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyIntentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyIntentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyIntentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SankeyIntentResponse`
pub mod sankey_intent_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.decision)
    pub enum Decision {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.upload_immediately)
        UploadImmediately(UploadImmediately),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.drop)
        Drop(Drop),
    }

    impl ::protobuf::Oneof for Decision {
    }

    impl ::protobuf::OneofFull for Decision {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::SankeyIntentResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("decision").unwrap()).clone()
        }
    }

    impl Decision {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Decision>("decision")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.UploadImmediately)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UploadImmediately {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.UploadImmediately.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UploadImmediately {
        fn default() -> &'a UploadImmediately {
            <UploadImmediately as ::protobuf::Message>::default_instance()
        }
    }

    impl UploadImmediately {
        pub fn new() -> UploadImmediately {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadImmediately>(
                "SankeyIntentResponse.UploadImmediately",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UploadImmediately {
        const NAME: &'static str = "UploadImmediately";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UploadImmediately {
            UploadImmediately::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UploadImmediately {
            static instance: UploadImmediately = UploadImmediately {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UploadImmediately {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SankeyIntentResponse.UploadImmediately").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UploadImmediately {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UploadImmediately {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Drop)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drop {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Drop.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drop {
        fn default() -> &'a Drop {
            <Drop as ::protobuf::Message>::default_instance()
        }
    }

    impl Drop {
        pub fn new() -> Drop {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Drop>(
                "SankeyIntentResponse.Drop",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Drop {
        const NAME: &'static str = "Drop";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drop {
            Drop::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drop {
            static instance: Drop = Drop {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Drop {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SankeyIntentResponse.Drop").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Drop {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Drop {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ApiResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApiResponse {
    // message oneof groups
    pub response_type: ::std::option::Option<api_response::Response_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ApiResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiResponse {
    fn default() -> &'a ApiResponse {
        <ApiResponse as ::protobuf::Message>::default_instance()
    }
}

impl ApiResponse {
    pub fn new() -> ApiResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.HandshakeResponse handshake = 1;

    pub fn handshake(&self) -> &HandshakeResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(ref v)) => v,
            _ => <HandshakeResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_handshake(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_handshake(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake(&mut self, v: HandshakeResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake(&mut self) -> &mut HandshakeResponse {
        if let ::std::option::Option::Some(api_response::Response_type::Handshake(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(HandshakeResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake(&mut self) -> HandshakeResponse {
        if self.has_handshake() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadResponse log_upload = 2;

    pub fn log_upload(&self) -> &LogUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(ref v)) => v,
            _ => <LogUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_log_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload(&mut self, v: LogUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload(&mut self) -> &mut LogUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::LogUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(LogUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload(&mut self) -> LogUploadResponse {
        if self.has_log_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::LogUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse log_upload_intent = 8;

    pub fn log_upload_intent(&self) -> &LogUploadIntentResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(ref v)) => v,
            _ => <LogUploadIntentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload_intent(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_log_upload_intent(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload_intent(&mut self, v: LogUploadIntentResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload_intent(&mut self) -> &mut LogUploadIntentResponse {
        if let ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(LogUploadIntentResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload_intent(&mut self) -> LogUploadIntentResponse {
        if self.has_log_upload_intent() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadIntentResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.StatsUploadResponse stats_upload = 7;

    pub fn stats_upload(&self) -> &StatsUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(ref v)) => v,
            _ => <StatsUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stats_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_stats_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stats_upload(&mut self, v: StatsUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stats_upload(&mut self) -> &mut StatsUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::StatsUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(StatsUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stats_upload(&mut self) -> StatsUploadResponse {
        if self.has_stats_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::StatsUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            StatsUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.PongResponse pong = 3;

    pub fn pong(&self) -> &PongResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(ref v)) => v,
            _ => <PongResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pong(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_pong(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: PongResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pong(&mut self) -> &mut PongResponse {
        if let ::std::option::Option::Some(api_response::Response_type::Pong(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(PongResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pong(&mut self) -> PongResponse {
        if self.has_pong() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::Pong(v)) => v,
                _ => panic!(),
            }
        } else {
            PongResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdate configuration_update = 4;

    pub fn configuration_update(&self) -> &ConfigurationUpdate {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ref v)) => v,
            _ => <ConfigurationUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_configuration_update(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_configuration_update(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_configuration_update(&mut self, v: ConfigurationUpdate) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_configuration_update(&mut self) -> &mut ConfigurationUpdate {
        if let ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ConfigurationUpdate::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_configuration_update(&mut self) -> ConfigurationUpdate {
        if self.has_configuration_update() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdate::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.RuntimeUpdate runtime_update = 5;

    pub fn runtime_update(&self) -> &RuntimeUpdate {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(ref v)) => v,
            _ => <RuntimeUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_runtime_update(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_runtime_update(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_update(&mut self, v: RuntimeUpdate) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_update(&mut self) -> &mut RuntimeUpdate {
        if let ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(RuntimeUpdate::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_update(&mut self) -> RuntimeUpdate {
        if self.has_runtime_update() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeUpdate::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ErrorShutdown error_shutdown = 6;

    pub fn error_shutdown(&self) -> &ErrorShutdown {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ref v)) => v,
            _ => <ErrorShutdown as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error_shutdown(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_error_shutdown(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_shutdown(&mut self, v: ErrorShutdown) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_shutdown(&mut self) -> &mut ErrorShutdown {
        if let ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ErrorShutdown::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_shutdown(&mut self) -> ErrorShutdown {
        if self.has_error_shutdown() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(v)) => v,
                _ => panic!(),
            }
        } else {
            ErrorShutdown::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.FlushBuffers flush_buffers = 9;

    pub fn flush_buffers(&self) -> &FlushBuffers {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(ref v)) => v,
            _ => <FlushBuffers as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_flush_buffers(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_flush_buffers(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flush_buffers(&mut self, v: FlushBuffers) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flush_buffers(&mut self) -> &mut FlushBuffers {
        if let ::std::option::Option::Some(api_response::Response_type::FlushBuffers(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(FlushBuffers::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flush_buffers(&mut self) -> FlushBuffers {
        if self.has_flush_buffers() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::FlushBuffers(v)) => v,
                _ => panic!(),
            }
        } else {
            FlushBuffers::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyPathUploadResponse sankey_diagram_upload = 12;

    pub fn sankey_diagram_upload(&self) -> &SankeyPathUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(ref v)) => v,
            _ => <SankeyPathUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_diagram_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_sankey_diagram_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_diagram_upload(&mut self, v: SankeyPathUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_diagram_upload(&mut self) -> &mut SankeyPathUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(SankeyPathUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_diagram_upload(&mut self) -> SankeyPathUploadResponse {
        if self.has_sankey_diagram_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyPathUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentResponse sankey_intent_response = 13;

    pub fn sankey_intent_response(&self) -> &SankeyIntentResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(ref v)) => v,
            _ => <SankeyIntentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_intent_response(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_sankey_intent_response(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_intent_response(&mut self, v: SankeyIntentResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_intent_response(&mut self) -> &mut SankeyIntentResponse {
        if let ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(SankeyIntentResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_intent_response(&mut self) -> SankeyIntentResponse {
        if self.has_sankey_intent_response() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyIntentResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactResponse artifact_upload = 14;

    pub fn artifact_upload(&self) -> &UploadArtifactResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(ref v)) => v,
            _ => <UploadArtifactResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_artifact_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_artifact_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_upload(&mut self, v: UploadArtifactResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_upload(&mut self) -> &mut UploadArtifactResponse {
        if let ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(UploadArtifactResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_upload(&mut self) -> UploadArtifactResponse {
        if self.has_artifact_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            UploadArtifactResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponse artifact_intent = 15;

    pub fn artifact_intent(&self) -> &UploadArtifactIntentResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(ref v)) => v,
            _ => <UploadArtifactIntentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_artifact_intent(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_artifact_intent(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_artifact_intent(&mut self, v: UploadArtifactIntentResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_artifact_intent(&mut self) -> &mut UploadArtifactIntentResponse {
        if let ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(UploadArtifactIntentResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_artifact_intent(&mut self) -> UploadArtifactIntentResponse {
        if self.has_artifact_intent() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            UploadArtifactIntentResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HandshakeResponse>(
            "handshake",
            ApiResponse::has_handshake,
            ApiResponse::handshake,
            ApiResponse::mut_handshake,
            ApiResponse::set_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadResponse>(
            "log_upload",
            ApiResponse::has_log_upload,
            ApiResponse::log_upload,
            ApiResponse::mut_log_upload,
            ApiResponse::set_log_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadIntentResponse>(
            "log_upload_intent",
            ApiResponse::has_log_upload_intent,
            ApiResponse::log_upload_intent,
            ApiResponse::mut_log_upload_intent,
            ApiResponse::set_log_upload_intent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatsUploadResponse>(
            "stats_upload",
            ApiResponse::has_stats_upload,
            ApiResponse::stats_upload,
            ApiResponse::mut_stats_upload,
            ApiResponse::set_stats_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PongResponse>(
            "pong",
            ApiResponse::has_pong,
            ApiResponse::pong,
            ApiResponse::mut_pong,
            ApiResponse::set_pong,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdate>(
            "configuration_update",
            ApiResponse::has_configuration_update,
            ApiResponse::configuration_update,
            ApiResponse::mut_configuration_update,
            ApiResponse::set_configuration_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RuntimeUpdate>(
            "runtime_update",
            ApiResponse::has_runtime_update,
            ApiResponse::runtime_update,
            ApiResponse::mut_runtime_update,
            ApiResponse::set_runtime_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ErrorShutdown>(
            "error_shutdown",
            ApiResponse::has_error_shutdown,
            ApiResponse::error_shutdown,
            ApiResponse::mut_error_shutdown,
            ApiResponse::set_error_shutdown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FlushBuffers>(
            "flush_buffers",
            ApiResponse::has_flush_buffers,
            ApiResponse::flush_buffers,
            ApiResponse::mut_flush_buffers,
            ApiResponse::set_flush_buffers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyPathUploadResponse>(
            "sankey_diagram_upload",
            ApiResponse::has_sankey_diagram_upload,
            ApiResponse::sankey_diagram_upload,
            ApiResponse::mut_sankey_diagram_upload,
            ApiResponse::set_sankey_diagram_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyIntentResponse>(
            "sankey_intent_response",
            ApiResponse::has_sankey_intent_response,
            ApiResponse::sankey_intent_response,
            ApiResponse::mut_sankey_intent_response,
            ApiResponse::set_sankey_intent_response,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UploadArtifactResponse>(
            "artifact_upload",
            ApiResponse::has_artifact_upload,
            ApiResponse::artifact_upload,
            ApiResponse::mut_artifact_upload,
            ApiResponse::set_artifact_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UploadArtifactIntentResponse>(
            "artifact_intent",
            ApiResponse::has_artifact_intent,
            ApiResponse::artifact_intent,
            ApiResponse::mut_artifact_intent,
            ApiResponse::set_artifact_intent,
        ));
        oneofs.push(api_response::Response_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiResponse>(
            "ApiResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiResponse {
    const NAME: &'static str = "ApiResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(is.read_message()?));
                },
                18 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(is.read_message()?));
                },
                66 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(is.read_message()?));
                },
                58 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(is.read_message()?));
                },
                26 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(is.read_message()?));
                },
                34 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(is.read_message()?));
                },
                42 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(is.read_message()?));
                },
                50 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(is.read_message()?));
                },
                74 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(is.read_message()?));
                },
                98 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(is.read_message()?));
                },
                106 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(is.read_message()?));
                },
                114 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactUpload(is.read_message()?));
                },
                122 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ArtifactIntent(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &api_response::Response_type::Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::LogUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::LogUploadIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::StatsUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::Pong(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ConfigurationUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::RuntimeUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ErrorShutdown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::FlushBuffers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::SankeyDiagramUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::SankeyIntentResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ArtifactUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ArtifactIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &api_response::Response_type::Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &api_response::Response_type::LogUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &api_response::Response_type::LogUploadIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &api_response::Response_type::StatsUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &api_response::Response_type::Pong(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &api_response::Response_type::ConfigurationUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &api_response::Response_type::RuntimeUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &api_response::Response_type::ErrorShutdown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &api_response::Response_type::FlushBuffers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &api_response::Response_type::SankeyDiagramUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &api_response::Response_type::SankeyIntentResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
                &api_response::Response_type::ArtifactUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &api_response::Response_type::ArtifactIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiResponse {
        ApiResponse::new()
    }

    fn clear(&mut self) {
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiResponse {
        static instance: ApiResponse = ApiResponse {
            response_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApiResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ApiResponse`
pub mod api_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ApiResponse.response_type)
    pub enum Response_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.handshake)
        Handshake(super::HandshakeResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.log_upload)
        LogUpload(super::LogUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.log_upload_intent)
        LogUploadIntent(super::LogUploadIntentResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.stats_upload)
        StatsUpload(super::StatsUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.pong)
        Pong(super::PongResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.configuration_update)
        ConfigurationUpdate(super::ConfigurationUpdate),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.runtime_update)
        RuntimeUpdate(super::RuntimeUpdate),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.error_shutdown)
        ErrorShutdown(super::ErrorShutdown),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.flush_buffers)
        FlushBuffers(super::FlushBuffers),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.sankey_diagram_upload)
        SankeyDiagramUpload(super::SankeyPathUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.sankey_intent_response)
        SankeyIntentResponse(super::SankeyIntentResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.artifact_upload)
        ArtifactUpload(super::UploadArtifactResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.artifact_intent)
        ArtifactIntent(super::UploadArtifactIntentResponse),
    }

    impl ::protobuf::Oneof for Response_type {
    }

    impl ::protobuf::OneofFull for Response_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ApiResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response_type").unwrap()).clone()
        }
    }

    impl Response_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response_type>("response_type")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,bitdrift_public/protobuf/client/v1/api.proto\x12\"bitdrift_public.pro\
    tobuf.client.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/pro\
    tobuf/duration.proto\x1a0bitdrift_public/protobuf/client/v1/runtime.prot\
    o\x1a/bitdrift_public/protobuf/client/v1/metric.proto\x1a/bitdrift_publi\
    c/protobuf/filter/v1/filter.proto\x1a3bitdrift_public/protobuf/workflow/\
    v1/workflow.proto\x1a6bitdrift_public/protobuf/bdtail/v1/bdtail_config.p\
    roto\x1a/bitdrift_public/protobuf/config/v1/config.proto\x1a1bitdrift_pu\
    blic/protobuf/logging/v1/payload.proto\x1a\x17validate/validate.proto\"m\
    \n\x0eClientKillFile\x12\x20\n\x0capi_key_hash\x18\x01\x20\x01(\x0cR\nap\
    iKeyHash\x129\n\nkill_until\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\tkillUntil\"\xff\x03\n\x10HandshakeRequest\x12\x84\x01\n\x16sta\
    tic_device_metadata\x18\x01\x20\x03(\x0b2N.bitdrift_public.protobuf.clie\
    nt.v1.HandshakeRequest.StaticDeviceMetadataEntryR\x14staticDeviceMetadat\
    a\x12>\n\x1bconfiguration_version_nonce\x18\x03\x20\x01(\tR\x19configura\
    tionVersionNonce\x122\n\x15runtime_version_nonce\x18\x04\x20\x01(\tR\x13\
    runtimeVersionNonce\x12<\n\x1aprevious_disconnect_reason\x18\x06\x20\x01\
    (\tR\x18previousDisconnectReason\x12\x1d\n\nsleep_mode\x18\x07\x20\x01(\
    \x08R\tsleepMode\x1ar\n\x19StaticDeviceMetadataEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12?\n\x05value\x18\x02\x20\x01(\x0b2).bitdr\
    ift_public.protobuf.logging.v1.DataR\x05value:\x028\x01J\x04\x08\x02\x10\
    \x03J\x04\x08\x05\x10\x06R\x13fields_for_all_logs\"\x92\x03\n\x16LogUplo\
    adIntentRequest\x12\x1b\n\tlog_count\x18\x01\x20\x01(\rR\x08logCount\x12\
    \x1d\n\nbyte_count\x18\x02\x20\x01(\rR\tbyteCount\x12\x1b\n\tbuffer_id\
    \x18\x03\x20\x01(\tR\x08bufferId\x12\x1f\n\x0bintent_uuid\x18\x04\x20\
    \x01(\tR\nintentUuid\x12\x1d\n\nsession_id\x18\x06\x20\x01(\tR\tsessionI\
    d\x12\x87\x01\n\x16workflow_action_upload\x18\x05\x20\x01(\x0b2O.bitdrif\
    t_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUploadH\
    \0R\x14workflowActionUpload\x1aF\n\x14WorkflowActionUpload\x12.\n\x13wor\
    kflow_action_ids\x18\x01\x20\x03(\tR\x11workflowActionIdsB\r\n\x0bintent\
    _type\"\xbb\x02\n\x17LogUploadIntentResponse\x12\x1f\n\x0bintent_uuid\
    \x18\x01\x20\x01(\tR\nintentUuid\x12~\n\x12upload_immediately\x18\x02\
    \x20\x01(\x0b2M.bitdrift_public.protobuf.client.v1.LogUploadIntentRespon\
    se.UploadImmediatelyH\0R\x11uploadImmediately\x12V\n\x04drop\x18\x03\x20\
    \x01(\x0b2@.bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.D\
    ropH\0R\x04drop\x1a\x13\n\x11UploadImmediately\x1a\x06\n\x04DropB\n\n\
    \x08decision\"\x84\x01\n\x10LogUploadRequest\x12(\n\x0bupload_uuid\x18\
    \x01\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x1c\n\x04log\
    s\x18\x02\x20\x03(\x0cR\x04logsB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12(\n\
    \x0bbuffer_uuid\x18\x03\x20\x01(\tR\nbufferUuidB\x07\xfaB\x04r\x02\x10\
    \x01\",\n\x0bPingRequest\x12\x1d\n\nsleep_mode\x18\x01\x20\x01(\x08R\tsl\
    eepMode\"\xfc\x01\n\x16ConfigurationUpdateAck\x12;\n\x1alast_applied_ver\
    sion_nonce\x18\x01\x20\x01(\tR\x17lastAppliedVersionNonce\x12S\n\x04nack\
    \x18\x02\x20\x01(\x0b2?.bitdrift_public.protobuf.client.v1.Configuration\
    UpdateAck.NackR\x04nack\x1aP\n\x04Nack\x12#\n\rversion_nonce\x18\x01\x20\
    \x01(\tR\x0cversionNonce\x12#\n\rerror_details\x18\x02\x20\x01(\tR\x0cer\
    rorDetails\"\xeb\x08\n\nApiRequest\x12T\n\thandshake\x18\x01\x20\x01(\
    \x0b24.bitdrift_public.protobuf.client.v1.HandshakeRequestH\0R\thandshak\
    e\x12h\n\x11log_upload_intent\x18\x07\x20\x01(\x0b2:.bitdrift_public.pro\
    tobuf.client.v1.LogUploadIntentRequestH\0R\x0flogUploadIntent\x12U\n\nlo\
    g_upload\x18\x02\x20\x01(\x0b24.bitdrift_public.protobuf.client.v1.LogUp\
    loadRequestH\0R\tlogUpload\x12[\n\x0cstats_upload\x18\x06\x20\x01(\x0b26\
    .bitdrift_public.protobuf.client.v1.StatsUploadRequestH\0R\x0bstatsUploa\
    d\x12E\n\x04ping\x18\x03\x20\x01(\x0b2/.bitdrift_public.protobuf.client.\
    v1.PingRequestH\0R\x04ping\x12v\n\x18configuration_update_ack\x18\x04\
    \x20\x01(\x0b2:.bitdrift_public.protobuf.client.v1.ConfigurationUpdateAc\
    kH\0R\x16configurationUpdateAck\x12j\n\x12runtime_update_ack\x18\x05\x20\
    \x01(\x0b2:.bitdrift_public.protobuf.client.v1.ConfigurationUpdateAckH\0\
    R\x10runtimeUpdateAck\x12k\n\x12sankey_path_upload\x18\n\x20\x01(\x0b2;.\
    bitdrift_public.protobuf.client.v1.SankeyPathUploadRequestH\0R\x10sankey\
    PathUpload\x12^\n\rsankey_intent\x18\x0b\x20\x01(\x0b27.bitdrift_public.\
    protobuf.client.v1.SankeyIntentRequestH\0R\x0csankeyIntent\x12d\n\x0fart\
    ifact_upload\x18\x0c\x20\x01(\x0b29.bitdrift_public.protobuf.client.v1.U\
    ploadArtifactRequestH\0R\x0eartifactUpload\x12j\n\x0fartifact_intent\x18\
    \r\x20\x01(\x0b2?.bitdrift_public.protobuf.client.v1.UploadArtifactInten\
    tRequestH\0R\x0eartifactIntentB\x13\n\x0crequest_type\x12\x03\xf8B\x01J\
    \x04\x08\x08\x10\tJ\x04\x08\t\x10\n\"\x9a\x02\n\x17SankeyPathUploadReque\
    st\x12(\n\x0bupload_uuid\x18\x04\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\
    \x02\x10\x01\x12\x17\n\x02id\x18\x01\x20\x01(\tR\x02idB\x07\xfaB\x04r\
    \x02\x10\x01\x12\x20\n\x07path_id\x18\x02\x20\x01(\tR\x06pathIdB\x07\xfa\
    B\x04r\x02\x10\x01\x12`\n\x05nodes\x18\x03\x20\x03(\x0b2@.bitdrift_publi\
    c.protobuf.client.v1.SankeyPathUploadRequest.NodeR\x05nodesB\x08\xfaB\
    \x05\x92\x01\x02\x08\x01\x1a8\n\x04Node\x120\n\x0fextracted_value\x18\
    \x01\x20\x01(\tR\x0eextractedValueB\x07\xfaB\x04r\x02\x10\x01\"\x96\x01\
    \n\x13SankeyIntentRequest\x12(\n\x0bintent_uuid\x18\x01\x20\x01(\tR\nint\
    entUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x20\n\x07path_id\x18\x02\x20\x01(\
    \tR\x06pathIdB\x07\xfaB\x04r\x02\x10\x01\x123\n\x11sankey_diagram_id\x18\
    \x03\x20\x01(\tR\x0fsankeyDiagramIdB\x07\xfaB\x04r\x02\x10\x01\"\xe9\x01\
    \n\x1bUploadArtifactIntentRequest\x12(\n\x0bintent_uuid\x18\x01\x20\x01(\
    \tR\nintentUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x20\n\x07type_id\x18\x02\
    \x20\x01(\tR\x06typeIdB\x07\xfaB\x04r\x02\x10\x01\x12\x1a\n\x08metadata\
    \x18\x03\x20\x01(\x0cR\x08metadata\x12(\n\x0bartifact_id\x18\x04\x20\x01\
    (\tR\nartifactIdB\x07\xfaB\x04r\x02\x10\x01\x128\n\x04time\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x04timeB\x08\xfaB\x05\x8a\x01\
    \x02\x10\x01\"\xd4\x02\n\x1cUploadArtifactIntentResponse\x12(\n\x0binten\
    t_uuid\x18\x01\x20\x01(\tR\nintentUuidB\x07\xfaB\x04r\x02\x10\x01\x12\
    \x83\x01\n\x12upload_immediately\x18\x03\x20\x01(\x0b2R.bitdrift_public.\
    protobuf.client.v1.UploadArtifactIntentResponse.UploadImmediatelyH\0R\
    \x11uploadImmediately\x12[\n\x04drop\x18\x04\x20\x01(\x0b2E.bitdrift_pub\
    lic.protobuf.client.v1.UploadArtifactIntentResponse.DropH\0R\x04drop\x1a\
    \x13\n\x11UploadImmediately\x1a\x06\n\x04DropB\n\n\x08decision\"\xed\x03\
    \n\x15UploadArtifactRequest\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\nu\
    ploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x20\n\x07type_id\x18\x02\x20\
    \x01(\tR\x06typeIdB\x07\xfaB\x04r\x02\x10\x01\x12\x1a\n\x08contents\x18\
    \x03\x20\x01(\x0cR\x08contents\x12(\n\x0bartifact_id\x18\x04\x20\x01(\tR\
    \nartifactIdB\x07\xfaB\x04r\x02\x10\x01\x12s\n\x0estate_metadata\x18\x05\
    \x20\x03(\x0b2L.bitdrift_public.protobuf.client.v1.UploadArtifactRequest\
    .StateMetadataEntryR\rstateMetadata\x128\n\x04time\x18\x06\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x04timeB\x08\xfaB\x05\x8a\x01\x02\x10\
    \x01\x12&\n\nsession_id\x18\x07\x20\x01(\tR\tsessionIdB\x07\xfaB\x04r\
    \x02\x10\x01\x1ak\n\x12StateMetadataEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12?\n\x05value\x18\x02\x20\x01(\x0b2).bitdrift_public.p\
    rotobuf.logging.v1.DataR\x05value:\x028\x01\"X\n\x16UploadArtifactRespon\
    se\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\
    \x02\x10\x01\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\"\x94\x02\n\
    \x11HandshakeResponse\x12m\n\x0fstream_settings\x18\x01\x20\x01(\x0b2D.b\
    itdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettingsR\x0es\
    treamSettings\x12>\n\x1bconfiguration_update_status\x18\x02\x20\x01(\rR\
    \x19configurationUpdateStatus\x1aP\n\x0eStreamSettings\x12>\n\rping_inte\
    rval\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0cpingInterval\
    \"\r\n\x0bRateLimited\"\xca\x01\n\x11LogUploadResponse\x12(\n\x0bupload_\
    uuid\x18\x01\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x14\
    \n\x05error\x18\x02\x20\x01(\tR\x05error\x12!\n\x0clogs_dropped\x18\x03\
    \x20\x01(\rR\x0blogsDropped\x12R\n\x0crate_limited\x18\x04\x20\x01(\x0b2\
    /.bitdrift_public.protobuf.client.v1.RateLimitedR\x0brateLimited\"\xae\
    \x06\n\x12StatsUploadRequest\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\n\
    uploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12e\n\x08snapshot\x18\x02\x20\x03\
    (\x0b2?.bitdrift_public.protobuf.client.v1.StatsUploadRequest.SnapshotR\
    \x08snapshotB\x08\xfaB\x05\x92\x01\x02\x08\x01\x123\n\x07sent_at\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x06sentAt\x1a\xd1\x04\n\
    \x08Snapshot\x12K\n\x07metrics\x18\x01\x20\x01(\x0b2/.bitdrift_public.pr\
    otobuf.client.v1.MetricsListH\0R\x07metrics\x12l\n\naggregated\x18\x02\
    \x20\x01(\x0b2J.bitdrift_public.protobuf.client.v1.StatsUploadRequest.Sn\
    apshot.AggregatedH\x01R\naggregated\x12\x86\x01\n\x13metric_id_overflows\
    \x18\x03\x20\x03(\x0b2V.bitdrift_public.protobuf.client.v1.StatsUploadRe\
    quest.Snapshot.MetricIdOverflowsEntryR\x11metricIdOverflows\x1a\x90\x01\
    \n\nAggregated\x12G\n\x0cperiod_start\x18\x04\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\x0bperiodStartB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x129\
    \n\nperiod_end\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tper\
    iodEnd\x1aD\n\x16MetricIdOverflowsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x04R\x05value:\x028\x01B\
    \x14\n\rsnapshot_type\x12\x03\xf8B\x01B\x12\n\x0boccurred_at\x12\x03\xf8\
    B\x01\"~\n\x13StatsUploadResponse\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\
    \tR\nuploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x14\n\x05error\x18\x02\
    \x20\x01(\tR\x05error\x12'\n\x0fmetrics_dropped\x18\x03\x20\x01(\rR\x0em\
    etricsDropped\"\x0e\n\x0cPongResponse\"\xba\x05\n\x13ConfigurationUpdate\
    \x12#\n\rversion_nonce\x18\x01\x20\x01(\tR\x0cversionNonce\x12v\n\x12sta\
    te_of_the_world\x18\x02\x20\x01(\x0b2G.bitdrift_public.protobuf.client.v\
    1.ConfigurationUpdate.StateOfTheWorldH\0R\x0fstateOfTheWorld\x1a\xf6\x03\
    \n\x0fStateOfTheWorld\x12b\n\x12buffer_config_list\x18\x03\x20\x01(\x0b2\
    4.bitdrift_public.protobuf.config.v1.BufferConfigListR\x10bufferConfigLi\
    st\x12u\n\x17workflows_configuration\x18\x04\x20\x01(\x0b2<.bitdrift_pub\
    lic.protobuf.workflow.v1.WorkflowsConfigurationR\x16workflowsConfigurati\
    on\x12k\n\x14bdtail_configuration\x18\x06\x20\x01(\x0b28.bitdrift_public\
    .protobuf.bdtail.v1.BdTailConfigurationsR\x13bdtailConfiguration\x12m\n\
    \x15filters_configuration\x18\x08\x20\x01(\x0b28.bitdrift_public.protobu\
    f.filter.v1.FiltersConfigurationR\x14filtersConfigurationJ\x04\x08\x02\
    \x10\x03J\x04\x08\x07\x10\x08R\x08mll_listR\x16insights_configurationB\r\
    \n\x0bupdate_type\"{\n\rRuntimeUpdate\x12#\n\rversion_nonce\x18\x01\x20\
    \x01(\tR\x0cversionNonce\x12E\n\x07runtime\x18\x02\x20\x01(\x0b2+.bitdri\
    ft_public.protobuf.client.v1.RuntimeR\x07runtime\"S\n\rErrorShutdown\x12\
    \x1f\n\x0bgrpc_status\x18\x01\x20\x01(\x05R\ngrpcStatus\x12!\n\x0cgrpc_m\
    essage\x18\x02\x20\x01(\tR\x0bgrpcMessage\"4\n\x0cFlushBuffers\x12$\n\
    \x0ebuffer_id_list\x18\x01\x20\x03(\tR\x0cbufferIdList\"Z\n\x18SankeyPat\
    hUploadResponse\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\nuploadUuidB\
    \x07\xfaB\x04r\x02\x10\x01\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05err\
    or\"\xcb\x02\n\x14SankeyIntentResponse\x12(\n\x0bintent_uuid\x18\x01\x20\
    \x01(\tR\nintentUuidB\x07\xfaB\x04r\x02\x10\x01\x12{\n\x12upload_immedia\
    tely\x18\x03\x20\x01(\x0b2J.bitdrift_public.protobuf.client.v1.SankeyInt\
    entResponse.UploadImmediatelyH\0R\x11uploadImmediately\x12S\n\x04drop\
    \x18\x04\x20\x01(\x0b2=.bitdrift_public.protobuf.client.v1.SankeyIntentR\
    esponse.DropH\0R\x04drop\x1a\x13\n\x11UploadImmediately\x1a\x06\n\x04Dro\
    pB\n\n\x08decisionJ\x04\x08\x02\x10\x03R\x08decision\"\xa8\n\n\x0bApiRes\
    ponse\x12U\n\thandshake\x18\x01\x20\x01(\x0b25.bitdrift_public.protobuf.\
    client.v1.HandshakeResponseH\0R\thandshake\x12V\n\nlog_upload\x18\x02\
    \x20\x01(\x0b25.bitdrift_public.protobuf.client.v1.LogUploadResponseH\0R\
    \tlogUpload\x12i\n\x11log_upload_intent\x18\x08\x20\x01(\x0b2;.bitdrift_\
    public.protobuf.client.v1.LogUploadIntentResponseH\0R\x0flogUploadIntent\
    \x12\\\n\x0cstats_upload\x18\x07\x20\x01(\x0b27.bitdrift_public.protobuf\
    .client.v1.StatsUploadResponseH\0R\x0bstatsUpload\x12F\n\x04pong\x18\x03\
    \x20\x01(\x0b20.bitdrift_public.protobuf.client.v1.PongResponseH\0R\x04p\
    ong\x12l\n\x14configuration_update\x18\x04\x20\x01(\x0b27.bitdrift_publi\
    c.protobuf.client.v1.ConfigurationUpdateH\0R\x13configurationUpdate\x12Z\
    \n\x0eruntime_update\x18\x05\x20\x01(\x0b21.bitdrift_public.protobuf.cli\
    ent.v1.RuntimeUpdateH\0R\rruntimeUpdate\x12Z\n\x0eerror_shutdown\x18\x06\
    \x20\x01(\x0b21.bitdrift_public.protobuf.client.v1.ErrorShutdownH\0R\rer\
    rorShutdown\x12W\n\rflush_buffers\x18\t\x20\x01(\x0b20.bitdrift_public.p\
    rotobuf.client.v1.FlushBuffersH\0R\x0cflushBuffers\x12r\n\x15sankey_diag\
    ram_upload\x18\x0c\x20\x01(\x0b2<.bitdrift_public.protobuf.client.v1.San\
    keyPathUploadResponseH\0R\x13sankeyDiagramUpload\x12p\n\x16sankey_intent\
    _response\x18\r\x20\x01(\x0b28.bitdrift_public.protobuf.client.v1.Sankey\
    IntentResponseH\0R\x14sankeyIntentResponse\x12e\n\x0fartifact_upload\x18\
    \x0e\x20\x01(\x0b2:.bitdrift_public.protobuf.client.v1.UploadArtifactRes\
    ponseH\0R\x0eartifactUpload\x12k\n\x0fartifact_intent\x18\x0f\x20\x01(\
    \x0b2@.bitdrift_public.protobuf.client.v1.UploadArtifactIntentResponseH\
    \0R\x0eartifactIntentB\x14\n\rresponse_type\x12\x03\xf8B\x01J\x04\x08\n\
    \x10\x0bJ\x04\x08\x0b\x10\x0c2x\n\nApiService\x12j\n\x03Mux\x12..bitdrif\
    t_public.protobuf.client.v1.ApiRequest\x1a/.bitdrift_public.protobuf.cli\
    ent.v1.ApiResponse(\x010\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(10);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(super::runtime::file_descriptor().clone());
            deps.push(super::metric::file_descriptor().clone());
            deps.push(super::filter::file_descriptor().clone());
            deps.push(super::workflow::file_descriptor().clone());
            deps.push(super::bdtail_config::file_descriptor().clone());
            deps.push(super::config::file_descriptor().clone());
            deps.push(super::payload::file_descriptor().clone());
            deps.push(super::validate::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(40);
            messages.push(ClientKillFile::generated_message_descriptor_data());
            messages.push(HandshakeRequest::generated_message_descriptor_data());
            messages.push(LogUploadIntentRequest::generated_message_descriptor_data());
            messages.push(LogUploadIntentResponse::generated_message_descriptor_data());
            messages.push(LogUploadRequest::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(ConfigurationUpdateAck::generated_message_descriptor_data());
            messages.push(ApiRequest::generated_message_descriptor_data());
            messages.push(SankeyPathUploadRequest::generated_message_descriptor_data());
            messages.push(SankeyIntentRequest::generated_message_descriptor_data());
            messages.push(UploadArtifactIntentRequest::generated_message_descriptor_data());
            messages.push(UploadArtifactIntentResponse::generated_message_descriptor_data());
            messages.push(UploadArtifactRequest::generated_message_descriptor_data());
            messages.push(UploadArtifactResponse::generated_message_descriptor_data());
            messages.push(HandshakeResponse::generated_message_descriptor_data());
            messages.push(RateLimited::generated_message_descriptor_data());
            messages.push(LogUploadResponse::generated_message_descriptor_data());
            messages.push(StatsUploadRequest::generated_message_descriptor_data());
            messages.push(StatsUploadResponse::generated_message_descriptor_data());
            messages.push(PongResponse::generated_message_descriptor_data());
            messages.push(ConfigurationUpdate::generated_message_descriptor_data());
            messages.push(RuntimeUpdate::generated_message_descriptor_data());
            messages.push(ErrorShutdown::generated_message_descriptor_data());
            messages.push(FlushBuffers::generated_message_descriptor_data());
            messages.push(SankeyPathUploadResponse::generated_message_descriptor_data());
            messages.push(SankeyIntentResponse::generated_message_descriptor_data());
            messages.push(ApiResponse::generated_message_descriptor_data());
            messages.push(log_upload_intent_request::WorkflowActionUpload::generated_message_descriptor_data());
            messages.push(log_upload_intent_response::UploadImmediately::generated_message_descriptor_data());
            messages.push(log_upload_intent_response::Drop::generated_message_descriptor_data());
            messages.push(configuration_update_ack::Nack::generated_message_descriptor_data());
            messages.push(sankey_path_upload_request::Node::generated_message_descriptor_data());
            messages.push(upload_artifact_intent_response::UploadImmediately::generated_message_descriptor_data());
            messages.push(upload_artifact_intent_response::Drop::generated_message_descriptor_data());
            messages.push(handshake_response::StreamSettings::generated_message_descriptor_data());
            messages.push(stats_upload_request::Snapshot::generated_message_descriptor_data());
            messages.push(stats_upload_request::snapshot::Aggregated::generated_message_descriptor_data());
            messages.push(configuration_update::StateOfTheWorld::generated_message_descriptor_data());
            messages.push(sankey_intent_response::UploadImmediately::generated_message_descriptor_data());
            messages.push(sankey_intent_response::Drop::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
