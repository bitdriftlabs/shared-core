// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/client/v1/api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ClientKillFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClientKillFile {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ClientKillFile.api_key_hash)
    pub api_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ClientKillFile.kill_until)
    pub kill_until: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ClientKillFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClientKillFile {
    fn default() -> &'a ClientKillFile {
        <ClientKillFile as ::protobuf::Message>::default_instance()
    }
}

impl ClientKillFile {
    pub fn new() -> ClientKillFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_key_hash",
            |m: &ClientKillFile| { &m.api_key_hash },
            |m: &mut ClientKillFile| { &mut m.api_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "kill_until",
            |m: &ClientKillFile| { &m.kill_until },
            |m: &mut ClientKillFile| { &mut m.kill_until },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClientKillFile>(
            "ClientKillFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClientKillFile {
    const NAME: &'static str = "ClientKillFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.api_key_hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.kill_until)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.api_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.api_key_hash);
        }
        if let Some(v) = self.kill_until.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.api_key_hash.is_empty() {
            os.write_bytes(1, &self.api_key_hash)?;
        }
        if let Some(v) = self.kill_until.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClientKillFile {
        ClientKillFile::new()
    }

    fn clear(&mut self) {
        self.api_key_hash.clear();
        self.kill_until.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClientKillFile {
        static instance: ClientKillFile = ClientKillFile {
            api_key_hash: ::std::vec::Vec::new(),
            kill_until: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClientKillFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClientKillFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClientKillFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientKillFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HandshakeRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.static_device_metadata)
    pub static_device_metadata: ::std::collections::HashMap<::std::string::String, super::payload::Data>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.configuration_version_nonce)
    pub configuration_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.runtime_version_nonce)
    pub runtime_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeRequest.opqaue_version_nonces)
    pub opqaue_version_nonces: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeRequest {
    fn default() -> &'a HandshakeRequest {
        <HandshakeRequest as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeRequest {
    pub fn new() -> HandshakeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "static_device_metadata",
            |m: &HandshakeRequest| { &m.static_device_metadata },
            |m: &mut HandshakeRequest| { &mut m.static_device_metadata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "configuration_version_nonce",
            |m: &HandshakeRequest| { &m.configuration_version_nonce },
            |m: &mut HandshakeRequest| { &mut m.configuration_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runtime_version_nonce",
            |m: &HandshakeRequest| { &m.runtime_version_nonce },
            |m: &mut HandshakeRequest| { &mut m.runtime_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "opqaue_version_nonces",
            |m: &HandshakeRequest| { &m.opqaue_version_nonces },
            |m: &mut HandshakeRequest| { &mut m.opqaue_version_nonces },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeRequest>(
            "HandshakeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeRequest {
    const NAME: &'static str = "HandshakeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.static_device_metadata.insert(key, value);
                },
                26 => {
                    self.configuration_version_nonce = is.read_string()?;
                },
                34 => {
                    self.runtime_version_nonce = is.read_string()?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.opqaue_version_nonces.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.static_device_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.configuration_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.configuration_version_nonce);
        }
        if !self.runtime_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.runtime_version_nonce);
        }
        for (k, v) in &self.opqaue_version_nonces {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.static_device_metadata {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if !self.configuration_version_nonce.is_empty() {
            os.write_string(3, &self.configuration_version_nonce)?;
        }
        if !self.runtime_version_nonce.is_empty() {
            os.write_string(4, &self.runtime_version_nonce)?;
        }
        for (k, v) in &self.opqaue_version_nonces {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeRequest {
        HandshakeRequest::new()
    }

    fn clear(&mut self) {
        self.static_device_metadata.clear();
        self.configuration_version_nonce.clear();
        self.runtime_version_nonce.clear();
        self.opqaue_version_nonces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeRequest {
        static instance: ::protobuf::rt::Lazy<HandshakeRequest> = ::protobuf::rt::Lazy::new();
        instance.get(HandshakeRequest::new)
    }
}

impl ::protobuf::MessageFull for HandshakeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueConfigurationUpdate {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdate.version_nonce)
    pub version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdate.configuration)
    pub configuration: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueConfigurationUpdate {
    fn default() -> &'a OpaqueConfigurationUpdate {
        <OpaqueConfigurationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueConfigurationUpdate {
    pub fn new() -> OpaqueConfigurationUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_nonce",
            |m: &OpaqueConfigurationUpdate| { &m.version_nonce },
            |m: &mut OpaqueConfigurationUpdate| { &mut m.version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "configuration",
            |m: &OpaqueConfigurationUpdate| { &m.configuration },
            |m: &mut OpaqueConfigurationUpdate| { &mut m.configuration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueConfigurationUpdate>(
            "OpaqueConfigurationUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueConfigurationUpdate {
    const NAME: &'static str = "OpaqueConfigurationUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_nonce = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.configuration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
        }
        if let Some(v) = self.configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_nonce.is_empty() {
            os.write_string(1, &self.version_nonce)?;
        }
        if let Some(v) = self.configuration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueConfigurationUpdate {
        OpaqueConfigurationUpdate::new()
    }

    fn clear(&mut self) {
        self.version_nonce.clear();
        self.configuration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueConfigurationUpdate {
        static instance: OpaqueConfigurationUpdate = OpaqueConfigurationUpdate {
            version_nonce: ::std::string::String::new(),
            configuration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueConfigurationUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueConfigurationUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueConfigurationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueConfigurationUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdateAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueConfigurationUpdateAck {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdateAck.type_url)
    pub type_url: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdateAck.ack)
    pub ack: ::protobuf::MessageField<ConfigurationUpdateAck>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdateAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueConfigurationUpdateAck {
    fn default() -> &'a OpaqueConfigurationUpdateAck {
        <OpaqueConfigurationUpdateAck as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueConfigurationUpdateAck {
    pub fn new() -> OpaqueConfigurationUpdateAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_url",
            |m: &OpaqueConfigurationUpdateAck| { &m.type_url },
            |m: &mut OpaqueConfigurationUpdateAck| { &mut m.type_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ConfigurationUpdateAck>(
            "ack",
            |m: &OpaqueConfigurationUpdateAck| { &m.ack },
            |m: &mut OpaqueConfigurationUpdateAck| { &mut m.ack },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueConfigurationUpdateAck>(
            "OpaqueConfigurationUpdateAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueConfigurationUpdateAck {
    const NAME: &'static str = "OpaqueConfigurationUpdateAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_url = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ack)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_url);
        }
        if let Some(v) = self.ack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_url.is_empty() {
            os.write_string(1, &self.type_url)?;
        }
        if let Some(v) = self.ack.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueConfigurationUpdateAck {
        OpaqueConfigurationUpdateAck::new()
    }

    fn clear(&mut self) {
        self.type_url.clear();
        self.ack.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueConfigurationUpdateAck {
        static instance: OpaqueConfigurationUpdateAck = OpaqueConfigurationUpdateAck {
            type_url: ::std::string::String::new(),
            ack: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueConfigurationUpdateAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueConfigurationUpdateAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueConfigurationUpdateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueConfigurationUpdateAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadIntentRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.log_count)
    pub log_count: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.byte_count)
    pub byte_count: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.buffer_id)
    pub buffer_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // message oneof groups
    pub intent_type: ::std::option::Option<log_upload_intent_request::Intent_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadIntentRequest {
    fn default() -> &'a LogUploadIntentRequest {
        <LogUploadIntentRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadIntentRequest {
    pub fn new() -> LogUploadIntentRequest {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload workflow_action_upload = 5;

    pub fn workflow_action_upload(&self) -> &log_upload_intent_request::WorkflowActionUpload {
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v)) => v,
            _ => <log_upload_intent_request::WorkflowActionUpload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_workflow_action_upload(&mut self) {
        self.intent_type = ::std::option::Option::None;
    }

    pub fn has_workflow_action_upload(&self) -> bool {
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_workflow_action_upload(&mut self, v: log_upload_intent_request::WorkflowActionUpload) {
        self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_workflow_action_upload(&mut self) -> &mut log_upload_intent_request::WorkflowActionUpload {
        if let ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(_)) = self.intent_type {
        } else {
            self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(log_upload_intent_request::WorkflowActionUpload::new()));
        }
        match self.intent_type {
            ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_workflow_action_upload(&mut self) -> log_upload_intent_request::WorkflowActionUpload {
        if self.has_workflow_action_upload() {
            match self.intent_type.take() {
                ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_request::WorkflowActionUpload::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "log_count",
            |m: &LogUploadIntentRequest| { &m.log_count },
            |m: &mut LogUploadIntentRequest| { &mut m.log_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "byte_count",
            |m: &LogUploadIntentRequest| { &m.byte_count },
            |m: &mut LogUploadIntentRequest| { &mut m.byte_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buffer_id",
            |m: &LogUploadIntentRequest| { &m.buffer_id },
            |m: &mut LogUploadIntentRequest| { &mut m.buffer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &LogUploadIntentRequest| { &m.intent_uuid },
            |m: &mut LogUploadIntentRequest| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_request::WorkflowActionUpload>(
            "workflow_action_upload",
            LogUploadIntentRequest::has_workflow_action_upload,
            LogUploadIntentRequest::workflow_action_upload,
            LogUploadIntentRequest::mut_workflow_action_upload,
            LogUploadIntentRequest::set_workflow_action_upload,
        ));
        oneofs.push(log_upload_intent_request::Intent_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadIntentRequest>(
            "LogUploadIntentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadIntentRequest {
    const NAME: &'static str = "LogUploadIntentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.log_count = is.read_uint32()?;
                },
                16 => {
                    self.byte_count = is.read_uint32()?;
                },
                26 => {
                    self.buffer_id = is.read_string()?;
                },
                34 => {
                    self.intent_uuid = is.read_string()?;
                },
                42 => {
                    self.intent_type = ::std::option::Option::Some(log_upload_intent_request::Intent_type::WorkflowActionUpload(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.log_count != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.log_count);
        }
        if self.byte_count != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.byte_count);
        }
        if !self.buffer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.buffer_id);
        }
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.intent_uuid);
        }
        if let ::std::option::Option::Some(ref v) = self.intent_type {
            match v {
                &log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.log_count != 0 {
            os.write_uint32(1, self.log_count)?;
        }
        if self.byte_count != 0 {
            os.write_uint32(2, self.byte_count)?;
        }
        if !self.buffer_id.is_empty() {
            os.write_string(3, &self.buffer_id)?;
        }
        if !self.intent_uuid.is_empty() {
            os.write_string(4, &self.intent_uuid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.intent_type {
            match v {
                &log_upload_intent_request::Intent_type::WorkflowActionUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadIntentRequest {
        LogUploadIntentRequest::new()
    }

    fn clear(&mut self) {
        self.log_count = 0;
        self.byte_count = 0;
        self.buffer_id.clear();
        self.intent_uuid.clear();
        self.intent_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadIntentRequest {
        static instance: LogUploadIntentRequest = LogUploadIntentRequest {
            log_count: 0,
            byte_count: 0,
            buffer_id: ::std::string::String::new(),
            intent_uuid: ::std::string::String::new(),
            intent_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadIntentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadIntentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadIntentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadIntentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogUploadIntentRequest`
pub mod log_upload_intent_request {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.intent_type)
    pub enum Intent_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.workflow_action_upload)
        WorkflowActionUpload(WorkflowActionUpload),
    }

    impl ::protobuf::Oneof for Intent_type {
    }

    impl ::protobuf::OneofFull for Intent_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogUploadIntentRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("intent_type").unwrap()).clone()
        }
    }

    impl Intent_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Intent_type>("intent_type")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkflowActionUpload {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload.workflow_action_ids)
        pub workflow_action_ids: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUpload.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkflowActionUpload {
        fn default() -> &'a WorkflowActionUpload {
            <WorkflowActionUpload as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkflowActionUpload {
        pub fn new() -> WorkflowActionUpload {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "workflow_action_ids",
                |m: &WorkflowActionUpload| { &m.workflow_action_ids },
                |m: &mut WorkflowActionUpload| { &mut m.workflow_action_ids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowActionUpload>(
                "LogUploadIntentRequest.WorkflowActionUpload",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkflowActionUpload {
        const NAME: &'static str = "WorkflowActionUpload";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.workflow_action_ids.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.workflow_action_ids {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.workflow_action_ids {
                os.write_string(1, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkflowActionUpload {
            WorkflowActionUpload::new()
        }

        fn clear(&mut self) {
            self.workflow_action_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkflowActionUpload {
            static instance: WorkflowActionUpload = WorkflowActionUpload {
                workflow_action_ids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkflowActionUpload {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentRequest.WorkflowActionUpload").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkflowActionUpload {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkflowActionUpload {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadIntentResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // message oneof groups
    pub decision: ::std::option::Option<log_upload_intent_response::Decision>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadIntentResponse {
    fn default() -> &'a LogUploadIntentResponse {
        <LogUploadIntentResponse as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadIntentResponse {
    pub fn new() -> LogUploadIntentResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately upload_immediately = 2;

    pub fn upload_immediately(&self) -> &log_upload_intent_response::UploadImmediately {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(ref v)) => v,
            _ => <log_upload_intent_response::UploadImmediately as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_upload_immediately(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_upload_immediately(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_upload_immediately(&mut self, v: log_upload_intent_response::UploadImmediately) {
        self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(v))
    }

    // Mutable pointer to the field.
    pub fn mut_upload_immediately(&mut self) -> &mut log_upload_intent_response::UploadImmediately {
        if let ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(log_upload_intent_response::UploadImmediately::new()));
        }
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_upload_immediately(&mut self) -> log_upload_intent_response::UploadImmediately {
        if self.has_upload_immediately() {
            match self.decision.take() {
                ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_response::UploadImmediately::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop drop = 3;

    pub fn drop(&self) -> &log_upload_intent_response::Drop {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(ref v)) => v,
            _ => <log_upload_intent_response::Drop as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_drop(&mut self) {
        self.decision = ::std::option::Option::None;
    }

    pub fn has_drop(&self) -> bool {
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: log_upload_intent_response::Drop) {
        self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut log_upload_intent_response::Drop {
        if let ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(_)) = self.decision {
        } else {
            self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(log_upload_intent_response::Drop::new()));
        }
        match self.decision {
            ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_drop(&mut self) -> log_upload_intent_response::Drop {
        if self.has_drop() {
            match self.decision.take() {
                ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(v)) => v,
                _ => panic!(),
            }
        } else {
            log_upload_intent_response::Drop::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &LogUploadIntentResponse| { &m.intent_uuid },
            |m: &mut LogUploadIntentResponse| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_response::UploadImmediately>(
            "upload_immediately",
            LogUploadIntentResponse::has_upload_immediately,
            LogUploadIntentResponse::upload_immediately,
            LogUploadIntentResponse::mut_upload_immediately,
            LogUploadIntentResponse::set_upload_immediately,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_upload_intent_response::Drop>(
            "drop",
            LogUploadIntentResponse::has_drop,
            LogUploadIntentResponse::drop,
            LogUploadIntentResponse::mut_drop,
            LogUploadIntentResponse::set_drop,
        ));
        oneofs.push(log_upload_intent_response::Decision::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadIntentResponse>(
            "LogUploadIntentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadIntentResponse {
    const NAME: &'static str = "LogUploadIntentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                18 => {
                    self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::UploadImmediately(is.read_message()?));
                },
                26 => {
                    self.decision = ::std::option::Option::Some(log_upload_intent_response::Decision::Drop(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &log_upload_intent_response::Decision::UploadImmediately(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_upload_intent_response::Decision::Drop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if let ::std::option::Option::Some(ref v) = self.decision {
            match v {
                &log_upload_intent_response::Decision::UploadImmediately(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &log_upload_intent_response::Decision::Drop(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadIntentResponse {
        LogUploadIntentResponse::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.decision = ::std::option::Option::None;
        self.decision = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadIntentResponse {
        static instance: LogUploadIntentResponse = LogUploadIntentResponse {
            intent_uuid: ::std::string::String::new(),
            decision: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadIntentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadIntentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadIntentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadIntentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogUploadIntentResponse`
pub mod log_upload_intent_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.decision)
    pub enum Decision {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.upload_immediately)
        UploadImmediately(UploadImmediately),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.drop)
        Drop(Drop),
    }

    impl ::protobuf::Oneof for Decision {
    }

    impl ::protobuf::OneofFull for Decision {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogUploadIntentResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("decision").unwrap()).clone()
        }
    }

    impl Decision {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Decision>("decision")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UploadImmediately {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.UploadImmediately.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UploadImmediately {
        fn default() -> &'a UploadImmediately {
            <UploadImmediately as ::protobuf::Message>::default_instance()
        }
    }

    impl UploadImmediately {
        pub fn new() -> UploadImmediately {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UploadImmediately>(
                "LogUploadIntentResponse.UploadImmediately",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UploadImmediately {
        const NAME: &'static str = "UploadImmediately";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UploadImmediately {
            UploadImmediately::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UploadImmediately {
            static instance: UploadImmediately = UploadImmediately {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UploadImmediately {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentResponse.UploadImmediately").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UploadImmediately {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UploadImmediately {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Drop {
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.Drop.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Drop {
        fn default() -> &'a Drop {
            <Drop as ::protobuf::Message>::default_instance()
        }
    }

    impl Drop {
        pub fn new() -> Drop {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Drop>(
                "LogUploadIntentResponse.Drop",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Drop {
        const NAME: &'static str = "Drop";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Drop {
            Drop::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Drop {
            static instance: Drop = Drop {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Drop {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogUploadIntentResponse.Drop").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Drop {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Drop {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.logs)
    pub logs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadRequest.buffer_uuid)
    pub buffer_uuid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadRequest {
    fn default() -> &'a LogUploadRequest {
        <LogUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadRequest {
    pub fn new() -> LogUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &LogUploadRequest| { &m.upload_uuid },
            |m: &mut LogUploadRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logs",
            |m: &LogUploadRequest| { &m.logs },
            |m: &mut LogUploadRequest| { &mut m.logs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buffer_uuid",
            |m: &LogUploadRequest| { &m.buffer_uuid },
            |m: &mut LogUploadRequest| { &mut m.buffer_uuid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadRequest>(
            "LogUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadRequest {
    const NAME: &'static str = "LogUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.logs.push(is.read_bytes()?);
                },
                26 => {
                    self.buffer_uuid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        for value in &self.logs {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if !self.buffer_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.buffer_uuid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        for v in &self.logs {
            os.write_bytes(2, &v)?;
        };
        if !self.buffer_uuid.is_empty() {
            os.write_string(3, &self.buffer_uuid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadRequest {
        LogUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.logs.clear();
        self.buffer_uuid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadRequest {
        static instance: LogUploadRequest = LogUploadRequest {
            upload_uuid: ::std::string::String::new(),
            logs: ::std::vec::Vec::new(),
            buffer_uuid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.PingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigurationUpdateAck {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.last_applied_version_nonce)
    pub last_applied_version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.nack)
    pub nack: ::protobuf::MessageField<configuration_update_ack::Nack>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigurationUpdateAck {
    fn default() -> &'a ConfigurationUpdateAck {
        <ConfigurationUpdateAck as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationUpdateAck {
    pub fn new() -> ConfigurationUpdateAck {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_applied_version_nonce",
            |m: &ConfigurationUpdateAck| { &m.last_applied_version_nonce },
            |m: &mut ConfigurationUpdateAck| { &mut m.last_applied_version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, configuration_update_ack::Nack>(
            "nack",
            |m: &ConfigurationUpdateAck| { &m.nack },
            |m: &mut ConfigurationUpdateAck| { &mut m.nack },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationUpdateAck>(
            "ConfigurationUpdateAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigurationUpdateAck {
    const NAME: &'static str = "ConfigurationUpdateAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.last_applied_version_nonce = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.nack)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.last_applied_version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.last_applied_version_nonce);
        }
        if let Some(v) = self.nack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.last_applied_version_nonce.is_empty() {
            os.write_string(1, &self.last_applied_version_nonce)?;
        }
        if let Some(v) = self.nack.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigurationUpdateAck {
        ConfigurationUpdateAck::new()
    }

    fn clear(&mut self) {
        self.last_applied_version_nonce.clear();
        self.nack.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigurationUpdateAck {
        static instance: ConfigurationUpdateAck = ConfigurationUpdateAck {
            last_applied_version_nonce: ::std::string::String::new(),
            nack: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigurationUpdateAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigurationUpdateAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigurationUpdateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationUpdateAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigurationUpdateAck`
pub mod configuration_update_ack {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Nack {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.version_nonce)
        pub version_nonce: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.error_details)
        pub error_details: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck.Nack.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Nack {
        fn default() -> &'a Nack {
            <Nack as ::protobuf::Message>::default_instance()
        }
    }

    impl Nack {
        pub fn new() -> Nack {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "version_nonce",
                |m: &Nack| { &m.version_nonce },
                |m: &mut Nack| { &mut m.version_nonce },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "error_details",
                |m: &Nack| { &m.error_details },
                |m: &mut Nack| { &mut m.error_details },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Nack>(
                "ConfigurationUpdateAck.Nack",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Nack {
        const NAME: &'static str = "Nack";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.version_nonce = is.read_string()?;
                    },
                    18 => {
                        self.error_details = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.version_nonce.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
            }
            if !self.error_details.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.error_details);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.version_nonce.is_empty() {
                os.write_string(1, &self.version_nonce)?;
            }
            if !self.error_details.is_empty() {
                os.write_string(2, &self.error_details)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Nack {
            Nack::new()
        }

        fn clear(&mut self) {
            self.version_nonce.clear();
            self.error_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Nack {
            static instance: Nack = Nack {
                version_nonce: ::std::string::String::new(),
                error_details: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Nack {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConfigurationUpdateAck.Nack").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Nack {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Nack {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ApiRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApiRequest {
    // message oneof groups
    pub request_type: ::std::option::Option<api_request::Request_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ApiRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiRequest {
    fn default() -> &'a ApiRequest {
        <ApiRequest as ::protobuf::Message>::default_instance()
    }
}

impl ApiRequest {
    pub fn new() -> ApiRequest {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.HandshakeRequest handshake = 1;

    pub fn handshake(&self) -> &HandshakeRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(ref v)) => v,
            _ => <HandshakeRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_handshake(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_handshake(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake(&mut self, v: HandshakeRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake(&mut self) -> &mut HandshakeRequest {
        if let ::std::option::Option::Some(api_request::Request_type::Handshake(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(HandshakeRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake(&mut self) -> HandshakeRequest {
        if self.has_handshake() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentRequest log_upload_intent = 7;

    pub fn log_upload_intent(&self) -> &LogUploadIntentRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(ref v)) => v,
            _ => <LogUploadIntentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload_intent(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_log_upload_intent(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload_intent(&mut self, v: LogUploadIntentRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload_intent(&mut self) -> &mut LogUploadIntentRequest {
        if let ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(LogUploadIntentRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload_intent(&mut self) -> LogUploadIntentRequest {
        if self.has_log_upload_intent() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadIntentRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadRequest log_upload = 2;

    pub fn log_upload(&self) -> &LogUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(ref v)) => v,
            _ => <LogUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_log_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload(&mut self, v: LogUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload(&mut self) -> &mut LogUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::LogUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(LogUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::LogUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload(&mut self) -> LogUploadRequest {
        if self.has_log_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::LogUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.StatsUploadRequest stats_upload = 6;

    pub fn stats_upload(&self) -> &StatsUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(ref v)) => v,
            _ => <StatsUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stats_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_stats_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stats_upload(&mut self, v: StatsUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stats_upload(&mut self) -> &mut StatsUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::StatsUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(StatsUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::StatsUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stats_upload(&mut self) -> StatsUploadRequest {
        if self.has_stats_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::StatsUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            StatsUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.PingRequest ping = 3;

    pub fn ping(&self) -> &PingRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(ref v)) => v,
            _ => <PingRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: PingRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut PingRequest {
        if let ::std::option::Option::Some(api_request::Request_type::Ping(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(PingRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::Ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> PingRequest {
        if self.has_ping() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::Ping(v)) => v,
                _ => panic!(),
            }
        } else {
            PingRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck configuration_update_ack = 4;

    pub fn configuration_update_ack(&self) -> &ConfigurationUpdateAck {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ref v)) => v,
            _ => <ConfigurationUpdateAck as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_configuration_update_ack(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_configuration_update_ack(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_configuration_update_ack(&mut self, v: ConfigurationUpdateAck) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_configuration_update_ack(&mut self) -> &mut ConfigurationUpdateAck {
        if let ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ConfigurationUpdateAck::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_configuration_update_ack(&mut self) -> ConfigurationUpdateAck {
        if self.has_configuration_update_ack() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdateAck::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdateAck runtime_update_ack = 5;

    pub fn runtime_update_ack(&self) -> &ConfigurationUpdateAck {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ref v)) => v,
            _ => <ConfigurationUpdateAck as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_runtime_update_ack(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_runtime_update_ack(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_update_ack(&mut self, v: ConfigurationUpdateAck) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_update_ack(&mut self) -> &mut ConfigurationUpdateAck {
        if let ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ConfigurationUpdateAck::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_update_ack(&mut self) -> ConfigurationUpdateAck {
        if self.has_runtime_update_ack() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdateAck::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdateAck opaque_configuration_update_ack = 8;

    pub fn opaque_configuration_update_ack(&self) -> &OpaqueConfigurationUpdateAck {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(ref v)) => v,
            _ => <OpaqueConfigurationUpdateAck as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_opaque_configuration_update_ack(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_opaque_configuration_update_ack(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opaque_configuration_update_ack(&mut self, v: OpaqueConfigurationUpdateAck) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opaque_configuration_update_ack(&mut self) -> &mut OpaqueConfigurationUpdateAck {
        if let ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(OpaqueConfigurationUpdateAck::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opaque_configuration_update_ack(&mut self) -> OpaqueConfigurationUpdateAck {
        if self.has_opaque_configuration_update_ack() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(v)) => v,
                _ => panic!(),
            }
        } else {
            OpaqueConfigurationUpdateAck::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.OpaqueRequest opaque_upload = 9;

    pub fn opaque_upload(&self) -> &OpaqueRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(ref v)) => v,
            _ => <OpaqueRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_opaque_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_opaque_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opaque_upload(&mut self, v: OpaqueRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opaque_upload(&mut self) -> &mut OpaqueRequest {
        if let ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(OpaqueRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opaque_upload(&mut self) -> OpaqueRequest {
        if self.has_opaque_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            OpaqueRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest sankey_diagram_upload = 10;

    pub fn sankey_diagram_upload(&self) -> &SankeyDiagramUploadRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(ref v)) => v,
            _ => <SankeyDiagramUploadRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_diagram_upload(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_sankey_diagram_upload(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_diagram_upload(&mut self, v: SankeyDiagramUploadRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_diagram_upload(&mut self) -> &mut SankeyDiagramUploadRequest {
        if let ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(SankeyDiagramUploadRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_diagram_upload(&mut self) -> SankeyDiagramUploadRequest {
        if self.has_sankey_diagram_upload() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyDiagramUploadRequest::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentRequest sankey_intent = 11;

    pub fn sankey_intent(&self) -> &SankeyIntentRequest {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(ref v)) => v,
            _ => <SankeyIntentRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_intent(&mut self) {
        self.request_type = ::std::option::Option::None;
    }

    pub fn has_sankey_intent(&self) -> bool {
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_intent(&mut self, v: SankeyIntentRequest) {
        self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_intent(&mut self) -> &mut SankeyIntentRequest {
        if let ::std::option::Option::Some(api_request::Request_type::SankeyIntent(_)) = self.request_type {
        } else {
            self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(SankeyIntentRequest::new()));
        }
        match self.request_type {
            ::std::option::Option::Some(api_request::Request_type::SankeyIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_intent(&mut self) -> SankeyIntentRequest {
        if self.has_sankey_intent() {
            match self.request_type.take() {
                ::std::option::Option::Some(api_request::Request_type::SankeyIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyIntentRequest::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HandshakeRequest>(
            "handshake",
            ApiRequest::has_handshake,
            ApiRequest::handshake,
            ApiRequest::mut_handshake,
            ApiRequest::set_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadIntentRequest>(
            "log_upload_intent",
            ApiRequest::has_log_upload_intent,
            ApiRequest::log_upload_intent,
            ApiRequest::mut_log_upload_intent,
            ApiRequest::set_log_upload_intent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadRequest>(
            "log_upload",
            ApiRequest::has_log_upload,
            ApiRequest::log_upload,
            ApiRequest::mut_log_upload,
            ApiRequest::set_log_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatsUploadRequest>(
            "stats_upload",
            ApiRequest::has_stats_upload,
            ApiRequest::stats_upload,
            ApiRequest::mut_stats_upload,
            ApiRequest::set_stats_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PingRequest>(
            "ping",
            ApiRequest::has_ping,
            ApiRequest::ping,
            ApiRequest::mut_ping,
            ApiRequest::set_ping,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdateAck>(
            "configuration_update_ack",
            ApiRequest::has_configuration_update_ack,
            ApiRequest::configuration_update_ack,
            ApiRequest::mut_configuration_update_ack,
            ApiRequest::set_configuration_update_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdateAck>(
            "runtime_update_ack",
            ApiRequest::has_runtime_update_ack,
            ApiRequest::runtime_update_ack,
            ApiRequest::mut_runtime_update_ack,
            ApiRequest::set_runtime_update_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OpaqueConfigurationUpdateAck>(
            "opaque_configuration_update_ack",
            ApiRequest::has_opaque_configuration_update_ack,
            ApiRequest::opaque_configuration_update_ack,
            ApiRequest::mut_opaque_configuration_update_ack,
            ApiRequest::set_opaque_configuration_update_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OpaqueRequest>(
            "opaque_upload",
            ApiRequest::has_opaque_upload,
            ApiRequest::opaque_upload,
            ApiRequest::mut_opaque_upload,
            ApiRequest::set_opaque_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyDiagramUploadRequest>(
            "sankey_diagram_upload",
            ApiRequest::has_sankey_diagram_upload,
            ApiRequest::sankey_diagram_upload,
            ApiRequest::mut_sankey_diagram_upload,
            ApiRequest::set_sankey_diagram_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyIntentRequest>(
            "sankey_intent",
            ApiRequest::has_sankey_intent,
            ApiRequest::sankey_intent,
            ApiRequest::mut_sankey_intent,
            ApiRequest::set_sankey_intent,
        ));
        oneofs.push(api_request::Request_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiRequest>(
            "ApiRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiRequest {
    const NAME: &'static str = "ApiRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::Handshake(is.read_message()?));
                },
                58 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUploadIntent(is.read_message()?));
                },
                18 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::LogUpload(is.read_message()?));
                },
                50 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::StatsUpload(is.read_message()?));
                },
                26 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::Ping(is.read_message()?));
                },
                34 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::ConfigurationUpdateAck(is.read_message()?));
                },
                42 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::RuntimeUpdateAck(is.read_message()?));
                },
                66 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueConfigurationUpdateAck(is.read_message()?));
                },
                74 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::OpaqueUpload(is.read_message()?));
                },
                82 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyDiagramUpload(is.read_message()?));
                },
                90 => {
                    self.request_type = ::std::option::Option::Some(api_request::Request_type::SankeyIntent(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request_type {
            match v {
                &api_request::Request_type::Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::LogUploadIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::LogUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::StatsUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::Ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::ConfigurationUpdateAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::RuntimeUpdateAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::OpaqueConfigurationUpdateAck(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::OpaqueUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::SankeyDiagramUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_request::Request_type::SankeyIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.request_type {
            match v {
                &api_request::Request_type::Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &api_request::Request_type::LogUploadIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &api_request::Request_type::LogUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &api_request::Request_type::StatsUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &api_request::Request_type::Ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &api_request::Request_type::ConfigurationUpdateAck(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &api_request::Request_type::RuntimeUpdateAck(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &api_request::Request_type::OpaqueConfigurationUpdateAck(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &api_request::Request_type::OpaqueUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &api_request::Request_type::SankeyDiagramUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &api_request::Request_type::SankeyIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiRequest {
        ApiRequest::new()
    }

    fn clear(&mut self) {
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.request_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiRequest {
        static instance: ApiRequest = ApiRequest {
            request_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApiRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ApiRequest`
pub mod api_request {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ApiRequest.request_type)
    pub enum Request_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.handshake)
        Handshake(super::HandshakeRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.log_upload_intent)
        LogUploadIntent(super::LogUploadIntentRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.log_upload)
        LogUpload(super::LogUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.stats_upload)
        StatsUpload(super::StatsUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.ping)
        Ping(super::PingRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.configuration_update_ack)
        ConfigurationUpdateAck(super::ConfigurationUpdateAck),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.runtime_update_ack)
        RuntimeUpdateAck(super::ConfigurationUpdateAck),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.opaque_configuration_update_ack)
        OpaqueConfigurationUpdateAck(super::OpaqueConfigurationUpdateAck),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.opaque_upload)
        OpaqueUpload(super::OpaqueRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.sankey_diagram_upload)
        SankeyDiagramUpload(super::SankeyDiagramUploadRequest),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiRequest.sankey_intent)
        SankeyIntent(super::SankeyIntentRequest),
    }

    impl ::protobuf::Oneof for Request_type {
    }

    impl ::protobuf::OneofFull for Request_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ApiRequest as ::protobuf::MessageFull>::descriptor().oneof_by_name("request_type").unwrap()).clone()
        }
    }

    impl Request_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Request_type>("request_type")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyDiagramUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.path_id)
    pub path_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.nodes)
    pub nodes: ::std::vec::Vec<sankey_diagram_upload_request::Node>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyDiagramUploadRequest {
    fn default() -> &'a SankeyDiagramUploadRequest {
        <SankeyDiagramUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl SankeyDiagramUploadRequest {
    pub fn new() -> SankeyDiagramUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &SankeyDiagramUploadRequest| { &m.id },
            |m: &mut SankeyDiagramUploadRequest| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_id",
            |m: &SankeyDiagramUploadRequest| { &m.path_id },
            |m: &mut SankeyDiagramUploadRequest| { &mut m.path_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nodes",
            |m: &SankeyDiagramUploadRequest| { &m.nodes },
            |m: &mut SankeyDiagramUploadRequest| { &mut m.nodes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyDiagramUploadRequest>(
            "SankeyDiagramUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyDiagramUploadRequest {
    const NAME: &'static str = "SankeyDiagramUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.path_id = is.read_string()?;
                },
                26 => {
                    self.nodes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.path_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_id);
        }
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.path_id.is_empty() {
            os.write_string(2, &self.path_id)?;
        }
        for v in &self.nodes {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyDiagramUploadRequest {
        SankeyDiagramUploadRequest::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.path_id.clear();
        self.nodes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyDiagramUploadRequest {
        static instance: SankeyDiagramUploadRequest = SankeyDiagramUploadRequest {
            id: ::std::string::String::new(),
            path_id: ::std::string::String::new(),
            nodes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyDiagramUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyDiagramUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyDiagramUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyDiagramUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SankeyDiagramUploadRequest`
pub mod sankey_diagram_upload_request {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.Node)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Node {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.Node.extracted_value)
        pub extracted_value: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRequest.Node.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Node {
        fn default() -> &'a Node {
            <Node as ::protobuf::Message>::default_instance()
        }
    }

    impl Node {
        pub fn new() -> Node {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "extracted_value",
                |m: &Node| { &m.extracted_value },
                |m: &mut Node| { &mut m.extracted_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Node>(
                "SankeyDiagramUploadRequest.Node",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Node {
        const NAME: &'static str = "Node";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.extracted_value = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.extracted_value.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.extracted_value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.extracted_value.is_empty() {
                os.write_string(1, &self.extracted_value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Node {
            Node::new()
        }

        fn clear(&mut self) {
            self.extracted_value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Node {
            static instance: Node = Node {
                extracted_value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Node {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SankeyDiagramUploadRequest.Node").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Node {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Node {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyIntentRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.path_id)
    pub path_id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.sankey_diagram_id)
    pub sankey_diagram_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyIntentRequest {
    fn default() -> &'a SankeyIntentRequest {
        <SankeyIntentRequest as ::protobuf::Message>::default_instance()
    }
}

impl SankeyIntentRequest {
    pub fn new() -> SankeyIntentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &SankeyIntentRequest| { &m.intent_uuid },
            |m: &mut SankeyIntentRequest| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_id",
            |m: &SankeyIntentRequest| { &m.path_id },
            |m: &mut SankeyIntentRequest| { &mut m.path_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sankey_diagram_id",
            |m: &SankeyIntentRequest| { &m.sankey_diagram_id },
            |m: &mut SankeyIntentRequest| { &mut m.sankey_diagram_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyIntentRequest>(
            "SankeyIntentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyIntentRequest {
    const NAME: &'static str = "SankeyIntentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                18 => {
                    self.path_id = is.read_string()?;
                },
                26 => {
                    self.sankey_diagram_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if !self.path_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_id);
        }
        if !self.sankey_diagram_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sankey_diagram_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if !self.path_id.is_empty() {
            os.write_string(2, &self.path_id)?;
        }
        if !self.sankey_diagram_id.is_empty() {
            os.write_string(3, &self.sankey_diagram_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyIntentRequest {
        SankeyIntentRequest::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.path_id.clear();
        self.sankey_diagram_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyIntentRequest {
        static instance: SankeyIntentRequest = SankeyIntentRequest {
            intent_uuid: ::std::string::String::new(),
            path_id: ::std::string::String::new(),
            sankey_diagram_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyIntentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyIntentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyIntentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyIntentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HandshakeResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeResponse.stream_settings)
    pub stream_settings: ::protobuf::MessageField<handshake_response::StreamSettings>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HandshakeResponse {
    fn default() -> &'a HandshakeResponse {
        <HandshakeResponse as ::protobuf::Message>::default_instance()
    }
}

impl HandshakeResponse {
    pub fn new() -> HandshakeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, handshake_response::StreamSettings>(
            "stream_settings",
            |m: &HandshakeResponse| { &m.stream_settings },
            |m: &mut HandshakeResponse| { &mut m.stream_settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HandshakeResponse>(
            "HandshakeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HandshakeResponse {
    const NAME: &'static str = "HandshakeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stream_settings)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stream_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HandshakeResponse {
        HandshakeResponse::new()
    }

    fn clear(&mut self) {
        self.stream_settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HandshakeResponse {
        static instance: HandshakeResponse = HandshakeResponse {
            stream_settings: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HandshakeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HandshakeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HandshakeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HandshakeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HandshakeResponse`
pub mod handshake_response {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StreamSettings {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings.ping_interval)
        pub ping_interval: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamSettings.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StreamSettings {
        fn default() -> &'a StreamSettings {
            <StreamSettings as ::protobuf::Message>::default_instance()
        }
    }

    impl StreamSettings {
        pub fn new() -> StreamSettings {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
                "ping_interval",
                |m: &StreamSettings| { &m.ping_interval },
                |m: &mut StreamSettings| { &mut m.ping_interval },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamSettings>(
                "HandshakeResponse.StreamSettings",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StreamSettings {
        const NAME: &'static str = "StreamSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_interval)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ping_interval.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ping_interval.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StreamSettings {
            StreamSettings::new()
        }

        fn clear(&mut self) {
            self.ping_interval.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StreamSettings {
            static instance: StreamSettings = StreamSettings {
                ping_interval: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StreamSettings {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HandshakeResponse.StreamSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StreamSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StreamSettings {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.RateLimited)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RateLimited {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.RateLimited.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RateLimited {
    fn default() -> &'a RateLimited {
        <RateLimited as ::protobuf::Message>::default_instance()
    }
}

impl RateLimited {
    pub fn new() -> RateLimited {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RateLimited>(
            "RateLimited",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RateLimited {
    const NAME: &'static str = "RateLimited";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RateLimited {
        RateLimited::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RateLimited {
        static instance: RateLimited = RateLimited {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RateLimited {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RateLimited").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RateLimited {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimited {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.LogUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.logs_dropped)
    pub logs_dropped: u32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.LogUploadResponse.rate_limited)
    pub rate_limited: ::protobuf::MessageField<RateLimited>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.LogUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogUploadResponse {
    fn default() -> &'a LogUploadResponse {
        <LogUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl LogUploadResponse {
    pub fn new() -> LogUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &LogUploadResponse| { &m.upload_uuid },
            |m: &mut LogUploadResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &LogUploadResponse| { &m.error },
            |m: &mut LogUploadResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logs_dropped",
            |m: &LogUploadResponse| { &m.logs_dropped },
            |m: &mut LogUploadResponse| { &mut m.logs_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RateLimited>(
            "rate_limited",
            |m: &LogUploadResponse| { &m.rate_limited },
            |m: &mut LogUploadResponse| { &mut m.rate_limited },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogUploadResponse>(
            "LogUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogUploadResponse {
    const NAME: &'static str = "LogUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.logs_dropped = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rate_limited)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.logs_dropped != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.logs_dropped);
        }
        if let Some(v) = self.rate_limited.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.logs_dropped != 0 {
            os.write_uint32(3, self.logs_dropped)?;
        }
        if let Some(v) = self.rate_limited.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogUploadResponse {
        LogUploadResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.logs_dropped = 0;
        self.rate_limited.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogUploadResponse {
        static instance: LogUploadResponse = LogUploadResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            logs_dropped: 0,
            rate_limited: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatsUploadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.snapshot)
    pub snapshot: ::std::vec::Vec<stats_upload_request::Snapshot>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.sent_at)
    pub sent_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsUploadRequest {
    fn default() -> &'a StatsUploadRequest {
        <StatsUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatsUploadRequest {
    pub fn new() -> StatsUploadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &StatsUploadRequest| { &m.upload_uuid },
            |m: &mut StatsUploadRequest| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot",
            |m: &StatsUploadRequest| { &m.snapshot },
            |m: &mut StatsUploadRequest| { &mut m.snapshot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "sent_at",
            |m: &StatsUploadRequest| { &m.sent_at },
            |m: &mut StatsUploadRequest| { &mut m.sent_at },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsUploadRequest>(
            "StatsUploadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsUploadRequest {
    const NAME: &'static str = "StatsUploadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.snapshot.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sent_at)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        for value in &self.snapshot {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.sent_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        for v in &self.snapshot {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.sent_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsUploadRequest {
        StatsUploadRequest::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.snapshot.clear();
        self.sent_at.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsUploadRequest {
        static instance: StatsUploadRequest = StatsUploadRequest {
            upload_uuid: ::std::string::String::new(),
            snapshot: ::std::vec::Vec::new(),
            sent_at: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsUploadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsUploadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsUploadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StatsUploadRequest`
pub mod stats_upload_request {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Snapshot {
        // message oneof groups
        pub snapshot_type: ::std::option::Option<snapshot::Snapshot_type>,
        pub occurred_at: ::std::option::Option<snapshot::Occurred_at>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Snapshot {
        fn default() -> &'a Snapshot {
            <Snapshot as ::protobuf::Message>::default_instance()
        }
    }

    impl Snapshot {
        pub fn new() -> Snapshot {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.client.v1.MetricsList metrics = 1;

        pub fn metrics(&self) -> &super::super::metric::MetricsList {
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(ref v)) => v,
                _ => <super::super::metric::MetricsList as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_metrics(&mut self) {
            self.snapshot_type = ::std::option::Option::None;
        }

        pub fn has_metrics(&self) -> bool {
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_metrics(&mut self, v: super::super::metric::MetricsList) {
            self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(v))
        }

        // Mutable pointer to the field.
        pub fn mut_metrics(&mut self) -> &mut super::super::metric::MetricsList {
            if let ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(_)) = self.snapshot_type {
            } else {
                self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(super::super::metric::MetricsList::new()));
            }
            match self.snapshot_type {
                ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_metrics(&mut self) -> super::super::metric::MetricsList {
            if self.has_metrics() {
                match self.snapshot_type.take() {
                    ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(v)) => v,
                    _ => panic!(),
                }
            } else {
                super::super::metric::MetricsList::new()
            }
        }

        // .bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated aggregated = 2;

        pub fn aggregated(&self) -> &snapshot::Aggregated {
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(ref v)) => v,
                _ => <snapshot::Aggregated as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_aggregated(&mut self) {
            self.occurred_at = ::std::option::Option::None;
        }

        pub fn has_aggregated(&self) -> bool {
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_aggregated(&mut self, v: snapshot::Aggregated) {
            self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(v))
        }

        // Mutable pointer to the field.
        pub fn mut_aggregated(&mut self) -> &mut snapshot::Aggregated {
            if let ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(_)) = self.occurred_at {
            } else {
                self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(snapshot::Aggregated::new()));
            }
            match self.occurred_at {
                ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_aggregated(&mut self) -> snapshot::Aggregated {
            if self.has_aggregated() {
                match self.occurred_at.take() {
                    ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(v)) => v,
                    _ => panic!(),
                }
            } else {
                snapshot::Aggregated::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(2);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::metric::MetricsList>(
                "metrics",
                Snapshot::has_metrics,
                Snapshot::metrics,
                Snapshot::mut_metrics,
                Snapshot::set_metrics,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, snapshot::Aggregated>(
                "aggregated",
                Snapshot::has_aggregated,
                Snapshot::aggregated,
                Snapshot::mut_aggregated,
                Snapshot::set_aggregated,
            ));
            oneofs.push(snapshot::Snapshot_type::generated_oneof_descriptor_data());
            oneofs.push(snapshot::Occurred_at::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Snapshot>(
                "StatsUploadRequest.Snapshot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Snapshot {
        const NAME: &'static str = "Snapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.snapshot_type = ::std::option::Option::Some(snapshot::Snapshot_type::Metrics(is.read_message()?));
                    },
                    18 => {
                        self.occurred_at = ::std::option::Option::Some(snapshot::Occurred_at::Aggregated(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.snapshot_type {
                match v {
                    &snapshot::Snapshot_type::Metrics(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            if let ::std::option::Option::Some(ref v) = self.occurred_at {
                match v {
                    &snapshot::Occurred_at::Aggregated(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.snapshot_type {
                match v {
                    &snapshot::Snapshot_type::Metrics(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                };
            }
            if let ::std::option::Option::Some(ref v) = self.occurred_at {
                match v {
                    &snapshot::Occurred_at::Aggregated(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Snapshot {
            Snapshot::new()
        }

        fn clear(&mut self) {
            self.snapshot_type = ::std::option::Option::None;
            self.occurred_at = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Snapshot {
            static instance: Snapshot = Snapshot {
                snapshot_type: ::std::option::Option::None,
                occurred_at: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Snapshot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StatsUploadRequest.Snapshot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Snapshot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Snapshot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Snapshot`
    pub mod snapshot {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.snapshot_type)
        pub enum Snapshot_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.metrics)
            Metrics(super::super::super::metric::MetricsList),
        }

        impl ::protobuf::Oneof for Snapshot_type {
        }

        impl ::protobuf::OneofFull for Snapshot_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Snapshot as ::protobuf::MessageFull>::descriptor().oneof_by_name("snapshot_type").unwrap()).clone()
            }
        }

        impl Snapshot_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Snapshot_type>("snapshot_type")
            }
        }

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.occurred_at)
        pub enum Occurred_at {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.aggregated)
            Aggregated(Aggregated),
        }

        impl ::protobuf::Oneof for Occurred_at {
        }

        impl ::protobuf::OneofFull for Occurred_at {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Snapshot as ::protobuf::MessageFull>::descriptor().oneof_by_name("occurred_at").unwrap()).clone()
            }
        }

        impl Occurred_at {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Occurred_at>("occurred_at")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Aggregated {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.period_start)
            pub period_start: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.period_end)
            pub period_end: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadRequest.Snapshot.Aggregated.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Aggregated {
            fn default() -> &'a Aggregated {
                <Aggregated as ::protobuf::Message>::default_instance()
            }
        }

        impl Aggregated {
            pub fn new() -> Aggregated {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                    "period_start",
                    |m: &Aggregated| { &m.period_start },
                    |m: &mut Aggregated| { &mut m.period_start },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
                    "period_end",
                    |m: &Aggregated| { &m.period_end },
                    |m: &mut Aggregated| { &mut m.period_end },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Aggregated>(
                    "StatsUploadRequest.Snapshot.Aggregated",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Aggregated {
            const NAME: &'static str = "Aggregated";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        34 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.period_start)?;
                        },
                        42 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.period_end)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.period_start.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.period_end.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.period_start.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                }
                if let Some(v) = self.period_end.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Aggregated {
                Aggregated::new()
            }

            fn clear(&mut self) {
                self.period_start.clear();
                self.period_end.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Aggregated {
                static instance: Aggregated = Aggregated {
                    period_start: ::protobuf::MessageField::none(),
                    period_end: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Aggregated {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StatsUploadRequest.Snapshot.Aggregated").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Aggregated {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Aggregated {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.StatsUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StatsUploadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.upload_uuid)
    pub upload_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.metrics_dropped)
    pub metrics_dropped: u32,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.StatsUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatsUploadResponse {
    fn default() -> &'a StatsUploadResponse {
        <StatsUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatsUploadResponse {
    pub fn new() -> StatsUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "upload_uuid",
            |m: &StatsUploadResponse| { &m.upload_uuid },
            |m: &mut StatsUploadResponse| { &mut m.upload_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &StatsUploadResponse| { &m.error },
            |m: &mut StatsUploadResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_dropped",
            |m: &StatsUploadResponse| { &m.metrics_dropped },
            |m: &mut StatsUploadResponse| { &mut m.metrics_dropped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatsUploadResponse>(
            "StatsUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatsUploadResponse {
    const NAME: &'static str = "StatsUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.upload_uuid = is.read_string()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                24 => {
                    self.metrics_dropped = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.upload_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upload_uuid);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if self.metrics_dropped != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.metrics_dropped);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.upload_uuid.is_empty() {
            os.write_string(1, &self.upload_uuid)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if self.metrics_dropped != 0 {
            os.write_uint32(3, self.metrics_dropped)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatsUploadResponse {
        StatsUploadResponse::new()
    }

    fn clear(&mut self) {
        self.upload_uuid.clear();
        self.error.clear();
        self.metrics_dropped = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatsUploadResponse {
        static instance: StatsUploadResponse = StatsUploadResponse {
            upload_uuid: ::std::string::String::new(),
            error: ::std::string::String::new(),
            metrics_dropped: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatsUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatsUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatsUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatsUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.OpaqueRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueRequest.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueRequest.request)
    pub request: ::protobuf::MessageField<::protobuf::well_known_types::any::Any>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.OpaqueRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueRequest {
    fn default() -> &'a OpaqueRequest {
        <OpaqueRequest as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueRequest {
    pub fn new() -> OpaqueRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &OpaqueRequest| { &m.uuid },
            |m: &mut OpaqueRequest| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::any::Any>(
            "request",
            |m: &OpaqueRequest| { &m.request },
            |m: &mut OpaqueRequest| { &mut m.request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueRequest>(
            "OpaqueRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueRequest {
    const NAME: &'static str = "OpaqueRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueRequest {
        OpaqueRequest::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueRequest {
        static instance: OpaqueRequest = OpaqueRequest {
            uuid: ::std::string::String::new(),
            request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.OpaqueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OpaqueResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueResponse.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.OpaqueResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.OpaqueResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OpaqueResponse {
    fn default() -> &'a OpaqueResponse {
        <OpaqueResponse as ::protobuf::Message>::default_instance()
    }
}

impl OpaqueResponse {
    pub fn new() -> OpaqueResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &OpaqueResponse| { &m.uuid },
            |m: &mut OpaqueResponse| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &OpaqueResponse| { &m.error },
            |m: &mut OpaqueResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OpaqueResponse>(
            "OpaqueResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OpaqueResponse {
    const NAME: &'static str = "OpaqueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        if let Some(v) = self.error.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OpaqueResponse {
        OpaqueResponse::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OpaqueResponse {
        static instance: OpaqueResponse = OpaqueResponse {
            uuid: ::std::string::String::new(),
            error: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OpaqueResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OpaqueResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OpaqueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpaqueResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.PongResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PongResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.PongResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PongResponse {
    fn default() -> &'a PongResponse {
        <PongResponse as ::protobuf::Message>::default_instance()
    }
}

impl PongResponse {
    pub fn new() -> PongResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PongResponse>(
            "PongResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PongResponse {
    const NAME: &'static str = "PongResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PongResponse {
        PongResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PongResponse {
        static instance: PongResponse = PongResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PongResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PongResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PongResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PongResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConfigurationUpdate {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.version_nonce)
    pub version_nonce: ::std::string::String,
    // message oneof groups
    pub update_type: ::std::option::Option<configuration_update::Update_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConfigurationUpdate {
    fn default() -> &'a ConfigurationUpdate {
        <ConfigurationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ConfigurationUpdate {
    pub fn new() -> ConfigurationUpdate {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld state_of_the_world = 2;

    pub fn state_of_the_world(&self) -> &configuration_update::StateOfTheWorld {
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(ref v)) => v,
            _ => <configuration_update::StateOfTheWorld as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_state_of_the_world(&mut self) {
        self.update_type = ::std::option::Option::None;
    }

    pub fn has_state_of_the_world(&self) -> bool {
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state_of_the_world(&mut self, v: configuration_update::StateOfTheWorld) {
        self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state_of_the_world(&mut self) -> &mut configuration_update::StateOfTheWorld {
        if let ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(_)) = self.update_type {
        } else {
            self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(configuration_update::StateOfTheWorld::new()));
        }
        match self.update_type {
            ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state_of_the_world(&mut self) -> configuration_update::StateOfTheWorld {
        if self.has_state_of_the_world() {
            match self.update_type.take() {
                ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(v)) => v,
                _ => panic!(),
            }
        } else {
            configuration_update::StateOfTheWorld::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_nonce",
            |m: &ConfigurationUpdate| { &m.version_nonce },
            |m: &mut ConfigurationUpdate| { &mut m.version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, configuration_update::StateOfTheWorld>(
            "state_of_the_world",
            ConfigurationUpdate::has_state_of_the_world,
            ConfigurationUpdate::state_of_the_world,
            ConfigurationUpdate::mut_state_of_the_world,
            ConfigurationUpdate::set_state_of_the_world,
        ));
        oneofs.push(configuration_update::Update_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationUpdate>(
            "ConfigurationUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConfigurationUpdate {
    const NAME: &'static str = "ConfigurationUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_nonce = is.read_string()?;
                },
                18 => {
                    self.update_type = ::std::option::Option::Some(configuration_update::Update_type::StateOfTheWorld(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
        }
        if let ::std::option::Option::Some(ref v) = self.update_type {
            match v {
                &configuration_update::Update_type::StateOfTheWorld(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_nonce.is_empty() {
            os.write_string(1, &self.version_nonce)?;
        }
        if let ::std::option::Option::Some(ref v) = self.update_type {
            match v {
                &configuration_update::Update_type::StateOfTheWorld(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConfigurationUpdate {
        ConfigurationUpdate::new()
    }

    fn clear(&mut self) {
        self.version_nonce.clear();
        self.update_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConfigurationUpdate {
        static instance: ConfigurationUpdate = ConfigurationUpdate {
            version_nonce: ::std::string::String::new(),
            update_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConfigurationUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConfigurationUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConfigurationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigurationUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConfigurationUpdate`
pub mod configuration_update {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.update_type)
    pub enum Update_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.state_of_the_world)
        StateOfTheWorld(StateOfTheWorld),
    }

    impl ::protobuf::Oneof for Update_type {
    }

    impl ::protobuf::OneofFull for Update_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ConfigurationUpdate as ::protobuf::MessageFull>::descriptor().oneof_by_name("update_type").unwrap()).clone()
        }
    }

    impl Update_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Update_type>("update_type")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StateOfTheWorld {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.buffer_config_list)
        pub buffer_config_list: ::protobuf::MessageField<super::super::config::BufferConfigList>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.workflows_configuration)
        pub workflows_configuration: ::protobuf::MessageField<super::super::workflow::WorkflowsConfiguration>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.bdtail_configuration)
        pub bdtail_configuration: ::protobuf::MessageField<super::super::bdtail_config::BdTailConfigurations>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.filters_configuration)
        pub filters_configuration: ::protobuf::MessageField<super::super::filter::FiltersConfiguration>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ConfigurationUpdate.StateOfTheWorld.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StateOfTheWorld {
        fn default() -> &'a StateOfTheWorld {
            <StateOfTheWorld as ::protobuf::Message>::default_instance()
        }
    }

    impl StateOfTheWorld {
        pub fn new() -> StateOfTheWorld {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::config::BufferConfigList>(
                "buffer_config_list",
                |m: &StateOfTheWorld| { &m.buffer_config_list },
                |m: &mut StateOfTheWorld| { &mut m.buffer_config_list },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::workflow::WorkflowsConfiguration>(
                "workflows_configuration",
                |m: &StateOfTheWorld| { &m.workflows_configuration },
                |m: &mut StateOfTheWorld| { &mut m.workflows_configuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::bdtail_config::BdTailConfigurations>(
                "bdtail_configuration",
                |m: &StateOfTheWorld| { &m.bdtail_configuration },
                |m: &mut StateOfTheWorld| { &mut m.bdtail_configuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::filter::FiltersConfiguration>(
                "filters_configuration",
                |m: &StateOfTheWorld| { &m.filters_configuration },
                |m: &mut StateOfTheWorld| { &mut m.filters_configuration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateOfTheWorld>(
                "ConfigurationUpdate.StateOfTheWorld",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StateOfTheWorld {
        const NAME: &'static str = "StateOfTheWorld";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.buffer_config_list)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.workflows_configuration)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.bdtail_configuration)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.filters_configuration)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.buffer_config_list.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.workflows_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.bdtail_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.filters_configuration.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.buffer_config_list.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.workflows_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.bdtail_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.filters_configuration.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StateOfTheWorld {
            StateOfTheWorld::new()
        }

        fn clear(&mut self) {
            self.buffer_config_list.clear();
            self.workflows_configuration.clear();
            self.bdtail_configuration.clear();
            self.filters_configuration.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StateOfTheWorld {
            static instance: StateOfTheWorld = StateOfTheWorld {
                buffer_config_list: ::protobuf::MessageField::none(),
                workflows_configuration: ::protobuf::MessageField::none(),
                bdtail_configuration: ::protobuf::MessageField::none(),
                filters_configuration: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StateOfTheWorld {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConfigurationUpdate.StateOfTheWorld").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StateOfTheWorld {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StateOfTheWorld {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.RuntimeUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RuntimeUpdate {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.version_nonce)
    pub version_nonce: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.runtime)
    pub runtime: ::protobuf::MessageField<super::runtime::Runtime>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.RuntimeUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RuntimeUpdate {
    fn default() -> &'a RuntimeUpdate {
        <RuntimeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeUpdate {
    pub fn new() -> RuntimeUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version_nonce",
            |m: &RuntimeUpdate| { &m.version_nonce },
            |m: &mut RuntimeUpdate| { &mut m.version_nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::runtime::Runtime>(
            "runtime",
            |m: &RuntimeUpdate| { &m.runtime },
            |m: &mut RuntimeUpdate| { &mut m.runtime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeUpdate>(
            "RuntimeUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RuntimeUpdate {
    const NAME: &'static str = "RuntimeUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_nonce = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.runtime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version_nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_nonce);
        }
        if let Some(v) = self.runtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version_nonce.is_empty() {
            os.write_string(1, &self.version_nonce)?;
        }
        if let Some(v) = self.runtime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RuntimeUpdate {
        RuntimeUpdate::new()
    }

    fn clear(&mut self) {
        self.version_nonce.clear();
        self.runtime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RuntimeUpdate {
        static instance: RuntimeUpdate = RuntimeUpdate {
            version_nonce: ::std::string::String::new(),
            runtime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RuntimeUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RuntimeUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RuntimeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ErrorShutdown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ErrorShutdown {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ErrorShutdown.grpc_status)
    pub grpc_status: i32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.ErrorShutdown.grpc_message)
    pub grpc_message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ErrorShutdown.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ErrorShutdown {
    fn default() -> &'a ErrorShutdown {
        <ErrorShutdown as ::protobuf::Message>::default_instance()
    }
}

impl ErrorShutdown {
    pub fn new() -> ErrorShutdown {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_status",
            |m: &ErrorShutdown| { &m.grpc_status },
            |m: &mut ErrorShutdown| { &mut m.grpc_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_message",
            |m: &ErrorShutdown| { &m.grpc_message },
            |m: &mut ErrorShutdown| { &mut m.grpc_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorShutdown>(
            "ErrorShutdown",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ErrorShutdown {
    const NAME: &'static str = "ErrorShutdown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.grpc_status = is.read_int32()?;
                },
                18 => {
                    self.grpc_message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.grpc_status != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.grpc_status);
        }
        if !self.grpc_message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.grpc_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.grpc_status != 0 {
            os.write_int32(1, self.grpc_status)?;
        }
        if !self.grpc_message.is_empty() {
            os.write_string(2, &self.grpc_message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ErrorShutdown {
        ErrorShutdown::new()
    }

    fn clear(&mut self) {
        self.grpc_status = 0;
        self.grpc_message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ErrorShutdown {
        static instance: ErrorShutdown = ErrorShutdown {
            grpc_status: 0,
            grpc_message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ErrorShutdown {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ErrorShutdown").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ErrorShutdown {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorShutdown {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.FlushBuffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FlushBuffers {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.FlushBuffers.buffer_id_list)
    pub buffer_id_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.FlushBuffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FlushBuffers {
    fn default() -> &'a FlushBuffers {
        <FlushBuffers as ::protobuf::Message>::default_instance()
    }
}

impl FlushBuffers {
    pub fn new() -> FlushBuffers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffer_id_list",
            |m: &FlushBuffers| { &m.buffer_id_list },
            |m: &mut FlushBuffers| { &mut m.buffer_id_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FlushBuffers>(
            "FlushBuffers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FlushBuffers {
    const NAME: &'static str = "FlushBuffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buffer_id_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buffer_id_list {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buffer_id_list {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FlushBuffers {
        FlushBuffers::new()
    }

    fn clear(&mut self) {
        self.buffer_id_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FlushBuffers {
        static instance: FlushBuffers = FlushBuffers {
            buffer_id_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FlushBuffers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FlushBuffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FlushBuffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlushBuffers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyDiagramUploadResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyDiagramUploadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyDiagramUploadResponse {
    fn default() -> &'a SankeyDiagramUploadResponse {
        <SankeyDiagramUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl SankeyDiagramUploadResponse {
    pub fn new() -> SankeyDiagramUploadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyDiagramUploadResponse>(
            "SankeyDiagramUploadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyDiagramUploadResponse {
    const NAME: &'static str = "SankeyDiagramUploadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyDiagramUploadResponse {
        SankeyDiagramUploadResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyDiagramUploadResponse {
        static instance: SankeyDiagramUploadResponse = SankeyDiagramUploadResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyDiagramUploadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyDiagramUploadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyDiagramUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyDiagramUploadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.SankeyIntentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SankeyIntentResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.intent_uuid)
    pub intent_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.decision)
    pub decision: ::protobuf::EnumOrUnknown<sankey_intent_response::Decision>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SankeyIntentResponse {
    fn default() -> &'a SankeyIntentResponse {
        <SankeyIntentResponse as ::protobuf::Message>::default_instance()
    }
}

impl SankeyIntentResponse {
    pub fn new() -> SankeyIntentResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "intent_uuid",
            |m: &SankeyIntentResponse| { &m.intent_uuid },
            |m: &mut SankeyIntentResponse| { &mut m.intent_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "decision",
            |m: &SankeyIntentResponse| { &m.decision },
            |m: &mut SankeyIntentResponse| { &mut m.decision },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyIntentResponse>(
            "SankeyIntentResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SankeyIntentResponse {
    const NAME: &'static str = "SankeyIntentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.intent_uuid = is.read_string()?;
                },
                16 => {
                    self.decision = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.intent_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.intent_uuid);
        }
        if self.decision != ::protobuf::EnumOrUnknown::new(sankey_intent_response::Decision::UPLOAD) {
            my_size += ::protobuf::rt::int32_size(2, self.decision.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.intent_uuid.is_empty() {
            os.write_string(1, &self.intent_uuid)?;
        }
        if self.decision != ::protobuf::EnumOrUnknown::new(sankey_intent_response::Decision::UPLOAD) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.decision))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SankeyIntentResponse {
        SankeyIntentResponse::new()
    }

    fn clear(&mut self) {
        self.intent_uuid.clear();
        self.decision = ::protobuf::EnumOrUnknown::new(sankey_intent_response::Decision::UPLOAD);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SankeyIntentResponse {
        static instance: SankeyIntentResponse = SankeyIntentResponse {
            intent_uuid: ::std::string::String::new(),
            decision: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SankeyIntentResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SankeyIntentResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SankeyIntentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SankeyIntentResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SankeyIntentResponse`
pub mod sankey_intent_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Decision)
    pub enum Decision {
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Decision.UPLOAD)
        UPLOAD = 0,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.client.v1.SankeyIntentResponse.Decision.DROP)
        DROP = 1,
    }

    impl ::protobuf::Enum for Decision {
        const NAME: &'static str = "Decision";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Decision> {
            match value {
                0 => ::std::option::Option::Some(Decision::UPLOAD),
                1 => ::std::option::Option::Some(Decision::DROP),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Decision> {
            match str {
                "UPLOAD" => ::std::option::Option::Some(Decision::UPLOAD),
                "DROP" => ::std::option::Option::Some(Decision::DROP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Decision] = &[
            Decision::UPLOAD,
            Decision::DROP,
        ];
    }

    impl ::protobuf::EnumFull for Decision {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("SankeyIntentResponse.Decision").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Decision {
        fn default() -> Self {
            Decision::UPLOAD
        }
    }

    impl Decision {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Decision>("SankeyIntentResponse.Decision")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.client.v1.ApiResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ApiResponse {
    // message oneof groups
    pub response_type: ::std::option::Option<api_response::Response_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.client.v1.ApiResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ApiResponse {
    fn default() -> &'a ApiResponse {
        <ApiResponse as ::protobuf::Message>::default_instance()
    }
}

impl ApiResponse {
    pub fn new() -> ApiResponse {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.client.v1.HandshakeResponse handshake = 1;

    pub fn handshake(&self) -> &HandshakeResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(ref v)) => v,
            _ => <HandshakeResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_handshake(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_handshake(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handshake(&mut self, v: HandshakeResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handshake(&mut self) -> &mut HandshakeResponse {
        if let ::std::option::Option::Some(api_response::Response_type::Handshake(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(HandshakeResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Handshake(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handshake(&mut self) -> HandshakeResponse {
        if self.has_handshake() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::Handshake(v)) => v,
                _ => panic!(),
            }
        } else {
            HandshakeResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadResponse log_upload = 2;

    pub fn log_upload(&self) -> &LogUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(ref v)) => v,
            _ => <LogUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_log_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload(&mut self, v: LogUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload(&mut self) -> &mut LogUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::LogUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(LogUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload(&mut self) -> LogUploadResponse {
        if self.has_log_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::LogUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.LogUploadIntentResponse log_upload_intent = 8;

    pub fn log_upload_intent(&self) -> &LogUploadIntentResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(ref v)) => v,
            _ => <LogUploadIntentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_log_upload_intent(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_log_upload_intent(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_log_upload_intent(&mut self, v: LogUploadIntentResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_log_upload_intent(&mut self) -> &mut LogUploadIntentResponse {
        if let ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(LogUploadIntentResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_log_upload_intent(&mut self) -> LogUploadIntentResponse {
        if self.has_log_upload_intent() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(v)) => v,
                _ => panic!(),
            }
        } else {
            LogUploadIntentResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.StatsUploadResponse stats_upload = 7;

    pub fn stats_upload(&self) -> &StatsUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(ref v)) => v,
            _ => <StatsUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_stats_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_stats_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stats_upload(&mut self, v: StatsUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stats_upload(&mut self) -> &mut StatsUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::StatsUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(StatsUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::StatsUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stats_upload(&mut self) -> StatsUploadResponse {
        if self.has_stats_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::StatsUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            StatsUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.PongResponse pong = 3;

    pub fn pong(&self) -> &PongResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(ref v)) => v,
            _ => <PongResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pong(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_pong(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pong(&mut self, v: PongResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pong(&mut self) -> &mut PongResponse {
        if let ::std::option::Option::Some(api_response::Response_type::Pong(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(PongResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::Pong(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pong(&mut self) -> PongResponse {
        if self.has_pong() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::Pong(v)) => v,
                _ => panic!(),
            }
        } else {
            PongResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ConfigurationUpdate configuration_update = 4;

    pub fn configuration_update(&self) -> &ConfigurationUpdate {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ref v)) => v,
            _ => <ConfigurationUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_configuration_update(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_configuration_update(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_configuration_update(&mut self, v: ConfigurationUpdate) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_configuration_update(&mut self) -> &mut ConfigurationUpdate {
        if let ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ConfigurationUpdate::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_configuration_update(&mut self) -> ConfigurationUpdate {
        if self.has_configuration_update() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            ConfigurationUpdate::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.RuntimeUpdate runtime_update = 5;

    pub fn runtime_update(&self) -> &RuntimeUpdate {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(ref v)) => v,
            _ => <RuntimeUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_runtime_update(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_runtime_update(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_runtime_update(&mut self, v: RuntimeUpdate) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_runtime_update(&mut self) -> &mut RuntimeUpdate {
        if let ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(RuntimeUpdate::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_runtime_update(&mut self) -> RuntimeUpdate {
        if self.has_runtime_update() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeUpdate::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.ErrorShutdown error_shutdown = 6;

    pub fn error_shutdown(&self) -> &ErrorShutdown {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ref v)) => v,
            _ => <ErrorShutdown as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error_shutdown(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_error_shutdown(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error_shutdown(&mut self, v: ErrorShutdown) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error_shutdown(&mut self) -> &mut ErrorShutdown {
        if let ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ErrorShutdown::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error_shutdown(&mut self) -> ErrorShutdown {
        if self.has_error_shutdown() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(v)) => v,
                _ => panic!(),
            }
        } else {
            ErrorShutdown::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.FlushBuffers flush_buffers = 9;

    pub fn flush_buffers(&self) -> &FlushBuffers {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(ref v)) => v,
            _ => <FlushBuffers as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_flush_buffers(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_flush_buffers(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_flush_buffers(&mut self, v: FlushBuffers) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_flush_buffers(&mut self) -> &mut FlushBuffers {
        if let ::std::option::Option::Some(api_response::Response_type::FlushBuffers(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(FlushBuffers::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::FlushBuffers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_flush_buffers(&mut self) -> FlushBuffers {
        if self.has_flush_buffers() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::FlushBuffers(v)) => v,
                _ => panic!(),
            }
        } else {
            FlushBuffers::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.OpaqueConfigurationUpdate opaque_configuration_update = 10;

    pub fn opaque_configuration_update(&self) -> &OpaqueConfigurationUpdate {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(ref v)) => v,
            _ => <OpaqueConfigurationUpdate as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_opaque_configuration_update(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_opaque_configuration_update(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opaque_configuration_update(&mut self, v: OpaqueConfigurationUpdate) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opaque_configuration_update(&mut self) -> &mut OpaqueConfigurationUpdate {
        if let ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(OpaqueConfigurationUpdate::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opaque_configuration_update(&mut self) -> OpaqueConfigurationUpdate {
        if self.has_opaque_configuration_update() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(v)) => v,
                _ => panic!(),
            }
        } else {
            OpaqueConfigurationUpdate::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.OpaqueResponse opaque_upload = 11;

    pub fn opaque_upload(&self) -> &OpaqueResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(ref v)) => v,
            _ => <OpaqueResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_opaque_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_opaque_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_opaque_upload(&mut self, v: OpaqueResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_opaque_upload(&mut self) -> &mut OpaqueResponse {
        if let ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(OpaqueResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_opaque_upload(&mut self) -> OpaqueResponse {
        if self.has_opaque_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            OpaqueResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyDiagramUploadResponse sankey_diagram_upload = 12;

    pub fn sankey_diagram_upload(&self) -> &SankeyDiagramUploadResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(ref v)) => v,
            _ => <SankeyDiagramUploadResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_diagram_upload(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_sankey_diagram_upload(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_diagram_upload(&mut self, v: SankeyDiagramUploadResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_diagram_upload(&mut self) -> &mut SankeyDiagramUploadResponse {
        if let ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(SankeyDiagramUploadResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_diagram_upload(&mut self) -> SankeyDiagramUploadResponse {
        if self.has_sankey_diagram_upload() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyDiagramUploadResponse::new()
        }
    }

    // .bitdrift_public.protobuf.client.v1.SankeyIntentResponse sankey_intent_response = 13;

    pub fn sankey_intent_response(&self) -> &SankeyIntentResponse {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(ref v)) => v,
            _ => <SankeyIntentResponse as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sankey_intent_response(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_sankey_intent_response(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sankey_intent_response(&mut self, v: SankeyIntentResponse) {
        self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sankey_intent_response(&mut self) -> &mut SankeyIntentResponse {
        if let ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(SankeyIntentResponse::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sankey_intent_response(&mut self) -> SankeyIntentResponse {
        if self.has_sankey_intent_response() {
            match self.response_type.take() {
                ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            SankeyIntentResponse::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, HandshakeResponse>(
            "handshake",
            ApiResponse::has_handshake,
            ApiResponse::handshake,
            ApiResponse::mut_handshake,
            ApiResponse::set_handshake,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadResponse>(
            "log_upload",
            ApiResponse::has_log_upload,
            ApiResponse::log_upload,
            ApiResponse::mut_log_upload,
            ApiResponse::set_log_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogUploadIntentResponse>(
            "log_upload_intent",
            ApiResponse::has_log_upload_intent,
            ApiResponse::log_upload_intent,
            ApiResponse::mut_log_upload_intent,
            ApiResponse::set_log_upload_intent,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StatsUploadResponse>(
            "stats_upload",
            ApiResponse::has_stats_upload,
            ApiResponse::stats_upload,
            ApiResponse::mut_stats_upload,
            ApiResponse::set_stats_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PongResponse>(
            "pong",
            ApiResponse::has_pong,
            ApiResponse::pong,
            ApiResponse::mut_pong,
            ApiResponse::set_pong,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ConfigurationUpdate>(
            "configuration_update",
            ApiResponse::has_configuration_update,
            ApiResponse::configuration_update,
            ApiResponse::mut_configuration_update,
            ApiResponse::set_configuration_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RuntimeUpdate>(
            "runtime_update",
            ApiResponse::has_runtime_update,
            ApiResponse::runtime_update,
            ApiResponse::mut_runtime_update,
            ApiResponse::set_runtime_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ErrorShutdown>(
            "error_shutdown",
            ApiResponse::has_error_shutdown,
            ApiResponse::error_shutdown,
            ApiResponse::mut_error_shutdown,
            ApiResponse::set_error_shutdown,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FlushBuffers>(
            "flush_buffers",
            ApiResponse::has_flush_buffers,
            ApiResponse::flush_buffers,
            ApiResponse::mut_flush_buffers,
            ApiResponse::set_flush_buffers,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OpaqueConfigurationUpdate>(
            "opaque_configuration_update",
            ApiResponse::has_opaque_configuration_update,
            ApiResponse::opaque_configuration_update,
            ApiResponse::mut_opaque_configuration_update,
            ApiResponse::set_opaque_configuration_update,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, OpaqueResponse>(
            "opaque_upload",
            ApiResponse::has_opaque_upload,
            ApiResponse::opaque_upload,
            ApiResponse::mut_opaque_upload,
            ApiResponse::set_opaque_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyDiagramUploadResponse>(
            "sankey_diagram_upload",
            ApiResponse::has_sankey_diagram_upload,
            ApiResponse::sankey_diagram_upload,
            ApiResponse::mut_sankey_diagram_upload,
            ApiResponse::set_sankey_diagram_upload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SankeyIntentResponse>(
            "sankey_intent_response",
            ApiResponse::has_sankey_intent_response,
            ApiResponse::sankey_intent_response,
            ApiResponse::mut_sankey_intent_response,
            ApiResponse::set_sankey_intent_response,
        ));
        oneofs.push(api_response::Response_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApiResponse>(
            "ApiResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ApiResponse {
    const NAME: &'static str = "ApiResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::Handshake(is.read_message()?));
                },
                18 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUpload(is.read_message()?));
                },
                66 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::LogUploadIntent(is.read_message()?));
                },
                58 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::StatsUpload(is.read_message()?));
                },
                26 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::Pong(is.read_message()?));
                },
                34 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ConfigurationUpdate(is.read_message()?));
                },
                42 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::RuntimeUpdate(is.read_message()?));
                },
                50 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::ErrorShutdown(is.read_message()?));
                },
                74 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::FlushBuffers(is.read_message()?));
                },
                82 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueConfigurationUpdate(is.read_message()?));
                },
                90 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::OpaqueUpload(is.read_message()?));
                },
                98 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyDiagramUpload(is.read_message()?));
                },
                106 => {
                    self.response_type = ::std::option::Option::Some(api_response::Response_type::SankeyIntentResponse(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &api_response::Response_type::Handshake(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::LogUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::LogUploadIntent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::StatsUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::Pong(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ConfigurationUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::RuntimeUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::ErrorShutdown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::FlushBuffers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::OpaqueConfigurationUpdate(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::OpaqueUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::SankeyDiagramUpload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &api_response::Response_type::SankeyIntentResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &api_response::Response_type::Handshake(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &api_response::Response_type::LogUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &api_response::Response_type::LogUploadIntent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &api_response::Response_type::StatsUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &api_response::Response_type::Pong(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &api_response::Response_type::ConfigurationUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &api_response::Response_type::RuntimeUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &api_response::Response_type::ErrorShutdown(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &api_response::Response_type::FlushBuffers(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &api_response::Response_type::OpaqueConfigurationUpdate(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &api_response::Response_type::OpaqueUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &api_response::Response_type::SankeyDiagramUpload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &api_response::Response_type::SankeyIntentResponse(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ApiResponse {
        ApiResponse::new()
    }

    fn clear(&mut self) {
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ApiResponse {
        static instance: ApiResponse = ApiResponse {
            response_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ApiResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ApiResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ApiResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApiResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ApiResponse`
pub mod api_response {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.client.v1.ApiResponse.response_type)
    pub enum Response_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.handshake)
        Handshake(super::HandshakeResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.log_upload)
        LogUpload(super::LogUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.log_upload_intent)
        LogUploadIntent(super::LogUploadIntentResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.stats_upload)
        StatsUpload(super::StatsUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.pong)
        Pong(super::PongResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.configuration_update)
        ConfigurationUpdate(super::ConfigurationUpdate),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.runtime_update)
        RuntimeUpdate(super::RuntimeUpdate),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.error_shutdown)
        ErrorShutdown(super::ErrorShutdown),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.flush_buffers)
        FlushBuffers(super::FlushBuffers),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.opaque_configuration_update)
        OpaqueConfigurationUpdate(super::OpaqueConfigurationUpdate),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.opaque_upload)
        OpaqueUpload(super::OpaqueResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.sankey_diagram_upload)
        SankeyDiagramUpload(super::SankeyDiagramUploadResponse),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.client.v1.ApiResponse.sankey_intent_response)
        SankeyIntentResponse(super::SankeyIntentResponse),
    }

    impl ::protobuf::Oneof for Response_type {
    }

    impl ::protobuf::OneofFull for Response_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ApiResponse as ::protobuf::MessageFull>::descriptor().oneof_by_name("response_type").unwrap()).clone()
        }
    }

    impl Response_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Response_type>("response_type")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,bitdrift_public/protobuf/client/v1/api.proto\x12\"bitdrift_public.pro\
    tobuf.client.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/pro\
    tobuf/duration.proto\x1a\x19google/protobuf/any.proto\x1a0bitdrift_publi\
    c/protobuf/client/v1/runtime.proto\x1a/bitdrift_public/protobuf/client/v\
    1/metric.proto\x1a/bitdrift_public/protobuf/filter/v1/filter.proto\x1a3b\
    itdrift_public/protobuf/workflow/v1/workflow.proto\x1a6bitdrift_public/p\
    rotobuf/bdtail/v1/bdtail_config.proto\x1a/bitdrift_public/protobuf/confi\
    g/v1/config.proto\x1a1bitdrift_public/protobuf/logging/v1/payload.proto\
    \x1a\x17validate/validate.proto\"m\n\x0eClientKillFile\x12\x20\n\x0capi_\
    key_hash\x18\x01\x20\x01(\x0cR\napiKeyHash\x129\n\nkill_until\x18\x02\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tkillUntil\"\xe8\x04\n\x10\
    HandshakeRequest\x12\x84\x01\n\x16static_device_metadata\x18\x01\x20\x03\
    (\x0b2N.bitdrift_public.protobuf.client.v1.HandshakeRequest.StaticDevice\
    MetadataEntryR\x14staticDeviceMetadata\x12>\n\x1bconfiguration_version_n\
    once\x18\x03\x20\x01(\tR\x19configurationVersionNonce\x122\n\x15runtime_\
    version_nonce\x18\x04\x20\x01(\tR\x13runtimeVersionNonce\x12\x81\x01\n\
    \x15opqaue_version_nonces\x18\x05\x20\x03(\x0b2M.bitdrift_public.protobu\
    f.client.v1.HandshakeRequest.OpqaueVersionNoncesEntryR\x13opqaueVersionN\
    onces\x1ar\n\x19StaticDeviceMetadataEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12?\n\x05value\x18\x02\x20\x01(\x0b2).bitdrift_public.p\
    rotobuf.logging.v1.DataR\x05value:\x028\x01\x1aF\n\x18OpqaueVersionNonce\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01J\x04\x08\x02\x10\x03R\x13fields_\
    for_all_logs\"|\n\x19OpaqueConfigurationUpdate\x12#\n\rversion_nonce\x18\
    \x01\x20\x01(\tR\x0cversionNonce\x12:\n\rconfiguration\x18\x02\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\rconfiguration\"\x87\x01\n\x1cOpaqueConfi\
    gurationUpdateAck\x12\x19\n\x08type_url\x18\x01\x20\x01(\tR\x07typeUrl\
    \x12L\n\x03ack\x18\x02\x20\x01(\x0b2:.bitdrift_public.protobuf.client.v1\
    .ConfigurationUpdateAckR\x03ack\"\xf3\x02\n\x16LogUploadIntentRequest\
    \x12\x1b\n\tlog_count\x18\x01\x20\x01(\rR\x08logCount\x12\x1d\n\nbyte_co\
    unt\x18\x02\x20\x01(\rR\tbyteCount\x12\x1b\n\tbuffer_id\x18\x03\x20\x01(\
    \tR\x08bufferId\x12\x1f\n\x0bintent_uuid\x18\x04\x20\x01(\tR\nintentUuid\
    \x12\x87\x01\n\x16workflow_action_upload\x18\x05\x20\x01(\x0b2O.bitdrift\
    _public.protobuf.client.v1.LogUploadIntentRequest.WorkflowActionUploadH\
    \0R\x14workflowActionUpload\x1aF\n\x14WorkflowActionUpload\x12.\n\x13wor\
    kflow_action_ids\x18\x01\x20\x03(\tR\x11workflowActionIdsB\r\n\x0bintent\
    _type\"\xbb\x02\n\x17LogUploadIntentResponse\x12\x1f\n\x0bintent_uuid\
    \x18\x01\x20\x01(\tR\nintentUuid\x12~\n\x12upload_immediately\x18\x02\
    \x20\x01(\x0b2M.bitdrift_public.protobuf.client.v1.LogUploadIntentRespon\
    se.UploadImmediatelyH\0R\x11uploadImmediately\x12V\n\x04drop\x18\x03\x20\
    \x01(\x0b2@.bitdrift_public.protobuf.client.v1.LogUploadIntentResponse.D\
    ropH\0R\x04drop\x1a\x13\n\x11UploadImmediately\x1a\x06\n\x04DropB\n\n\
    \x08decision\"\x84\x01\n\x10LogUploadRequest\x12(\n\x0bupload_uuid\x18\
    \x01\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x1c\n\x04log\
    s\x18\x02\x20\x03(\x0cR\x04logsB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12(\n\
    \x0bbuffer_uuid\x18\x03\x20\x01(\tR\nbufferUuidB\x07\xfaB\x04r\x02\x10\
    \x01\"\r\n\x0bPingRequest\"\xfc\x01\n\x16ConfigurationUpdateAck\x12;\n\
    \x1alast_applied_version_nonce\x18\x01\x20\x01(\tR\x17lastAppliedVersion\
    Nonce\x12S\n\x04nack\x18\x02\x20\x01(\x0b2?.bitdrift_public.protobuf.cli\
    ent.v1.ConfigurationUpdateAck.NackR\x04nack\x1aP\n\x04Nack\x12#\n\rversi\
    on_nonce\x18\x01\x20\x01(\tR\x0cversionNonce\x12#\n\rerror_details\x18\
    \x02\x20\x01(\tR\x0cerrorDetails\"\xfc\x08\n\nApiRequest\x12T\n\thandsha\
    ke\x18\x01\x20\x01(\x0b24.bitdrift_public.protobuf.client.v1.HandshakeRe\
    questH\0R\thandshake\x12h\n\x11log_upload_intent\x18\x07\x20\x01(\x0b2:.\
    bitdrift_public.protobuf.client.v1.LogUploadIntentRequestH\0R\x0flogUplo\
    adIntent\x12U\n\nlog_upload\x18\x02\x20\x01(\x0b24.bitdrift_public.proto\
    buf.client.v1.LogUploadRequestH\0R\tlogUpload\x12[\n\x0cstats_upload\x18\
    \x06\x20\x01(\x0b26.bitdrift_public.protobuf.client.v1.StatsUploadReques\
    tH\0R\x0bstatsUpload\x12E\n\x04ping\x18\x03\x20\x01(\x0b2/.bitdrift_publ\
    ic.protobuf.client.v1.PingRequestH\0R\x04ping\x12v\n\x18configuration_up\
    date_ack\x18\x04\x20\x01(\x0b2:.bitdrift_public.protobuf.client.v1.Confi\
    gurationUpdateAckH\0R\x16configurationUpdateAck\x12j\n\x12runtime_update\
    _ack\x18\x05\x20\x01(\x0b2:.bitdrift_public.protobuf.client.v1.Configura\
    tionUpdateAckH\0R\x10runtimeUpdateAck\x12\x89\x01\n\x1fopaque_configurat\
    ion_update_ack\x18\x08\x20\x01(\x0b2@.bitdrift_public.protobuf.client.v1\
    .OpaqueConfigurationUpdateAckH\0R\x1copaqueConfigurationUpdateAck\x12X\n\
    \ropaque_upload\x18\t\x20\x01(\x0b21.bitdrift_public.protobuf.client.v1.\
    OpaqueRequestH\0R\x0copaqueUpload\x12t\n\x15sankey_diagram_upload\x18\n\
    \x20\x01(\x0b2>.bitdrift_public.protobuf.client.v1.SankeyDiagramUploadRe\
    questH\0R\x13sankeyDiagramUpload\x12^\n\rsankey_intent\x18\x0b\x20\x01(\
    \x0b27.bitdrift_public.protobuf.client.v1.SankeyIntentRequestH\0R\x0csan\
    keyIntentB\x13\n\x0crequest_type\x12\x03\xf8B\x01\"\xf6\x01\n\x1aSankeyD\
    iagramUploadRequest\x12\x17\n\x02id\x18\x01\x20\x01(\tR\x02idB\x07\xfaB\
    \x04r\x02\x10\x01\x12\x20\n\x07path_id\x18\x02\x20\x01(\tR\x06pathIdB\
    \x07\xfaB\x04r\x02\x10\x01\x12c\n\x05nodes\x18\x03\x20\x03(\x0b2C.bitdri\
    ft_public.protobuf.client.v1.SankeyDiagramUploadRequest.NodeR\x05nodesB\
    \x08\xfaB\x05\x92\x01\x02\x08\x01\x1a8\n\x04Node\x120\n\x0fextracted_val\
    ue\x18\x01\x20\x01(\tR\x0eextractedValueB\x07\xfaB\x04r\x02\x10\x01\"\
    \x96\x01\n\x13SankeyIntentRequest\x12(\n\x0bintent_uuid\x18\x01\x20\x01(\
    \tR\nintentUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x20\n\x07path_id\x18\x02\
    \x20\x01(\tR\x06pathIdB\x07\xfaB\x04r\x02\x10\x01\x123\n\x11sankey_diagr\
    am_id\x18\x03\x20\x01(\tR\x0fsankeyDiagramIdB\x07\xfaB\x04r\x02\x10\x01\
    \"\xd4\x01\n\x11HandshakeResponse\x12m\n\x0fstream_settings\x18\x01\x20\
    \x01(\x0b2D.bitdrift_public.protobuf.client.v1.HandshakeResponse.StreamS\
    ettingsR\x0estreamSettings\x1aP\n\x0eStreamSettings\x12>\n\rping_interva\
    l\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0cpingInterval\"\
    \r\n\x0bRateLimited\"\xca\x01\n\x11LogUploadResponse\x12(\n\x0bupload_uu\
    id\x18\x01\x20\x01(\tR\nuploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12\x14\n\
    \x05error\x18\x02\x20\x01(\tR\x05error\x12!\n\x0clogs_dropped\x18\x03\
    \x20\x01(\rR\x0blogsDropped\x12R\n\x0crate_limited\x18\x04\x20\x01(\x0b2\
    /.bitdrift_public.protobuf.client.v1.RateLimitedR\x0brateLimited\"\xdf\
    \x04\n\x12StatsUploadRequest\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\n\
    uploadUuidB\x07\xfaB\x04r\x02\x10\x01\x12e\n\x08snapshot\x18\x02\x20\x03\
    (\x0b2?.bitdrift_public.protobuf.client.v1.StatsUploadRequest.SnapshotR\
    \x08snapshotB\x08\xfaB\x05\x92\x01\x02\x08\x01\x123\n\x07sent_at\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x06sentAt\x1a\x82\x03\n\
    \x08Snapshot\x12K\n\x07metrics\x18\x01\x20\x01(\x0b2/.bitdrift_public.pr\
    otobuf.client.v1.MetricsListH\0R\x07metrics\x12l\n\naggregated\x18\x02\
    \x20\x01(\x0b2J.bitdrift_public.protobuf.client.v1.StatsUploadRequest.Sn\
    apshot.AggregatedH\x01R\naggregated\x1a\x90\x01\n\nAggregated\x12G\n\x0c\
    period_start\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0bper\
    iodStartB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x129\n\nperiod_end\x18\x05\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tperiodEndB\x14\n\rsnapsho\
    t_type\x12\x03\xf8B\x01B\x12\n\x0boccurred_at\x12\x03\xf8B\x01\"~\n\x13S\
    tatsUploadResponse\x12(\n\x0bupload_uuid\x18\x01\x20\x01(\tR\nuploadUuid\
    B\x07\xfaB\x04r\x02\x10\x01\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05er\
    ror\x12'\n\x0fmetrics_dropped\x18\x03\x20\x01(\rR\x0emetricsDropped\"]\n\
    \rOpaqueRequest\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\x04uuid\x128\n\x07\
    request\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x07requestB\x08\
    \xfaB\x05\x8a\x01\x02\x10\x01\"R\n\x0eOpaqueResponse\x12\x1b\n\x04uuid\
    \x18\x01\x20\x01(\tR\x04uuidB\x07\xfaB\x04r\x02\x10\x01\x12\x19\n\x05err\
    or\x18\x02\x20\x01(\tH\0R\x05error\x88\x01\x01B\x08\n\x06_error\"\x0e\n\
    \x0cPongResponse\"\xba\x05\n\x13ConfigurationUpdate\x12#\n\rversion_nonc\
    e\x18\x01\x20\x01(\tR\x0cversionNonce\x12v\n\x12state_of_the_world\x18\
    \x02\x20\x01(\x0b2G.bitdrift_public.protobuf.client.v1.ConfigurationUpda\
    te.StateOfTheWorldH\0R\x0fstateOfTheWorld\x1a\xf6\x03\n\x0fStateOfTheWor\
    ld\x12b\n\x12buffer_config_list\x18\x03\x20\x01(\x0b24.bitdrift_public.p\
    rotobuf.config.v1.BufferConfigListR\x10bufferConfigList\x12u\n\x17workfl\
    ows_configuration\x18\x04\x20\x01(\x0b2<.bitdrift_public.protobuf.workfl\
    ow.v1.WorkflowsConfigurationR\x16workflowsConfiguration\x12k\n\x14bdtail\
    _configuration\x18\x06\x20\x01(\x0b28.bitdrift_public.protobuf.bdtail.v1\
    .BdTailConfigurationsR\x13bdtailConfiguration\x12m\n\x15filters_configur\
    ation\x18\x08\x20\x01(\x0b28.bitdrift_public.protobuf.filter.v1.FiltersC\
    onfigurationR\x14filtersConfigurationJ\x04\x08\x02\x10\x03J\x04\x08\x07\
    \x10\x08R\x08mll_listR\x16insights_configurationB\r\n\x0bupdate_type\"{\
    \n\rRuntimeUpdate\x12#\n\rversion_nonce\x18\x01\x20\x01(\tR\x0cversionNo\
    nce\x12E\n\x07runtime\x18\x02\x20\x01(\x0b2+.bitdrift_public.protobuf.cl\
    ient.v1.RuntimeR\x07runtime\"S\n\rErrorShutdown\x12\x1f\n\x0bgrpc_status\
    \x18\x01\x20\x01(\x05R\ngrpcStatus\x12!\n\x0cgrpc_message\x18\x02\x20\
    \x01(\tR\x0bgrpcMessage\"4\n\x0cFlushBuffers\x12$\n\x0ebuffer_id_list\
    \x18\x01\x20\x03(\tR\x0cbufferIdList\"\x1d\n\x1bSankeyDiagramUploadRespo\
    nse\"\xc1\x01\n\x14SankeyIntentResponse\x12(\n\x0bintent_uuid\x18\x01\
    \x20\x01(\tR\nintentUuidB\x07\xfaB\x04r\x02\x10\x01\x12]\n\x08decision\
    \x18\x02\x20\x01(\x0e2A.bitdrift_public.protobuf.client.v1.SankeyIntentR\
    esponse.DecisionR\x08decision\"\x20\n\x08Decision\x12\n\n\x06UPLOAD\x10\
    \0\x12\x08\n\x04DROP\x10\x01\"\xa7\n\n\x0bApiResponse\x12U\n\thandshake\
    \x18\x01\x20\x01(\x0b25.bitdrift_public.protobuf.client.v1.HandshakeResp\
    onseH\0R\thandshake\x12V\n\nlog_upload\x18\x02\x20\x01(\x0b25.bitdrift_p\
    ublic.protobuf.client.v1.LogUploadResponseH\0R\tlogUpload\x12i\n\x11log_\
    upload_intent\x18\x08\x20\x01(\x0b2;.bitdrift_public.protobuf.client.v1.\
    LogUploadIntentResponseH\0R\x0flogUploadIntent\x12\\\n\x0cstats_upload\
    \x18\x07\x20\x01(\x0b27.bitdrift_public.protobuf.client.v1.StatsUploadRe\
    sponseH\0R\x0bstatsUpload\x12F\n\x04pong\x18\x03\x20\x01(\x0b20.bitdrift\
    _public.protobuf.client.v1.PongResponseH\0R\x04pong\x12l\n\x14configurat\
    ion_update\x18\x04\x20\x01(\x0b27.bitdrift_public.protobuf.client.v1.Con\
    figurationUpdateH\0R\x13configurationUpdate\x12Z\n\x0eruntime_update\x18\
    \x05\x20\x01(\x0b21.bitdrift_public.protobuf.client.v1.RuntimeUpdateH\0R\
    \rruntimeUpdate\x12Z\n\x0eerror_shutdown\x18\x06\x20\x01(\x0b21.bitdrift\
    _public.protobuf.client.v1.ErrorShutdownH\0R\rerrorShutdown\x12W\n\rflus\
    h_buffers\x18\t\x20\x01(\x0b20.bitdrift_public.protobuf.client.v1.FlushB\
    uffersH\0R\x0cflushBuffers\x12\x7f\n\x1bopaque_configuration_update\x18\
    \n\x20\x01(\x0b2=.bitdrift_public.protobuf.client.v1.OpaqueConfiguration\
    UpdateH\0R\x19opaqueConfigurationUpdate\x12Y\n\ropaque_upload\x18\x0b\
    \x20\x01(\x0b22.bitdrift_public.protobuf.client.v1.OpaqueResponseH\0R\
    \x0copaqueUpload\x12u\n\x15sankey_diagram_upload\x18\x0c\x20\x01(\x0b2?.\
    bitdrift_public.protobuf.client.v1.SankeyDiagramUploadResponseH\0R\x13sa\
    nkeyDiagramUpload\x12p\n\x16sankey_intent_response\x18\r\x20\x01(\x0b28.\
    bitdrift_public.protobuf.client.v1.SankeyIntentResponseH\0R\x14sankeyInt\
    entResponseB\x14\n\rresponse_type\x12\x03\xf8B\x012x\n\nApiService\x12j\
    \n\x03Mux\x12..bitdrift_public.protobuf.client.v1.ApiRequest\x1a/.bitdri\
    ft_public.protobuf.client.v1.ApiResponse(\x010\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(11);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::any::file_descriptor().clone());
            deps.push(super::runtime::file_descriptor().clone());
            deps.push(super::metric::file_descriptor().clone());
            deps.push(super::filter::file_descriptor().clone());
            deps.push(super::workflow::file_descriptor().clone());
            deps.push(super::bdtail_config::file_descriptor().clone());
            deps.push(super::config::file_descriptor().clone());
            deps.push(super::payload::file_descriptor().clone());
            deps.push(super::validate::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(36);
            messages.push(ClientKillFile::generated_message_descriptor_data());
            messages.push(HandshakeRequest::generated_message_descriptor_data());
            messages.push(OpaqueConfigurationUpdate::generated_message_descriptor_data());
            messages.push(OpaqueConfigurationUpdateAck::generated_message_descriptor_data());
            messages.push(LogUploadIntentRequest::generated_message_descriptor_data());
            messages.push(LogUploadIntentResponse::generated_message_descriptor_data());
            messages.push(LogUploadRequest::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(ConfigurationUpdateAck::generated_message_descriptor_data());
            messages.push(ApiRequest::generated_message_descriptor_data());
            messages.push(SankeyDiagramUploadRequest::generated_message_descriptor_data());
            messages.push(SankeyIntentRequest::generated_message_descriptor_data());
            messages.push(HandshakeResponse::generated_message_descriptor_data());
            messages.push(RateLimited::generated_message_descriptor_data());
            messages.push(LogUploadResponse::generated_message_descriptor_data());
            messages.push(StatsUploadRequest::generated_message_descriptor_data());
            messages.push(StatsUploadResponse::generated_message_descriptor_data());
            messages.push(OpaqueRequest::generated_message_descriptor_data());
            messages.push(OpaqueResponse::generated_message_descriptor_data());
            messages.push(PongResponse::generated_message_descriptor_data());
            messages.push(ConfigurationUpdate::generated_message_descriptor_data());
            messages.push(RuntimeUpdate::generated_message_descriptor_data());
            messages.push(ErrorShutdown::generated_message_descriptor_data());
            messages.push(FlushBuffers::generated_message_descriptor_data());
            messages.push(SankeyDiagramUploadResponse::generated_message_descriptor_data());
            messages.push(SankeyIntentResponse::generated_message_descriptor_data());
            messages.push(ApiResponse::generated_message_descriptor_data());
            messages.push(log_upload_intent_request::WorkflowActionUpload::generated_message_descriptor_data());
            messages.push(log_upload_intent_response::UploadImmediately::generated_message_descriptor_data());
            messages.push(log_upload_intent_response::Drop::generated_message_descriptor_data());
            messages.push(configuration_update_ack::Nack::generated_message_descriptor_data());
            messages.push(sankey_diagram_upload_request::Node::generated_message_descriptor_data());
            messages.push(handshake_response::StreamSettings::generated_message_descriptor_data());
            messages.push(stats_upload_request::Snapshot::generated_message_descriptor_data());
            messages.push(stats_upload_request::snapshot::Aggregated::generated_message_descriptor_data());
            messages.push(configuration_update::StateOfTheWorld::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(sankey_intent_response::Decision::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
