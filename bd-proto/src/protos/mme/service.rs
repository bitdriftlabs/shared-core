// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 29.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/mme/v1/service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.Metric)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Metric {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.annotations)
    pub annotations: ::std::vec::Vec<Annotation>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.allowlist_rules)
    pub allowlist_rules: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.first_read_s)
    pub first_read_s: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.last_read_s)
    pub last_read_s: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.first_written_s)
    pub first_written_s: i64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.last_written_s)
    pub last_written_s: i64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Metric.blocklisted_at_s)
    pub blocklisted_at_s: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.Metric.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Metric {
    fn default() -> &'a Metric {
        <Metric as ::protobuf::Message>::default_instance()
    }
}

impl Metric {
    pub fn new() -> Metric {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Metric| { &m.name },
            |m: &mut Metric| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotations",
            |m: &Metric| { &m.annotations },
            |m: &mut Metric| { &mut m.annotations },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allowlist_rules",
            |m: &Metric| { &m.allowlist_rules },
            |m: &mut Metric| { &mut m.allowlist_rules },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_read_s",
            |m: &Metric| { &m.first_read_s },
            |m: &mut Metric| { &mut m.first_read_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_read_s",
            |m: &Metric| { &m.last_read_s },
            |m: &mut Metric| { &mut m.last_read_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "first_written_s",
            |m: &Metric| { &m.first_written_s },
            |m: &mut Metric| { &mut m.first_written_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_written_s",
            |m: &Metric| { &m.last_written_s },
            |m: &mut Metric| { &mut m.last_written_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blocklisted_at_s",
            |m: &Metric| { &m.blocklisted_at_s },
            |m: &mut Metric| { &mut m.blocklisted_at_s },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Metric>(
            "Metric",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Metric {
    const NAME: &'static str = "Metric";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.annotations.push(is.read_message()?);
                },
                66 => {
                    self.allowlist_rules.push(is.read_string()?);
                },
                72 => {
                    self.first_read_s = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.last_read_s = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.first_written_s = is.read_int64()?;
                },
                96 => {
                    self.last_written_s = is.read_int64()?;
                },
                104 => {
                    self.blocklisted_at_s = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.annotations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.allowlist_rules {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.first_read_s {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.last_read_s {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if self.first_written_s != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.first_written_s);
        }
        if self.last_written_s != 0 {
            my_size += ::protobuf::rt::int64_size(12, self.last_written_s);
        }
        if let Some(v) = self.blocklisted_at_s {
            my_size += ::protobuf::rt::int64_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.annotations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.allowlist_rules {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.first_read_s {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.last_read_s {
            os.write_int64(10, v)?;
        }
        if self.first_written_s != 0 {
            os.write_int64(11, self.first_written_s)?;
        }
        if self.last_written_s != 0 {
            os.write_int64(12, self.last_written_s)?;
        }
        if let Some(v) = self.blocklisted_at_s {
            os.write_int64(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Metric {
        Metric::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.annotations.clear();
        self.allowlist_rules.clear();
        self.first_read_s = ::std::option::Option::None;
        self.last_read_s = ::std::option::Option::None;
        self.first_written_s = 0;
        self.last_written_s = 0;
        self.blocklisted_at_s = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Metric {
        static instance: Metric = Metric {
            name: ::std::string::String::new(),
            annotations: ::std::vec::Vec::new(),
            allowlist_rules: ::std::vec::Vec::new(),
            first_read_s: ::std::option::Option::None,
            last_read_s: ::std::option::Option::None,
            first_written_s: 0,
            last_written_s: 0,
            blocklisted_at_s: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Metric {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Metric").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Metric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Metric {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.Annotation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Annotation {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Annotation.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Annotation.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.Annotation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Annotation {
    fn default() -> &'a Annotation {
        <Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Annotation {
    pub fn new() -> Annotation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &Annotation| { &m.key },
            |m: &mut Annotation| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Annotation| { &m.value },
            |m: &mut Annotation| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Annotation>(
            "Annotation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Annotation {
    const NAME: &'static str = "Annotation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Annotation {
        Annotation::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Annotation {
        static instance: Annotation = Annotation {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Annotation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Annotation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Annotation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.LabelMatcher)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LabelMatcher {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.LabelMatcher.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.LabelMatcher.value)
    pub value: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.LabelMatcher.match_type)
    pub match_type: ::protobuf::EnumOrUnknown<label_matcher::MatchType>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.LabelMatcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LabelMatcher {
    fn default() -> &'a LabelMatcher {
        <LabelMatcher as ::protobuf::Message>::default_instance()
    }
}

impl LabelMatcher {
    pub fn new() -> LabelMatcher {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &LabelMatcher| { &m.label },
            |m: &mut LabelMatcher| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &LabelMatcher| { &m.value },
            |m: &mut LabelMatcher| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "match_type",
            |m: &LabelMatcher| { &m.match_type },
            |m: &mut LabelMatcher| { &mut m.match_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LabelMatcher>(
            "LabelMatcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LabelMatcher {
    const NAME: &'static str = "LabelMatcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                24 => {
                    self.match_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(label_matcher::MatchType::MATCH_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.match_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.match_type != ::protobuf::EnumOrUnknown::new(label_matcher::MatchType::MATCH_TYPE_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LabelMatcher {
        LabelMatcher::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.value.clear();
        self.match_type = ::protobuf::EnumOrUnknown::new(label_matcher::MatchType::MATCH_TYPE_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LabelMatcher {
        static instance: LabelMatcher = LabelMatcher {
            label: ::std::string::String::new(),
            value: ::std::string::String::new(),
            match_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LabelMatcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LabelMatcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LabelMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelMatcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LabelMatcher`
pub mod label_matcher {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType)
    pub enum MatchType {
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType.MATCH_TYPE_UNKNOWN)
        MATCH_TYPE_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType.MATCH_TYPE_EQUAL)
        MATCH_TYPE_EQUAL = 1,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType.MATCH_TYPE_NOT_EQUAL)
        MATCH_TYPE_NOT_EQUAL = 2,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType.MATCH_TYPE_REGEX)
        MATCH_TYPE_REGEX = 3,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.LabelMatcher.MatchType.MATCH_TYPE_NOT_REGEX)
        MATCH_TYPE_NOT_REGEX = 4,
    }

    impl ::protobuf::Enum for MatchType {
        const NAME: &'static str = "MatchType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MatchType> {
            match value {
                0 => ::std::option::Option::Some(MatchType::MATCH_TYPE_UNKNOWN),
                1 => ::std::option::Option::Some(MatchType::MATCH_TYPE_EQUAL),
                2 => ::std::option::Option::Some(MatchType::MATCH_TYPE_NOT_EQUAL),
                3 => ::std::option::Option::Some(MatchType::MATCH_TYPE_REGEX),
                4 => ::std::option::Option::Some(MatchType::MATCH_TYPE_NOT_REGEX),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<MatchType> {
            match str {
                "MATCH_TYPE_UNKNOWN" => ::std::option::Option::Some(MatchType::MATCH_TYPE_UNKNOWN),
                "MATCH_TYPE_EQUAL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_EQUAL),
                "MATCH_TYPE_NOT_EQUAL" => ::std::option::Option::Some(MatchType::MATCH_TYPE_NOT_EQUAL),
                "MATCH_TYPE_REGEX" => ::std::option::Option::Some(MatchType::MATCH_TYPE_REGEX),
                "MATCH_TYPE_NOT_REGEX" => ::std::option::Option::Some(MatchType::MATCH_TYPE_NOT_REGEX),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MatchType] = &[
            MatchType::MATCH_TYPE_UNKNOWN,
            MatchType::MATCH_TYPE_EQUAL,
            MatchType::MATCH_TYPE_NOT_EQUAL,
            MatchType::MATCH_TYPE_REGEX,
            MatchType::MATCH_TYPE_NOT_REGEX,
        ];
    }

    impl ::protobuf::EnumFull for MatchType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("LabelMatcher.MatchType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MatchType {
        fn default() -> Self {
            MatchType::MATCH_TYPE_UNKNOWN
        }
    }

    impl MatchType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MatchType>("LabelMatcher.MatchType")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.Matcher)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Matcher {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.Matcher.label_matchers)
    pub label_matchers: ::std::vec::Vec<LabelMatcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.Matcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Matcher {
    fn default() -> &'a Matcher {
        <Matcher as ::protobuf::Message>::default_instance()
    }
}

impl Matcher {
    pub fn new() -> Matcher {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "label_matchers",
            |m: &Matcher| { &m.label_matchers },
            |m: &mut Matcher| { &mut m.label_matchers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Matcher>(
            "Matcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Matcher {
    const NAME: &'static str = "Matcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label_matchers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.label_matchers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.label_matchers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Matcher {
        Matcher::new()
    }

    fn clear(&mut self) {
        self.label_matchers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Matcher {
        static instance: Matcher = Matcher {
            label_matchers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Matcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Matcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Matcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Matcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.MatcherList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatcherList {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.MatcherList.matchers)
    pub matchers: ::std::vec::Vec<Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.MatcherList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatcherList {
    fn default() -> &'a MatcherList {
        <MatcherList as ::protobuf::Message>::default_instance()
    }
}

impl MatcherList {
    pub fn new() -> MatcherList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchers",
            |m: &MatcherList| { &m.matchers },
            |m: &mut MatcherList| { &mut m.matchers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatcherList>(
            "MatcherList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatcherList {
    const NAME: &'static str = "MatcherList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matchers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matchers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matchers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatcherList {
        MatcherList::new()
    }

    fn clear(&mut self) {
        self.matchers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatcherList {
        static instance: MatcherList = MatcherList {
            matchers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatcherList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatcherList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatcherList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatcherList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlocklistRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest.matcher)
    pub matcher: ::protobuf::MessageField<Matcher>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest.page_size)
    pub page_size: u64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest.page_offset)
    pub page_offset: u64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest.include_source)
    pub include_source: bool,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetBlocklistRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlocklistRequest {
    fn default() -> &'a GetBlocklistRequest {
        <GetBlocklistRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocklistRequest {
    pub fn new() -> GetBlocklistRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Matcher>(
            "matcher",
            |m: &GetBlocklistRequest| { &m.matcher },
            |m: &mut GetBlocklistRequest| { &mut m.matcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &GetBlocklistRequest| { &m.page_size },
            |m: &mut GetBlocklistRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_offset",
            |m: &GetBlocklistRequest| { &m.page_offset },
            |m: &mut GetBlocklistRequest| { &mut m.page_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_source",
            |m: &GetBlocklistRequest| { &m.include_source },
            |m: &mut GetBlocklistRequest| { &mut m.include_source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlocklistRequest>(
            "GetBlocklistRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlocklistRequest {
    const NAME: &'static str = "GetBlocklistRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matcher)?;
                },
                16 => {
                    self.page_size = is.read_uint64()?;
                },
                24 => {
                    self.page_offset = is.read_uint64()?;
                },
                32 => {
                    self.include_source = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.page_size);
        }
        if self.page_offset != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.page_offset);
        }
        if self.include_source != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.page_size != 0 {
            os.write_uint64(2, self.page_size)?;
        }
        if self.page_offset != 0 {
            os.write_uint64(3, self.page_offset)?;
        }
        if self.include_source != false {
            os.write_bool(4, self.include_source)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlocklistRequest {
        GetBlocklistRequest::new()
    }

    fn clear(&mut self) {
        self.matcher.clear();
        self.page_size = 0;
        self.page_offset = 0;
        self.include_source = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlocklistRequest {
        static instance: GetBlocklistRequest = GetBlocklistRequest {
            matcher: ::protobuf::MessageField::none(),
            page_size: 0,
            page_offset: 0,
            include_source: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlocklistRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlocklistRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlocklistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocklistRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetBlocklistResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBlocklistResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetBlocklistResponse.metrics)
    pub metrics: ::std::vec::Vec<Metric>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetBlocklistResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBlocklistResponse {
    fn default() -> &'a GetBlocklistResponse {
        <GetBlocklistResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBlocklistResponse {
    pub fn new() -> GetBlocklistResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &GetBlocklistResponse| { &m.metrics },
            |m: &mut GetBlocklistResponse| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetBlocklistResponse>(
            "GetBlocklistResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetBlocklistResponse {
    const NAME: &'static str = "GetBlocklistResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBlocklistResponse {
        GetBlocklistResponse::new()
    }

    fn clear(&mut self) {
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBlocklistResponse {
        static instance: GetBlocklistResponse = GetBlocklistResponse {
            metrics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetBlocklistResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBlocklistResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBlocklistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlocklistResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.AllowMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllowMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.AllowMetricsRequest.matcher)
    pub matcher: ::protobuf::MessageField<Matcher>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.AllowMetricsRequest.allow_regex)
    pub allow_regex: bool,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.AllowMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllowMetricsRequest {
    fn default() -> &'a AllowMetricsRequest {
        <AllowMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AllowMetricsRequest {
    pub fn new() -> AllowMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Matcher>(
            "matcher",
            |m: &AllowMetricsRequest| { &m.matcher },
            |m: &mut AllowMetricsRequest| { &mut m.matcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "allow_regex",
            |m: &AllowMetricsRequest| { &m.allow_regex },
            |m: &mut AllowMetricsRequest| { &mut m.allow_regex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllowMetricsRequest>(
            "AllowMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllowMetricsRequest {
    const NAME: &'static str = "AllowMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matcher)?;
                },
                16 => {
                    self.allow_regex = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.allow_regex != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.allow_regex != false {
            os.write_bool(2, self.allow_regex)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllowMetricsRequest {
        AllowMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.matcher.clear();
        self.allow_regex = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllowMetricsRequest {
        static instance: AllowMetricsRequest = AllowMetricsRequest {
            matcher: ::protobuf::MessageField::none(),
            allow_regex: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllowMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllowMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllowMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.AllowMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllowMetricsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.AllowMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllowMetricsResponse {
    fn default() -> &'a AllowMetricsResponse {
        <AllowMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllowMetricsResponse {
    pub fn new() -> AllowMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllowMetricsResponse>(
            "AllowMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllowMetricsResponse {
    const NAME: &'static str = "AllowMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllowMetricsResponse {
        AllowMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllowMetricsResponse {
        static instance: AllowMetricsResponse = AllowMetricsResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllowMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllowMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllowMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BlockMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.BlockMetricsRequest.matcher)
    pub matcher: ::protobuf::MessageField<Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BlockMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockMetricsRequest {
    fn default() -> &'a BlockMetricsRequest {
        <BlockMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl BlockMetricsRequest {
    pub fn new() -> BlockMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Matcher>(
            "matcher",
            |m: &BlockMetricsRequest| { &m.matcher },
            |m: &mut BlockMetricsRequest| { &mut m.matcher },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockMetricsRequest>(
            "BlockMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockMetricsRequest {
    const NAME: &'static str = "BlockMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matcher)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockMetricsRequest {
        BlockMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.matcher.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockMetricsRequest {
        static instance: BlockMetricsRequest = BlockMetricsRequest {
            matcher: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BlockMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BlockMetricsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BlockMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockMetricsResponse {
    fn default() -> &'a BlockMetricsResponse {
        <BlockMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BlockMetricsResponse {
    pub fn new() -> BlockMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockMetricsResponse>(
            "BlockMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockMetricsResponse {
    const NAME: &'static str = "BlockMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockMetricsResponse {
        BlockMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockMetricsResponse {
        static instance: BlockMetricsResponse = BlockMetricsResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetAllowlistRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAllowlistRequest {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetAllowlistRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllowlistRequest {
    fn default() -> &'a GetAllowlistRequest {
        <GetAllowlistRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAllowlistRequest {
    pub fn new() -> GetAllowlistRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllowlistRequest>(
            "GetAllowlistRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllowlistRequest {
    const NAME: &'static str = "GetAllowlistRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllowlistRequest {
        GetAllowlistRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllowlistRequest {
        static instance: GetAllowlistRequest = GetAllowlistRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllowlistRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllowlistRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllowlistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllowlistRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetAllowlistResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAllowlistResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetAllowlistResponse.matcher)
    pub matcher: ::std::vec::Vec<Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetAllowlistResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAllowlistResponse {
    fn default() -> &'a GetAllowlistResponse {
        <GetAllowlistResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAllowlistResponse {
    pub fn new() -> GetAllowlistResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matcher",
            |m: &GetAllowlistResponse| { &m.matcher },
            |m: &mut GetAllowlistResponse| { &mut m.matcher },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAllowlistResponse>(
            "GetAllowlistResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAllowlistResponse {
    const NAME: &'static str = "GetAllowlistResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matcher.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matcher {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.matcher {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAllowlistResponse {
        GetAllowlistResponse::new()
    }

    fn clear(&mut self) {
        self.matcher.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAllowlistResponse {
        static instance: GetAllowlistResponse = GetAllowlistResponse {
            matcher: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAllowlistResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAllowlistResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAllowlistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAllowlistResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllowMetricsByQueryRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryRequest.query)
    pub query: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllowMetricsByQueryRequest {
    fn default() -> &'a AllowMetricsByQueryRequest {
        <AllowMetricsByQueryRequest as ::protobuf::Message>::default_instance()
    }
}

impl AllowMetricsByQueryRequest {
    pub fn new() -> AllowMetricsByQueryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &AllowMetricsByQueryRequest| { &m.query },
            |m: &mut AllowMetricsByQueryRequest| { &mut m.query },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllowMetricsByQueryRequest>(
            "AllowMetricsByQueryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllowMetricsByQueryRequest {
    const NAME: &'static str = "AllowMetricsByQueryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.query = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllowMetricsByQueryRequest {
        AllowMetricsByQueryRequest::new()
    }

    fn clear(&mut self) {
        self.query.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllowMetricsByQueryRequest {
        static instance: AllowMetricsByQueryRequest = AllowMetricsByQueryRequest {
            query: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllowMetricsByQueryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllowMetricsByQueryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllowMetricsByQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowMetricsByQueryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllowMetricsByQueryResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllowMetricsByQueryResponse {
    fn default() -> &'a AllowMetricsByQueryResponse {
        <AllowMetricsByQueryResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllowMetricsByQueryResponse {
    pub fn new() -> AllowMetricsByQueryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllowMetricsByQueryResponse>(
            "AllowMetricsByQueryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllowMetricsByQueryResponse {
    const NAME: &'static str = "AllowMetricsByQueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllowMetricsByQueryResponse {
        AllowMetricsByQueryResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllowMetricsByQueryResponse {
        static instance: AllowMetricsByQueryResponse = AllowMetricsByQueryResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllowMetricsByQueryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllowMetricsByQueryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllowMetricsByQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowMetricsByQueryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetMetricsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMetricsRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.matcher)
    pub matcher: ::protobuf::MessageField<Matcher>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.query)
    pub query: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.page_size)
    pub page_size: u64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.page_offset)
    pub page_offset: u64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.blocklist_filter)
    pub blocklist_filter: ::protobuf::EnumOrUnknown<get_metrics_request::BlocklistFilter>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.search_type)
    pub search_type: ::protobuf::EnumOrUnknown<get_metrics_request::SearchType>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMetricsRequest {
    fn default() -> &'a GetMetricsRequest {
        <GetMetricsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMetricsRequest {
    pub fn new() -> GetMetricsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Matcher>(
            "matcher",
            |m: &GetMetricsRequest| { &m.matcher },
            |m: &mut GetMetricsRequest| { &mut m.matcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &GetMetricsRequest| { &m.query },
            |m: &mut GetMetricsRequest| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_size",
            |m: &GetMetricsRequest| { &m.page_size },
            |m: &mut GetMetricsRequest| { &mut m.page_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page_offset",
            |m: &GetMetricsRequest| { &m.page_offset },
            |m: &mut GetMetricsRequest| { &mut m.page_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blocklist_filter",
            |m: &GetMetricsRequest| { &m.blocklist_filter },
            |m: &mut GetMetricsRequest| { &mut m.blocklist_filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_type",
            |m: &GetMetricsRequest| { &m.search_type },
            |m: &mut GetMetricsRequest| { &mut m.search_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetMetricsRequest>(
            "GetMetricsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetMetricsRequest {
    const NAME: &'static str = "GetMetricsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.matcher)?;
                },
                50 => {
                    self.query = is.read_string()?;
                },
                16 => {
                    self.page_size = is.read_uint64()?;
                },
                24 => {
                    self.page_offset = is.read_uint64()?;
                },
                32 => {
                    self.blocklist_filter = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.search_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.query);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.page_size);
        }
        if self.page_offset != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.page_offset);
        }
        if self.blocklist_filter != ::protobuf::EnumOrUnknown::new(get_metrics_request::BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.blocklist_filter.value());
        }
        if self.search_type != ::protobuf::EnumOrUnknown::new(get_metrics_request::SearchType::SEARCH_TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(5, self.search_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.query.is_empty() {
            os.write_string(6, &self.query)?;
        }
        if self.page_size != 0 {
            os.write_uint64(2, self.page_size)?;
        }
        if self.page_offset != 0 {
            os.write_uint64(3, self.page_offset)?;
        }
        if self.blocklist_filter != ::protobuf::EnumOrUnknown::new(get_metrics_request::BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.blocklist_filter))?;
        }
        if self.search_type != ::protobuf::EnumOrUnknown::new(get_metrics_request::SearchType::SEARCH_TYPE_UNKNOWN) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.search_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMetricsRequest {
        GetMetricsRequest::new()
    }

    fn clear(&mut self) {
        self.matcher.clear();
        self.query.clear();
        self.page_size = 0;
        self.page_offset = 0;
        self.blocklist_filter = ::protobuf::EnumOrUnknown::new(get_metrics_request::BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN);
        self.search_type = ::protobuf::EnumOrUnknown::new(get_metrics_request::SearchType::SEARCH_TYPE_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMetricsRequest {
        static instance: GetMetricsRequest = GetMetricsRequest {
            matcher: ::protobuf::MessageField::none(),
            query: ::std::string::String::new(),
            page_size: 0,
            page_offset: 0,
            blocklist_filter: ::protobuf::EnumOrUnknown::from_i32(0),
            search_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetMetricsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetMetricsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetMetricsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMetricsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GetMetricsRequest`
pub mod get_metrics_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.BlocklistFilter)
    pub enum BlocklistFilter {
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.BlocklistFilter.BLOCKLIST_FILTER_UNKNOWN)
        BLOCKLIST_FILTER_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.BlocklistFilter.BLOCKLIST_FILTER_ALL)
        BLOCKLIST_FILTER_ALL = 1,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.BlocklistFilter.BLOCKLIST_FILTER_BLOCKED_ONLY)
        BLOCKLIST_FILTER_BLOCKED_ONLY = 2,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.BlocklistFilter.BLOCKLIST_FILTER_ALLOWED_ONLY)
        BLOCKLIST_FILTER_ALLOWED_ONLY = 3,
    }

    impl ::protobuf::Enum for BlocklistFilter {
        const NAME: &'static str = "BlocklistFilter";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<BlocklistFilter> {
            match value {
                0 => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN),
                1 => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_ALL),
                2 => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_BLOCKED_ONLY),
                3 => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_ALLOWED_ONLY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<BlocklistFilter> {
            match str {
                "BLOCKLIST_FILTER_UNKNOWN" => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN),
                "BLOCKLIST_FILTER_ALL" => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_ALL),
                "BLOCKLIST_FILTER_BLOCKED_ONLY" => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_BLOCKED_ONLY),
                "BLOCKLIST_FILTER_ALLOWED_ONLY" => ::std::option::Option::Some(BlocklistFilter::BLOCKLIST_FILTER_ALLOWED_ONLY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [BlocklistFilter] = &[
            BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN,
            BlocklistFilter::BLOCKLIST_FILTER_ALL,
            BlocklistFilter::BLOCKLIST_FILTER_BLOCKED_ONLY,
            BlocklistFilter::BLOCKLIST_FILTER_ALLOWED_ONLY,
        ];
    }

    impl ::protobuf::EnumFull for BlocklistFilter {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetMetricsRequest.BlocklistFilter").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for BlocklistFilter {
        fn default() -> Self {
            BlocklistFilter::BLOCKLIST_FILTER_UNKNOWN
        }
    }

    impl BlocklistFilter {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BlocklistFilter>("GetMetricsRequest.BlocklistFilter")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType)
    pub enum SearchType {
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType.SEARCH_TYPE_UNKNOWN)
        SEARCH_TYPE_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType.SEARCH_TYPE_ANALYZED)
        SEARCH_TYPE_ANALYZED = 1,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType.SEARCH_TYPE_REGEX)
        SEARCH_TYPE_REGEX = 2,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType.SEARCH_TYPE_PROMQL)
        SEARCH_TYPE_PROMQL = 3,
    }

    impl ::protobuf::Enum for SearchType {
        const NAME: &'static str = "SearchType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SearchType> {
            match value {
                0 => ::std::option::Option::Some(SearchType::SEARCH_TYPE_UNKNOWN),
                1 => ::std::option::Option::Some(SearchType::SEARCH_TYPE_ANALYZED),
                2 => ::std::option::Option::Some(SearchType::SEARCH_TYPE_REGEX),
                3 => ::std::option::Option::Some(SearchType::SEARCH_TYPE_PROMQL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SearchType> {
            match str {
                "SEARCH_TYPE_UNKNOWN" => ::std::option::Option::Some(SearchType::SEARCH_TYPE_UNKNOWN),
                "SEARCH_TYPE_ANALYZED" => ::std::option::Option::Some(SearchType::SEARCH_TYPE_ANALYZED),
                "SEARCH_TYPE_REGEX" => ::std::option::Option::Some(SearchType::SEARCH_TYPE_REGEX),
                "SEARCH_TYPE_PROMQL" => ::std::option::Option::Some(SearchType::SEARCH_TYPE_PROMQL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SearchType] = &[
            SearchType::SEARCH_TYPE_UNKNOWN,
            SearchType::SEARCH_TYPE_ANALYZED,
            SearchType::SEARCH_TYPE_REGEX,
            SearchType::SEARCH_TYPE_PROMQL,
        ];
    }

    impl ::protobuf::EnumFull for SearchType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("GetMetricsRequest.SearchType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SearchType {
        fn default() -> Self {
            SearchType::SEARCH_TYPE_UNKNOWN
        }
    }

    impl SearchType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SearchType>("GetMetricsRequest.SearchType")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.GetMetricsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetMetricsResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsResponse.metrics)
    pub metrics: ::std::vec::Vec<Metric>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.GetMetricsResponse.total_num_metrics)
    pub total_num_metrics: u64,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.GetMetricsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetMetricsResponse {
    fn default() -> &'a GetMetricsResponse {
        <GetMetricsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMetricsResponse {
    pub fn new() -> GetMetricsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &GetMetricsResponse| { &m.metrics },
            |m: &mut GetMetricsResponse| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_num_metrics",
            |m: &GetMetricsResponse| { &m.total_num_metrics },
            |m: &mut GetMetricsResponse| { &mut m.total_num_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetMetricsResponse>(
            "GetMetricsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetMetricsResponse {
    const NAME: &'static str = "GetMetricsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.metrics.push(is.read_message()?);
                },
                16 => {
                    self.total_num_metrics = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total_num_metrics != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.total_num_metrics);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.total_num_metrics != 0 {
            os.write_uint64(2, self.total_num_metrics)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetMetricsResponse {
        GetMetricsResponse::new()
    }

    fn clear(&mut self) {
        self.metrics.clear();
        self.total_num_metrics = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetMetricsResponse {
        static instance: GetMetricsResponse = GetMetricsResponse {
            metrics: ::std::vec::Vec::new(),
            total_num_metrics: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetMetricsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetMetricsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetMetricsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMetricsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.TypeaheadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeaheadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.TypeaheadRequest.prefix)
    pub prefix: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.TypeaheadRequest.page_size)
    pub page_size: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.TypeaheadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeaheadRequest {
    fn default() -> &'a TypeaheadRequest {
        <TypeaheadRequest as ::protobuf::Message>::default_instance()
    }
}

impl TypeaheadRequest {
    pub fn new() -> TypeaheadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &TypeaheadRequest| { &m.prefix },
            |m: &mut TypeaheadRequest| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "page_size",
            |m: &TypeaheadRequest| { &m.page_size },
            |m: &mut TypeaheadRequest| { &mut m.page_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeaheadRequest>(
            "TypeaheadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeaheadRequest {
    const NAME: &'static str = "TypeaheadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prefix = is.read_string()?;
                },
                16 => {
                    self.page_size = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if let Some(v) = self.page_size {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if let Some(v) = self.page_size {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeaheadRequest {
        TypeaheadRequest::new()
    }

    fn clear(&mut self) {
        self.prefix.clear();
        self.page_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeaheadRequest {
        static instance: TypeaheadRequest = TypeaheadRequest {
            prefix: ::std::string::String::new(),
            page_size: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeaheadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeaheadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeaheadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeaheadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.TypeaheadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TypeaheadResponse {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.TypeaheadResponse.namespace_query)
    pub namespace_query: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.TypeaheadResponse.suggestions)
    pub suggestions: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.TypeaheadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TypeaheadResponse {
    fn default() -> &'a TypeaheadResponse {
        <TypeaheadResponse as ::protobuf::Message>::default_instance()
    }
}

impl TypeaheadResponse {
    pub fn new() -> TypeaheadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "namespace_query",
            |m: &TypeaheadResponse| { &m.namespace_query },
            |m: &mut TypeaheadResponse| { &mut m.namespace_query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "suggestions",
            |m: &TypeaheadResponse| { &m.suggestions },
            |m: &mut TypeaheadResponse| { &mut m.suggestions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeaheadResponse>(
            "TypeaheadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TypeaheadResponse {
    const NAME: &'static str = "TypeaheadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.namespace_query = is.read_string()?;
                },
                18 => {
                    self.suggestions.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.namespace_query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.namespace_query);
        }
        for value in &self.suggestions {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.namespace_query.is_empty() {
            os.write_string(1, &self.namespace_query)?;
        }
        for v in &self.suggestions {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TypeaheadResponse {
        TypeaheadResponse::new()
    }

    fn clear(&mut self) {
        self.namespace_query.clear();
        self.suggestions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TypeaheadResponse {
        static instance: TypeaheadResponse = TypeaheadResponse {
            namespace_query: ::std::string::String::new(),
            suggestions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TypeaheadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TypeaheadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TypeaheadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeaheadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.QueryMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QueryMetadata {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.query)
    pub query: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.source_type)
    pub source_type: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.latency)
    pub latency: f32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.returns_data)
    pub returns_data: bool,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.time_out)
    pub time_out: bool,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.is_error)
    pub is_error: bool,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.query_start)
    pub query_start: i64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.query_end)
    pub query_end: i64,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.num_data_points)
    pub num_data_points: i32,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.QueryMetadata.timestamp)
    pub timestamp: i64,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.QueryMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QueryMetadata {
    fn default() -> &'a QueryMetadata {
        <QueryMetadata as ::protobuf::Message>::default_instance()
    }
}

impl QueryMetadata {
    pub fn new() -> QueryMetadata {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query",
            |m: &QueryMetadata| { &m.query },
            |m: &mut QueryMetadata| { &mut m.query },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_type",
            |m: &QueryMetadata| { &m.source_type },
            |m: &mut QueryMetadata| { &mut m.source_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &QueryMetadata| { &m.source },
            |m: &mut QueryMetadata| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latency",
            |m: &QueryMetadata| { &m.latency },
            |m: &mut QueryMetadata| { &mut m.latency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "returns_data",
            |m: &QueryMetadata| { &m.returns_data },
            |m: &mut QueryMetadata| { &mut m.returns_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time_out",
            |m: &QueryMetadata| { &m.time_out },
            |m: &mut QueryMetadata| { &mut m.time_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_error",
            |m: &QueryMetadata| { &m.is_error },
            |m: &mut QueryMetadata| { &mut m.is_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query_start",
            |m: &QueryMetadata| { &m.query_start },
            |m: &mut QueryMetadata| { &mut m.query_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "query_end",
            |m: &QueryMetadata| { &m.query_end },
            |m: &mut QueryMetadata| { &mut m.query_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_data_points",
            |m: &QueryMetadata| { &m.num_data_points },
            |m: &mut QueryMetadata| { &mut m.num_data_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &QueryMetadata| { &m.timestamp },
            |m: &mut QueryMetadata| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QueryMetadata>(
            "QueryMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QueryMetadata {
    const NAME: &'static str = "QueryMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.query = is.read_string()?;
                },
                18 => {
                    self.source_type = is.read_string()?;
                },
                26 => {
                    self.source = is.read_string()?;
                },
                37 => {
                    self.latency = is.read_float()?;
                },
                40 => {
                    self.returns_data = is.read_bool()?;
                },
                48 => {
                    self.time_out = is.read_bool()?;
                },
                56 => {
                    self.is_error = is.read_bool()?;
                },
                64 => {
                    self.query_start = is.read_int64()?;
                },
                72 => {
                    self.query_end = is.read_int64()?;
                },
                80 => {
                    self.num_data_points = is.read_int32()?;
                },
                88 => {
                    self.timestamp = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if !self.source_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source_type);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if self.latency != 0. {
            my_size += 1 + 4;
        }
        if self.returns_data != false {
            my_size += 1 + 1;
        }
        if self.time_out != false {
            my_size += 1 + 1;
        }
        if self.is_error != false {
            my_size += 1 + 1;
        }
        if self.query_start != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.query_start);
        }
        if self.query_end != 0 {
            my_size += ::protobuf::rt::int64_size(9, self.query_end);
        }
        if self.num_data_points != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.num_data_points);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if !self.source_type.is_empty() {
            os.write_string(2, &self.source_type)?;
        }
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if self.latency != 0. {
            os.write_float(4, self.latency)?;
        }
        if self.returns_data != false {
            os.write_bool(5, self.returns_data)?;
        }
        if self.time_out != false {
            os.write_bool(6, self.time_out)?;
        }
        if self.is_error != false {
            os.write_bool(7, self.is_error)?;
        }
        if self.query_start != 0 {
            os.write_int64(8, self.query_start)?;
        }
        if self.query_end != 0 {
            os.write_int64(9, self.query_end)?;
        }
        if self.num_data_points != 0 {
            os.write_int32(10, self.num_data_points)?;
        }
        if self.timestamp != 0 {
            os.write_int64(11, self.timestamp)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QueryMetadata {
        QueryMetadata::new()
    }

    fn clear(&mut self) {
        self.query.clear();
        self.source_type.clear();
        self.source.clear();
        self.latency = 0.;
        self.returns_data = false;
        self.time_out = false;
        self.is_error = false;
        self.query_start = 0;
        self.query_end = 0;
        self.num_data_points = 0;
        self.timestamp = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QueryMetadata {
        static instance: QueryMetadata = QueryMetadata {
            query: ::std::string::String::new(),
            source_type: ::std::string::String::new(),
            source: ::std::string::String::new(),
            latency: 0.,
            returns_data: false,
            time_out: false,
            is_error: false,
            query_start: 0,
            query_end: 0,
            num_data_points: 0,
            timestamp: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QueryMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QueryMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QueryMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BulkUpdateLastReadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkUpdateLastReadRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.BulkUpdateLastReadRequest.queries)
    pub queries: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BulkUpdateLastReadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkUpdateLastReadRequest {
    fn default() -> &'a BulkUpdateLastReadRequest {
        <BulkUpdateLastReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl BulkUpdateLastReadRequest {
    pub fn new() -> BulkUpdateLastReadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queries",
            |m: &BulkUpdateLastReadRequest| { &m.queries },
            |m: &mut BulkUpdateLastReadRequest| { &mut m.queries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkUpdateLastReadRequest>(
            "BulkUpdateLastReadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkUpdateLastReadRequest {
    const NAME: &'static str = "BulkUpdateLastReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.queries.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.queries {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.queries {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkUpdateLastReadRequest {
        BulkUpdateLastReadRequest::new()
    }

    fn clear(&mut self) {
        self.queries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkUpdateLastReadRequest {
        static instance: BulkUpdateLastReadRequest = BulkUpdateLastReadRequest {
            queries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkUpdateLastReadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkUpdateLastReadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkUpdateLastReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkUpdateLastReadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BulkUpdateLastReadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkUpdateLastReadResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BulkUpdateLastReadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkUpdateLastReadResponse {
    fn default() -> &'a BulkUpdateLastReadResponse {
        <BulkUpdateLastReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl BulkUpdateLastReadResponse {
    pub fn new() -> BulkUpdateLastReadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkUpdateLastReadResponse>(
            "BulkUpdateLastReadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkUpdateLastReadResponse {
    const NAME: &'static str = "BulkUpdateLastReadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkUpdateLastReadResponse {
        BulkUpdateLastReadResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkUpdateLastReadResponse {
        static instance: BulkUpdateLastReadResponse = BulkUpdateLastReadResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkUpdateLastReadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkUpdateLastReadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkUpdateLastReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkUpdateLastReadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BulkUpdateQueriesMetadataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkUpdateQueriesMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.mme.v1.BulkUpdateQueriesMetadataRequest.queries_metadata)
    pub queries_metadata: ::std::vec::Vec<QueryMetadata>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BulkUpdateQueriesMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkUpdateQueriesMetadataRequest {
    fn default() -> &'a BulkUpdateQueriesMetadataRequest {
        <BulkUpdateQueriesMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl BulkUpdateQueriesMetadataRequest {
    pub fn new() -> BulkUpdateQueriesMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "queries_metadata",
            |m: &BulkUpdateQueriesMetadataRequest| { &m.queries_metadata },
            |m: &mut BulkUpdateQueriesMetadataRequest| { &mut m.queries_metadata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkUpdateQueriesMetadataRequest>(
            "BulkUpdateQueriesMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkUpdateQueriesMetadataRequest {
    const NAME: &'static str = "BulkUpdateQueriesMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.queries_metadata.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.queries_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.queries_metadata {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkUpdateQueriesMetadataRequest {
        BulkUpdateQueriesMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.queries_metadata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkUpdateQueriesMetadataRequest {
        static instance: BulkUpdateQueriesMetadataRequest = BulkUpdateQueriesMetadataRequest {
            queries_metadata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkUpdateQueriesMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkUpdateQueriesMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkUpdateQueriesMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkUpdateQueriesMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.mme.v1.BulkUpdateQueriesMetadataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BulkUpdateQueriesMetadataResponse {
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.mme.v1.BulkUpdateQueriesMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BulkUpdateQueriesMetadataResponse {
    fn default() -> &'a BulkUpdateQueriesMetadataResponse {
        <BulkUpdateQueriesMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl BulkUpdateQueriesMetadataResponse {
    pub fn new() -> BulkUpdateQueriesMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BulkUpdateQueriesMetadataResponse>(
            "BulkUpdateQueriesMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BulkUpdateQueriesMetadataResponse {
    const NAME: &'static str = "BulkUpdateQueriesMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BulkUpdateQueriesMetadataResponse {
        BulkUpdateQueriesMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BulkUpdateQueriesMetadataResponse {
        static instance: BulkUpdateQueriesMetadataResponse = BulkUpdateQueriesMetadataResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BulkUpdateQueriesMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BulkUpdateQueriesMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BulkUpdateQueriesMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulkUpdateQueriesMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n-bitdrift_public/protobuf/mme/v1/service.proto\x12\x1fbitdrift_public.\
    protobuf.mme.v1\x1a\x1acommon/protobuf/http.proto\"\xb1\x03\n\x06Metric\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12M\n\x0bannotations\x18\
    \x02\x20\x03(\x0b2+.bitdrift_public.protobuf.mme.v1.AnnotationR\x0bannot\
    ations\x12'\n\x0fallowlist_rules\x18\x08\x20\x03(\tR\x0eallowlistRules\
    \x12%\n\x0cfirst_read_s\x18\t\x20\x01(\x03H\0R\nfirstReadS\x88\x01\x01\
    \x12#\n\x0blast_read_s\x18\n\x20\x01(\x03H\x01R\tlastReadS\x88\x01\x01\
    \x12&\n\x0ffirst_written_s\x18\x0b\x20\x01(\x03R\rfirstWrittenS\x12$\n\
    \x0elast_written_s\x18\x0c\x20\x01(\x03R\x0clastWrittenS\x12-\n\x10block\
    listed_at_s\x18\r\x20\x01(\x03H\x02R\x0eblocklistedAtS\x88\x01\x01B\x0f\
    \n\r_first_read_sB\x0e\n\x0c_last_read_sB\x13\n\x11_blocklisted_at_sJ\
    \x04\x08\x03\x10\x04J\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\
    \x06\x10\x07J\x04\x08\x07\x10\x08\"4\n\nAnnotation\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \"\x98\x02\n\x0cLabelMatcher\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05l\
    abel\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12V\n\nmatch_type\
    \x18\x03\x20\x01(\x0e27.bitdrift_public.protobuf.mme.v1.LabelMatcher.Mat\
    chTypeR\tmatchType\"\x83\x01\n\tMatchType\x12\x16\n\x12MATCH_TYPE_UNKNOW\
    N\x10\0\x12\x14\n\x10MATCH_TYPE_EQUAL\x10\x01\x12\x18\n\x14MATCH_TYPE_NO\
    T_EQUAL\x10\x02\x12\x14\n\x10MATCH_TYPE_REGEX\x10\x03\x12\x18\n\x14MATCH\
    _TYPE_NOT_REGEX\x10\x04\"_\n\x07Matcher\x12T\n\x0elabel_matchers\x18\x01\
    \x20\x03(\x0b2-.bitdrift_public.protobuf.mme.v1.LabelMatcherR\rlabelMatc\
    hers\"S\n\x0bMatcherList\x12D\n\x08matchers\x18\x01\x20\x03(\x0b2(.bitdr\
    ift_public.protobuf.mme.v1.MatcherR\x08matchers\"\xbe\x01\n\x13GetBlockl\
    istRequest\x12B\n\x07matcher\x18\x01\x20\x01(\x0b2(.bitdrift_public.prot\
    obuf.mme.v1.MatcherR\x07matcher\x12\x1b\n\tpage_size\x18\x02\x20\x01(\
    \x04R\x08pageSize\x12\x1f\n\x0bpage_offset\x18\x03\x20\x01(\x04R\npageOf\
    fset\x12%\n\x0einclude_source\x18\x04\x20\x01(\x08R\rincludeSource\"Y\n\
    \x14GetBlocklistResponse\x12A\n\x07metrics\x18\x01\x20\x03(\x0b2'.bitdri\
    ft_public.protobuf.mme.v1.MetricR\x07metrics\"z\n\x13AllowMetricsRequest\
    \x12B\n\x07matcher\x18\x01\x20\x01(\x0b2(.bitdrift_public.protobuf.mme.v\
    1.MatcherR\x07matcher\x12\x1f\n\x0ballow_regex\x18\x02\x20\x01(\x08R\nal\
    lowRegex\"\x16\n\x14AllowMetricsResponse\"Y\n\x13BlockMetricsRequest\x12\
    B\n\x07matcher\x18\x01\x20\x01(\x0b2(.bitdrift_public.protobuf.mme.v1.Ma\
    tcherR\x07matcher\"\x16\n\x14BlockMetricsResponse\"\x15\n\x13GetAllowlis\
    tRequest\"Z\n\x14GetAllowlistResponse\x12B\n\x07matcher\x18\x01\x20\x03(\
    \x0b2(.bitdrift_public.protobuf.mme.v1.MatcherR\x07matcher\"2\n\x1aAllow\
    MetricsByQueryRequest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"\
    \x1d\n\x1bAllowMetricsByQueryResponse\"\xfc\x04\n\x11GetMetricsRequest\
    \x12B\n\x07matcher\x18\x01\x20\x01(\x0b2(.bitdrift_public.protobuf.mme.v\
    1.MatcherR\x07matcher\x12\x14\n\x05query\x18\x06\x20\x01(\tR\x05query\
    \x12\x1b\n\tpage_size\x18\x02\x20\x01(\x04R\x08pageSize\x12\x1f\n\x0bpag\
    e_offset\x18\x03\x20\x01(\x04R\npageOffset\x12m\n\x10blocklist_filter\
    \x18\x04\x20\x01(\x0e2B.bitdrift_public.protobuf.mme.v1.GetMetricsReques\
    t.BlocklistFilterR\x0fblocklistFilter\x12^\n\x0bsearch_type\x18\x05\x20\
    \x01(\x0e2=.bitdrift_public.protobuf.mme.v1.GetMetricsRequest.SearchType\
    R\nsearchType\"\x8f\x01\n\x0fBlocklistFilter\x12\x1c\n\x18BLOCKLIST_FILT\
    ER_UNKNOWN\x10\0\x12\x18\n\x14BLOCKLIST_FILTER_ALL\x10\x01\x12!\n\x1dBLO\
    CKLIST_FILTER_BLOCKED_ONLY\x10\x02\x12!\n\x1dBLOCKLIST_FILTER_ALLOWED_ON\
    LY\x10\x03\"n\n\nSearchType\x12\x17\n\x13SEARCH_TYPE_UNKNOWN\x10\0\x12\
    \x18\n\x14SEARCH_TYPE_ANALYZED\x10\x01\x12\x15\n\x11SEARCH_TYPE_REGEX\
    \x10\x02\x12\x16\n\x12SEARCH_TYPE_PROMQL\x10\x03\"\x83\x01\n\x12GetMetri\
    csResponse\x12A\n\x07metrics\x18\x01\x20\x03(\x0b2'.bitdrift_public.prot\
    obuf.mme.v1.MetricR\x07metrics\x12*\n\x11total_num_metrics\x18\x02\x20\
    \x01(\x04R\x0ftotalNumMetrics\"Z\n\x10TypeaheadRequest\x12\x16\n\x06pref\
    ix\x18\x01\x20\x01(\tR\x06prefix\x12\x20\n\tpage_size\x18\x02\x20\x01(\
    \x04H\0R\x08pageSize\x88\x01\x01B\x0c\n\n_page_size\"^\n\x11TypeaheadRes\
    ponse\x12'\n\x0fnamespace_query\x18\x01\x20\x01(\tR\x0enamespaceQuery\
    \x12\x20\n\x0bsuggestions\x18\x02\x20\x03(\tR\x0bsuggestions\"\xd5\x02\n\
    \rQueryMetadata\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x12\x1f\
    \n\x0bsource_type\x18\x02\x20\x01(\tR\nsourceType\x12\x16\n\x06source\
    \x18\x03\x20\x01(\tR\x06source\x12\x18\n\x07latency\x18\x04\x20\x01(\x02\
    R\x07latency\x12!\n\x0creturns_data\x18\x05\x20\x01(\x08R\x0breturnsData\
    \x12\x19\n\x08time_out\x18\x06\x20\x01(\x08R\x07timeOut\x12\x19\n\x08is_\
    error\x18\x07\x20\x01(\x08R\x07isError\x12\x1f\n\x0bquery_start\x18\x08\
    \x20\x01(\x03R\nqueryStart\x12\x1b\n\tquery_end\x18\t\x20\x01(\x03R\x08q\
    ueryEnd\x12&\n\x0fnum_data_points\x18\n\x20\x01(\x05R\rnumDataPoints\x12\
    \x1c\n\ttimestamp\x18\x0b\x20\x01(\x03R\ttimestamp\"5\n\x19BulkUpdateLas\
    tReadRequest\x12\x18\n\x07queries\x18\x01\x20\x03(\tR\x07queries\"\x1c\n\
    \x1aBulkUpdateLastReadResponse\"}\n\x20BulkUpdateQueriesMetadataRequest\
    \x12Y\n\x10queries_metadata\x18\x01\x20\x03(\x0b2..bitdrift_public.proto\
    buf.mme.v1.QueryMetadataR\x0fqueriesMetadata\"#\n!BulkUpdateQueriesMetad\
    ataResponse2\xe8\t\n\x16MetricsDiscoveryEngine\x12}\n\x0cGetBlocklist\
    \x124.bitdrift_public.protobuf.mme.v1.GetBlocklistRequest\x1a5.bitdrift_\
    public.protobuf.mme.v1.GetBlocklistResponse\"\0\x12}\n\x0cAllowMetrics\
    \x124.bitdrift_public.protobuf.mme.v1.AllowMetricsRequest\x1a5.bitdrift_\
    public.protobuf.mme.v1.AllowMetricsResponse\"\0\x12}\n\x0cBlockMetrics\
    \x124.bitdrift_public.protobuf.mme.v1.BlockMetricsRequest\x1a5.bitdrift_\
    public.protobuf.mme.v1.BlockMetricsResponse\"\0\x12}\n\x0cGetAllowlist\
    \x124.bitdrift_public.protobuf.mme.v1.GetAllowlistRequest\x1a5.bitdrift_\
    public.protobuf.mme.v1.GetAllowlistResponse\"\0\x12\x92\x01\n\x13AllowMe\
    tricsByQuery\x12;.bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryReq\
    uest\x1a<.bitdrift_public.protobuf.mme.v1.AllowMetricsByQueryResponse\"\
    \0\x12w\n\nGetMetrics\x122.bitdrift_public.protobuf.mme.v1.GetMetricsReq\
    uest\x1a3.bitdrift_public.protobuf.mme.v1.GetMetricsResponse\"\0\x12\x8f\
    \x01\n\x12BulkUpdateLastRead\x12:.bitdrift_public.protobuf.mme.v1.BulkUp\
    dateLastReadRequest\x1a;.bitdrift_public.protobuf.mme.v1.BulkUpdateLastR\
    eadResponse\"\0\x12\xa4\x01\n\x19BulkUpdateQueriesMetadata\x12A.bitdrift\
    _public.protobuf.mme.v1.BulkUpdateQueriesMetadataRequest\x1aB.bitdrift_p\
    ublic.protobuf.mme.v1.BulkUpdateQueriesMetadataResponse\"\0\x12\x82\x01\
    \n\x17GetTypeaheadSuggestions\x121.bitdrift_public.protobuf.mme.v1.Typea\
    headRequest\x1a2.bitdrift_public.protobuf.mme.v1.TypeaheadResponse\"\0\
    \x1a\x06\x92\xb5\x18\x020\x02b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::http::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(24);
            messages.push(Metric::generated_message_descriptor_data());
            messages.push(Annotation::generated_message_descriptor_data());
            messages.push(LabelMatcher::generated_message_descriptor_data());
            messages.push(Matcher::generated_message_descriptor_data());
            messages.push(MatcherList::generated_message_descriptor_data());
            messages.push(GetBlocklistRequest::generated_message_descriptor_data());
            messages.push(GetBlocklistResponse::generated_message_descriptor_data());
            messages.push(AllowMetricsRequest::generated_message_descriptor_data());
            messages.push(AllowMetricsResponse::generated_message_descriptor_data());
            messages.push(BlockMetricsRequest::generated_message_descriptor_data());
            messages.push(BlockMetricsResponse::generated_message_descriptor_data());
            messages.push(GetAllowlistRequest::generated_message_descriptor_data());
            messages.push(GetAllowlistResponse::generated_message_descriptor_data());
            messages.push(AllowMetricsByQueryRequest::generated_message_descriptor_data());
            messages.push(AllowMetricsByQueryResponse::generated_message_descriptor_data());
            messages.push(GetMetricsRequest::generated_message_descriptor_data());
            messages.push(GetMetricsResponse::generated_message_descriptor_data());
            messages.push(TypeaheadRequest::generated_message_descriptor_data());
            messages.push(TypeaheadResponse::generated_message_descriptor_data());
            messages.push(QueryMetadata::generated_message_descriptor_data());
            messages.push(BulkUpdateLastReadRequest::generated_message_descriptor_data());
            messages.push(BulkUpdateLastReadResponse::generated_message_descriptor_data());
            messages.push(BulkUpdateQueriesMetadataRequest::generated_message_descriptor_data());
            messages.push(BulkUpdateQueriesMetadataResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(label_matcher::MatchType::generated_enum_descriptor_data());
            enums.push(get_metrics_request::BlocklistFilter::generated_enum_descriptor_data());
            enums.push(get_metrics_request::SearchType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
