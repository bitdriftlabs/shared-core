// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 33.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/config/v1/config.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogMatcher {
    // message oneof groups
    pub match_type: ::std::option::Option<log_matcher::Match_type>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogMatcher {
    fn default() -> &'a LogMatcher {
        <LogMatcher as ::protobuf::Message>::default_instance()
    }
}

impl LogMatcher {
    pub fn new() -> LogMatcher {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher base_matcher = 1;

    pub fn base_matcher(&self) -> &log_matcher::BaseLogMatcher {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(ref v)) => v,
            _ => <log_matcher::BaseLogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_base_matcher(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_base_matcher(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_base_matcher(&mut self, v: log_matcher::BaseLogMatcher) {
        self.match_type = ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_base_matcher(&mut self) -> &mut log_matcher::BaseLogMatcher {
        if let ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(log_matcher::BaseLogMatcher::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_base_matcher(&mut self) -> log_matcher::BaseLogMatcher {
        if self.has_base_matcher() {
            match self.match_type.take() {
                ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::BaseLogMatcher::new()
        }
    }

    // .bitdrift_public.protobuf.config.v1.LogMatcher.MatcherList or_matcher = 2;

    pub fn or_matcher(&self) -> &log_matcher::MatcherList {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_or_matcher(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_or_matcher(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_matcher(&mut self, v: log_matcher::MatcherList) {
        self.match_type = ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(log_matcher::MatcherList::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_or_matcher() {
            match self.match_type.take() {
                ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.config.v1.LogMatcher.MatcherList and_matcher = 3;

    pub fn and_matcher(&self) -> &log_matcher::MatcherList {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_and_matcher(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_and_matcher(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_matcher(&mut self, v: log_matcher::MatcherList) {
        self.match_type = ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(log_matcher::MatcherList::new()));
        }
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_and_matcher() {
            match self.match_type.take() {
                ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.config.v1.LogMatcher not_matcher = 4;

    pub fn not_matcher(&self) -> &LogMatcher {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(ref v)) => v,
            _ => <LogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_not_matcher(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_not_matcher(&self) -> bool {
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_matcher(&mut self, v: LogMatcher) {
        self.match_type = ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_matcher(&mut self) -> &mut LogMatcher {
        if let ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(_)) = self.match_type {
        } else {
            self.match_type = ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(::std::boxed::Box::new(LogMatcher::new())));
        }
        match self.match_type {
            ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_matcher(&mut self) -> LogMatcher {
        if self.has_not_matcher() {
            match self.match_type.take() {
                ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(v)) => *v,
                _ => panic!(),
            }
        } else {
            LogMatcher::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::BaseLogMatcher>(
            "base_matcher",
            LogMatcher::has_base_matcher,
            LogMatcher::base_matcher,
            LogMatcher::mut_base_matcher,
            LogMatcher::set_base_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "or_matcher",
            LogMatcher::has_or_matcher,
            LogMatcher::or_matcher,
            LogMatcher::mut_or_matcher,
            LogMatcher::set_or_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "and_matcher",
            LogMatcher::has_and_matcher,
            LogMatcher::and_matcher,
            LogMatcher::mut_and_matcher,
            LogMatcher::set_and_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogMatcher>(
            "not_matcher",
            LogMatcher::has_not_matcher,
            LogMatcher::not_matcher,
            LogMatcher::mut_not_matcher,
            LogMatcher::set_not_matcher,
        ));
        oneofs.push(log_matcher::Match_type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogMatcher>(
            "LogMatcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogMatcher {
    const NAME: &'static str = "LogMatcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.match_type = ::std::option::Option::Some(log_matcher::Match_type::BaseMatcher(is.read_message()?));
                },
                18 => {
                    self.match_type = ::std::option::Option::Some(log_matcher::Match_type::OrMatcher(is.read_message()?));
                },
                26 => {
                    self.match_type = ::std::option::Option::Some(log_matcher::Match_type::AndMatcher(is.read_message()?));
                },
                34 => {
                    self.match_type = ::std::option::Option::Some(log_matcher::Match_type::NotMatcher(::std::boxed::Box::new(is.read_message()?)));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.match_type {
            match v {
                &log_matcher::Match_type::BaseMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Match_type::OrMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Match_type::AndMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Match_type::NotMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.match_type {
            match v {
                &log_matcher::Match_type::BaseMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &log_matcher::Match_type::OrMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &log_matcher::Match_type::AndMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &log_matcher::Match_type::NotMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, &**v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogMatcher {
        LogMatcher::new()
    }

    fn clear(&mut self) {
        self.match_type = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogMatcher {
        static instance: LogMatcher = LogMatcher {
            match_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogMatcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogMatcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogMatcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogMatcher`
pub mod log_matcher {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.config.v1.LogMatcher.match_type)
    pub enum Match_type {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.base_matcher)
        BaseMatcher(BaseLogMatcher),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.or_matcher)
        OrMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.and_matcher)
        AndMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.not_matcher)
        NotMatcher(::std::boxed::Box<super::LogMatcher>),
    }

    impl ::protobuf::Oneof for Match_type {
    }

    impl ::protobuf::OneofFull for Match_type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("match_type").unwrap()).clone()
        }
    }

    impl Match_type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Match_type>("match_type")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BaseLogMatcher {
        // message oneof groups
        pub match_type: ::std::option::Option<base_log_matcher::Match_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BaseLogMatcher {
        fn default() -> &'a BaseLogMatcher {
            <BaseLogMatcher as ::protobuf::Message>::default_instance()
        }
    }

    impl BaseLogMatcher {
        pub fn new() -> BaseLogMatcher {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch log_level_match = 1;

        pub fn log_level_match(&self) -> &base_log_matcher::LogLevelMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(ref v)) => v,
                _ => <base_log_matcher::LogLevelMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_log_level_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_log_level_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_log_level_match(&mut self, v: base_log_matcher::LogLevelMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_log_level_match(&mut self) -> &mut base_log_matcher::LogLevelMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(base_log_matcher::LogLevelMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_log_level_match(&mut self) -> base_log_matcher::LogLevelMatch {
            if self.has_log_level_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::LogLevelMatch::new()
            }
        }

        // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.MessageMatch message_match = 2;

        pub fn message_match(&self) -> &base_log_matcher::MessageMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref v)) => v,
                _ => <base_log_matcher::MessageMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_message_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_message_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_message_match(&mut self, v: base_log_matcher::MessageMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_message_match(&mut self) -> &mut base_log_matcher::MessageMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(base_log_matcher::MessageMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_message_match(&mut self) -> base_log_matcher::MessageMatch {
            if self.has_message_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::MessageMatch::new()
            }
        }

        // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch tag_match = 3;

        pub fn tag_match(&self) -> &base_log_matcher::TagMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref v)) => v,
                _ => <base_log_matcher::TagMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_tag_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_tag_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_tag_match(&mut self, v: base_log_matcher::TagMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_tag_match(&mut self) -> &mut base_log_matcher::TagMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(base_log_matcher::TagMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_tag_match(&mut self) -> base_log_matcher::TagMatch {
            if self.has_tag_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::TagMatch::new()
            }
        }

        // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TypeMatch type_match = 5;

        pub fn type_match(&self) -> &base_log_matcher::TypeMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(ref v)) => v,
                _ => <base_log_matcher::TypeMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_type_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_type_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_type_match(&mut self, v: base_log_matcher::TypeMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_type_match(&mut self) -> &mut base_log_matcher::TypeMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(base_log_matcher::TypeMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_type_match(&mut self) -> base_log_matcher::TypeMatch {
            if self.has_type_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::TypeMatch::new()
            }
        }

        // .bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.AnyMatch any_match = 4;

        pub fn any_match(&self) -> &base_log_matcher::AnyMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(ref v)) => v,
                _ => <base_log_matcher::AnyMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_any_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_any_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_any_match(&mut self, v: base_log_matcher::AnyMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_any_match(&mut self) -> &mut base_log_matcher::AnyMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(base_log_matcher::AnyMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_any_match(&mut self) -> base_log_matcher::AnyMatch {
            if self.has_any_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::AnyMatch::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::LogLevelMatch>(
                "log_level_match",
                BaseLogMatcher::has_log_level_match,
                BaseLogMatcher::log_level_match,
                BaseLogMatcher::mut_log_level_match,
                BaseLogMatcher::set_log_level_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::MessageMatch>(
                "message_match",
                BaseLogMatcher::has_message_match,
                BaseLogMatcher::message_match,
                BaseLogMatcher::mut_message_match,
                BaseLogMatcher::set_message_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::TagMatch>(
                "tag_match",
                BaseLogMatcher::has_tag_match,
                BaseLogMatcher::tag_match,
                BaseLogMatcher::mut_tag_match,
                BaseLogMatcher::set_tag_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::TypeMatch>(
                "type_match",
                BaseLogMatcher::has_type_match,
                BaseLogMatcher::type_match,
                BaseLogMatcher::mut_type_match,
                BaseLogMatcher::set_type_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::AnyMatch>(
                "any_match",
                BaseLogMatcher::has_any_match,
                BaseLogMatcher::any_match,
                BaseLogMatcher::mut_any_match,
                BaseLogMatcher::set_any_match,
            ));
            oneofs.push(base_log_matcher::Match_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BaseLogMatcher>(
                "LogMatcher.BaseLogMatcher",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BaseLogMatcher {
        const NAME: &'static str = "BaseLogMatcher";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::LogLevelMatch(is.read_message()?));
                    },
                    18 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(is.read_message()?));
                    },
                    26 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(is.read_message()?));
                    },
                    42 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TypeMatch(is.read_message()?));
                    },
                    34 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::AnyMatch(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::LogLevelMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::TypeMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::AnyMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::LogLevelMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &base_log_matcher::Match_type::TypeMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                    &base_log_matcher::Match_type::AnyMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BaseLogMatcher {
            BaseLogMatcher::new()
        }

        fn clear(&mut self) {
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BaseLogMatcher {
            static instance: BaseLogMatcher = BaseLogMatcher {
                match_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BaseLogMatcher {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BaseLogMatcher {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BaseLogMatcher {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BaseLogMatcher`
    pub mod base_log_matcher {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.match_type)
        pub enum Match_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.log_level_match)
            LogLevelMatch(LogLevelMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.message_match)
            MessageMatch(MessageMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.tag_match)
            TagMatch(TagMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.type_match)
            TypeMatch(TypeMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.any_match)
            AnyMatch(AnyMatch),
        }

        impl ::protobuf::Oneof for Match_type {
        }

        impl ::protobuf::OneofFull for Match_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::BaseLogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("match_type").unwrap()).clone()
            }
        }

        impl Match_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Match_type>("match_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct LogLevelMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.operator)
            pub operator: ::protobuf::EnumOrUnknown<log_level_match::ComparisonOperator>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.log_level)
            pub log_level: ::protobuf::EnumOrUnknown<log_level_match::LogLevel>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LogLevelMatch {
            fn default() -> &'a LogLevelMatch {
                <LogLevelMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl LogLevelMatch {
            pub fn new() -> LogLevelMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "operator",
                    |m: &LogLevelMatch| { &m.operator },
                    |m: &mut LogLevelMatch| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "log_level",
                    |m: &LogLevelMatch| { &m.log_level },
                    |m: &mut LogLevelMatch| { &mut m.log_level },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogLevelMatch>(
                    "LogMatcher.BaseLogMatcher.LogLevelMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LogLevelMatch {
            const NAME: &'static str = "LogLevelMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.operator = is.read_enum_or_unknown()?;
                        },
                        16 => {
                            self.log_level = is.read_enum_or_unknown()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.operator != ::protobuf::EnumOrUnknown::new(log_level_match::ComparisonOperator::LESS_THAN) {
                    my_size += ::protobuf::rt::int32_size(1, self.operator.value());
                }
                if self.log_level != ::protobuf::EnumOrUnknown::new(log_level_match::LogLevel::TRACE) {
                    my_size += ::protobuf::rt::int32_size(2, self.log_level.value());
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.operator != ::protobuf::EnumOrUnknown::new(log_level_match::ComparisonOperator::LESS_THAN) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.operator))?;
                }
                if self.log_level != ::protobuf::EnumOrUnknown::new(log_level_match::LogLevel::TRACE) {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.log_level))?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LogLevelMatch {
                LogLevelMatch::new()
            }

            fn clear(&mut self) {
                self.operator = ::protobuf::EnumOrUnknown::new(log_level_match::ComparisonOperator::LESS_THAN);
                self.log_level = ::protobuf::EnumOrUnknown::new(log_level_match::LogLevel::TRACE);
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LogLevelMatch {
                static instance: LogLevelMatch = LogLevelMatch {
                    operator: ::protobuf::EnumOrUnknown::from_i32(0),
                    log_level: ::protobuf::EnumOrUnknown::from_i32(0),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for LogLevelMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.LogLevelMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LogLevelMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LogLevelMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `LogLevelMatch`
        pub mod log_level_match {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator)
            pub enum ComparisonOperator {
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator.LESS_THAN)
                LESS_THAN = 0,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator.LESS_THAN_OR_EQUAL)
                LESS_THAN_OR_EQUAL = 1,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator.EQUALS)
                EQUALS = 2,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator.GREATER_THAN)
                GREATER_THAN = 3,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator.GREATER_THAN_OR_EQUAL)
                GREATER_THAN_OR_EQUAL = 4,
            }

            impl ::protobuf::Enum for ComparisonOperator {
                const NAME: &'static str = "ComparisonOperator";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<ComparisonOperator> {
                    match value {
                        0 => ::std::option::Option::Some(ComparisonOperator::LESS_THAN),
                        1 => ::std::option::Option::Some(ComparisonOperator::LESS_THAN_OR_EQUAL),
                        2 => ::std::option::Option::Some(ComparisonOperator::EQUALS),
                        3 => ::std::option::Option::Some(ComparisonOperator::GREATER_THAN),
                        4 => ::std::option::Option::Some(ComparisonOperator::GREATER_THAN_OR_EQUAL),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<ComparisonOperator> {
                    match str {
                        "LESS_THAN" => ::std::option::Option::Some(ComparisonOperator::LESS_THAN),
                        "LESS_THAN_OR_EQUAL" => ::std::option::Option::Some(ComparisonOperator::LESS_THAN_OR_EQUAL),
                        "EQUALS" => ::std::option::Option::Some(ComparisonOperator::EQUALS),
                        "GREATER_THAN" => ::std::option::Option::Some(ComparisonOperator::GREATER_THAN),
                        "GREATER_THAN_OR_EQUAL" => ::std::option::Option::Some(ComparisonOperator::GREATER_THAN_OR_EQUAL),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [ComparisonOperator] = &[
                    ComparisonOperator::LESS_THAN,
                    ComparisonOperator::LESS_THAN_OR_EQUAL,
                    ComparisonOperator::EQUALS,
                    ComparisonOperator::GREATER_THAN,
                    ComparisonOperator::GREATER_THAN_OR_EQUAL,
                ];
            }

            impl ::protobuf::EnumFull for ComparisonOperator {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for ComparisonOperator {
                fn default() -> Self {
                    ComparisonOperator::LESS_THAN
                }
            }

            impl ComparisonOperator {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ComparisonOperator>("LogMatcher.BaseLogMatcher.LogLevelMatch.ComparisonOperator")
                }
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel)
            pub enum LogLevel {
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.TRACE)
                TRACE = 0,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.DEBUG)
                DEBUG = 1,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.INFO)
                INFO = 2,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.WARN)
                WARN = 3,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.ERROR)
                ERROR = 4,
                // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel.CRITICAL)
                CRITICAL = 5,
            }

            impl ::protobuf::Enum for LogLevel {
                const NAME: &'static str = "LogLevel";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<LogLevel> {
                    match value {
                        0 => ::std::option::Option::Some(LogLevel::TRACE),
                        1 => ::std::option::Option::Some(LogLevel::DEBUG),
                        2 => ::std::option::Option::Some(LogLevel::INFO),
                        3 => ::std::option::Option::Some(LogLevel::WARN),
                        4 => ::std::option::Option::Some(LogLevel::ERROR),
                        5 => ::std::option::Option::Some(LogLevel::CRITICAL),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<LogLevel> {
                    match str {
                        "TRACE" => ::std::option::Option::Some(LogLevel::TRACE),
                        "DEBUG" => ::std::option::Option::Some(LogLevel::DEBUG),
                        "INFO" => ::std::option::Option::Some(LogLevel::INFO),
                        "WARN" => ::std::option::Option::Some(LogLevel::WARN),
                        "ERROR" => ::std::option::Option::Some(LogLevel::ERROR),
                        "CRITICAL" => ::std::option::Option::Some(LogLevel::CRITICAL),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [LogLevel] = &[
                    LogLevel::TRACE,
                    LogLevel::DEBUG,
                    LogLevel::INFO,
                    LogLevel::WARN,
                    LogLevel::ERROR,
                    LogLevel::CRITICAL,
                ];
            }

            impl ::protobuf::EnumFull for LogLevel {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for LogLevel {
                fn default() -> Self {
                    LogLevel::TRACE
                }
            }

            impl LogLevel {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LogLevel>("LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevel")
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.MessageMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.MessageMatch.match_type)
            pub match_type: ::protobuf::EnumOrUnknown<StringMatchType>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.MessageMatch.match_value)
            pub match_value: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.MessageMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageMatch {
            fn default() -> &'a MessageMatch {
                <MessageMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl MessageMatch {
            pub fn new() -> MessageMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_type",
                    |m: &MessageMatch| { &m.match_type },
                    |m: &mut MessageMatch| { &mut m.match_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_value",
                    |m: &MessageMatch| { &m.match_value },
                    |m: &mut MessageMatch| { &mut m.match_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageMatch>(
                    "LogMatcher.BaseLogMatcher.MessageMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MessageMatch {
            const NAME: &'static str = "MessageMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.match_type = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.match_value = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.match_type != ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT) {
                    my_size += ::protobuf::rt::int32_size(1, self.match_type.value());
                }
                if !self.match_value.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.match_value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.match_type != ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
                }
                if !self.match_value.is_empty() {
                    os.write_string(2, &self.match_value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageMatch {
                MessageMatch::new()
            }

            fn clear(&mut self) {
                self.match_type = ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT);
                self.match_value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageMatch {
                static instance: MessageMatch = MessageMatch {
                    match_type: ::protobuf::EnumOrUnknown::from_i32(0),
                    match_value: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MessageMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.MessageMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessageMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MessageMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TagMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch.match_type)
            pub match_type: ::protobuf::EnumOrUnknown<StringMatchType>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch.tag_key)
            pub tag_key: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch.match_value)
            pub match_value: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TagMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TagMatch {
            fn default() -> &'a TagMatch {
                <TagMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl TagMatch {
            pub fn new() -> TagMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_type",
                    |m: &TagMatch| { &m.match_type },
                    |m: &mut TagMatch| { &mut m.match_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tag_key",
                    |m: &TagMatch| { &m.tag_key },
                    |m: &mut TagMatch| { &mut m.tag_key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_value",
                    |m: &TagMatch| { &m.match_value },
                    |m: &mut TagMatch| { &mut m.match_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TagMatch>(
                    "LogMatcher.BaseLogMatcher.TagMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TagMatch {
            const NAME: &'static str = "TagMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.match_type = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.tag_key = is.read_string()?;
                        },
                        26 => {
                            self.match_value = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.match_type != ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT) {
                    my_size += ::protobuf::rt::int32_size(1, self.match_type.value());
                }
                if !self.tag_key.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.tag_key);
                }
                if !self.match_value.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.match_value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.match_type != ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.match_type))?;
                }
                if !self.tag_key.is_empty() {
                    os.write_string(2, &self.tag_key)?;
                }
                if !self.match_value.is_empty() {
                    os.write_string(3, &self.match_value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TagMatch {
                TagMatch::new()
            }

            fn clear(&mut self) {
                self.match_type = ::protobuf::EnumOrUnknown::new(StringMatchType::EXACT);
                self.tag_key.clear();
                self.match_value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TagMatch {
                static instance: TagMatch = TagMatch {
                    match_type: ::protobuf::EnumOrUnknown::from_i32(0),
                    tag_key: ::std::string::String::new(),
                    match_value: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TagMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.TagMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TagMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TagMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.AnyMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AnyMatch {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.AnyMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AnyMatch {
            fn default() -> &'a AnyMatch {
                <AnyMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl AnyMatch {
            pub fn new() -> AnyMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnyMatch>(
                    "LogMatcher.BaseLogMatcher.AnyMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AnyMatch {
            const NAME: &'static str = "AnyMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AnyMatch {
                AnyMatch::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AnyMatch {
                static instance: AnyMatch = AnyMatch {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for AnyMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.AnyMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AnyMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AnyMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TypeMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TypeMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TypeMatch.type)
            pub type_: u32,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TypeMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TypeMatch {
            fn default() -> &'a TypeMatch {
                <TypeMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl TypeMatch {
            pub fn new() -> TypeMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "type",
                    |m: &TypeMatch| { &m.type_ },
                    |m: &mut TypeMatch| { &mut m.type_ },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeMatch>(
                    "LogMatcher.BaseLogMatcher.TypeMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TypeMatch {
            const NAME: &'static str = "TypeMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = is.read_uint32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_ != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.type_);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_ != 0 {
                    os.write_uint32(1, self.type_)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TypeMatch {
                TypeMatch::new()
            }

            fn clear(&mut self) {
                self.type_ = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TypeMatch {
                static instance: TypeMatch = TypeMatch {
                    type_: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TypeMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.TypeMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TypeMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TypeMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.StringMatchType)
        pub enum StringMatchType {
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.StringMatchType.EXACT)
            EXACT = 0,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.StringMatchType.PREFIX)
            PREFIX = 1,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.StringMatchType.REGEX)
            REGEX = 2,
        }

        impl ::protobuf::Enum for StringMatchType {
            const NAME: &'static str = "StringMatchType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<StringMatchType> {
                match value {
                    0 => ::std::option::Option::Some(StringMatchType::EXACT),
                    1 => ::std::option::Option::Some(StringMatchType::PREFIX),
                    2 => ::std::option::Option::Some(StringMatchType::REGEX),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<StringMatchType> {
                match str {
                    "EXACT" => ::std::option::Option::Some(StringMatchType::EXACT),
                    "PREFIX" => ::std::option::Option::Some(StringMatchType::PREFIX),
                    "REGEX" => ::std::option::Option::Some(StringMatchType::REGEX),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [StringMatchType] = &[
                StringMatchType::EXACT,
                StringMatchType::PREFIX,
                StringMatchType::REGEX,
            ];
        }

        impl ::protobuf::EnumFull for StringMatchType {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("LogMatcher.BaseLogMatcher.StringMatchType").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for StringMatchType {
            fn default() -> Self {
                StringMatchType::EXACT
            }
        }

        impl StringMatchType {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<StringMatchType>("LogMatcher.BaseLogMatcher.StringMatchType")
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.LogMatcher.MatcherList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatcherList {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.LogMatcher.MatcherList.matcher)
        pub matcher: ::std::vec::Vec<super::LogMatcher>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.LogMatcher.MatcherList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatcherList {
        fn default() -> &'a MatcherList {
            <MatcherList as ::protobuf::Message>::default_instance()
        }
    }

    impl MatcherList {
        pub fn new() -> MatcherList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "matcher",
                |m: &MatcherList| { &m.matcher },
                |m: &mut MatcherList| { &mut m.matcher },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatcherList>(
                "LogMatcher.MatcherList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatcherList {
        const NAME: &'static str = "MatcherList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.matcher.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.matcher {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.matcher {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatcherList {
            MatcherList::new()
        }

        fn clear(&mut self) {
            self.matcher.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatcherList {
            static instance: MatcherList = MatcherList {
                matcher: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatcherList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.MatcherList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatcherList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatcherList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.BufferConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BufferConfig {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.filters)
    pub filters: ::std::vec::Vec<buffer_config::BufferFilter>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.type)
    pub type_: ::protobuf::EnumOrUnknown<buffer_config::Type>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.buffer_sizes)
    pub buffer_sizes: ::protobuf::MessageField<buffer_config::BufferSizes>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.context_matcher)
    pub context_matcher: ::protobuf::MessageField<super::matcher::RootMatcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.BufferConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BufferConfig {
    fn default() -> &'a BufferConfig {
        <BufferConfig as ::protobuf::Message>::default_instance()
    }
}

impl BufferConfig {
    pub fn new() -> BufferConfig {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &BufferConfig| { &m.name },
            |m: &mut BufferConfig| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BufferConfig| { &m.id },
            |m: &mut BufferConfig| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "filters",
            |m: &BufferConfig| { &m.filters },
            |m: &mut BufferConfig| { &mut m.filters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &BufferConfig| { &m.type_ },
            |m: &mut BufferConfig| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, buffer_config::BufferSizes>(
            "buffer_sizes",
            |m: &BufferConfig| { &m.buffer_sizes },
            |m: &mut BufferConfig| { &mut m.buffer_sizes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::matcher::RootMatcher>(
            "context_matcher",
            |m: &BufferConfig| { &m.context_matcher },
            |m: &mut BufferConfig| { &mut m.context_matcher },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BufferConfig>(
            "BufferConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BufferConfig {
    const NAME: &'static str = "BufferConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.id = is.read_string()?;
                },
                26 => {
                    self.filters.push(is.read_message()?);
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.buffer_sizes)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.context_matcher)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.type_ != ::protobuf::EnumOrUnknown::new(buffer_config::Type::TRIGGER) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if let Some(v) = self.buffer_sizes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.context_matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        for v in &self.filters {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if self.type_ != ::protobuf::EnumOrUnknown::new(buffer_config::Type::TRIGGER) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.buffer_sizes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.context_matcher.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BufferConfig {
        BufferConfig::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.id.clear();
        self.filters.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(buffer_config::Type::TRIGGER);
        self.buffer_sizes.clear();
        self.context_matcher.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BufferConfig {
        static instance: BufferConfig = BufferConfig {
            name: ::std::string::String::new(),
            id: ::std::string::String::new(),
            filters: ::std::vec::Vec::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            buffer_sizes: ::protobuf::MessageField::none(),
            context_matcher: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BufferConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BufferConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BufferConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `BufferConfig`
pub mod buffer_config {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BufferFilter {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter.filter)
        pub filter: ::protobuf::MessageField<super::LogMatcher>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BufferFilter {
        fn default() -> &'a BufferFilter {
            <BufferFilter as ::protobuf::Message>::default_instance()
        }
    }

    impl BufferFilter {
        pub fn new() -> BufferFilter {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "name",
                |m: &BufferFilter| { &m.name },
                |m: &mut BufferFilter| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &BufferFilter| { &m.id },
                |m: &mut BufferFilter| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LogMatcher>(
                "filter",
                |m: &BufferFilter| { &m.filter },
                |m: &mut BufferFilter| { &mut m.filter },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BufferFilter>(
                "BufferConfig.BufferFilter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BufferFilter {
        const NAME: &'static str = "BufferFilter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    18 => {
                        self.id = is.read_string()?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.filter)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.id);
            }
            if let Some(v) = self.filter.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if !self.id.is_empty() {
                os.write_string(2, &self.id)?;
            }
            if let Some(v) = self.filter.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BufferFilter {
            BufferFilter::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.id.clear();
            self.filter.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BufferFilter {
            static instance: BufferFilter = BufferFilter {
                name: ::std::string::String::new(),
                id: ::std::string::String::new(),
                filter: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BufferFilter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BufferConfig.BufferFilter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BufferFilter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BufferFilter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.BufferConfig.BufferSizes)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BufferSizes {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferSizes.volatile_buffer_size_bytes)
        pub volatile_buffer_size_bytes: u32,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferSizes.non_volatile_buffer_size_bytes)
        pub non_volatile_buffer_size_bytes: u32,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.BufferConfig.BufferSizes.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BufferSizes {
        fn default() -> &'a BufferSizes {
            <BufferSizes as ::protobuf::Message>::default_instance()
        }
    }

    impl BufferSizes {
        pub fn new() -> BufferSizes {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "volatile_buffer_size_bytes",
                |m: &BufferSizes| { &m.volatile_buffer_size_bytes },
                |m: &mut BufferSizes| { &mut m.volatile_buffer_size_bytes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "non_volatile_buffer_size_bytes",
                |m: &BufferSizes| { &m.non_volatile_buffer_size_bytes },
                |m: &mut BufferSizes| { &mut m.non_volatile_buffer_size_bytes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BufferSizes>(
                "BufferConfig.BufferSizes",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BufferSizes {
        const NAME: &'static str = "BufferSizes";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.volatile_buffer_size_bytes = is.read_uint32()?;
                    },
                    16 => {
                        self.non_volatile_buffer_size_bytes = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.volatile_buffer_size_bytes != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.volatile_buffer_size_bytes);
            }
            if self.non_volatile_buffer_size_bytes != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.non_volatile_buffer_size_bytes);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.volatile_buffer_size_bytes != 0 {
                os.write_uint32(1, self.volatile_buffer_size_bytes)?;
            }
            if self.non_volatile_buffer_size_bytes != 0 {
                os.write_uint32(2, self.non_volatile_buffer_size_bytes)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BufferSizes {
            BufferSizes::new()
        }

        fn clear(&mut self) {
            self.volatile_buffer_size_bytes = 0;
            self.non_volatile_buffer_size_bytes = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BufferSizes {
            static instance: BufferSizes = BufferSizes {
                volatile_buffer_size_bytes: 0,
                non_volatile_buffer_size_bytes: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BufferSizes {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("BufferConfig.BufferSizes").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BufferSizes {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BufferSizes {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:bitdrift_public.protobuf.config.v1.BufferConfig.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.BufferConfig.Type.TRIGGER)
        TRIGGER = 0,
        // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.config.v1.BufferConfig.Type.CONTINUOUS)
        CONTINUOUS = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::TRIGGER),
                1 => ::std::option::Option::Some(Type::CONTINUOUS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "TRIGGER" => ::std::option::Option::Some(Type::TRIGGER),
                "CONTINUOUS" => ::std::option::Option::Some(Type::CONTINUOUS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TRIGGER,
            Type::CONTINUOUS,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("BufferConfig.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TRIGGER
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("BufferConfig.Type")
        }
    }
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.config.v1.BufferConfigList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BufferConfigList {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.config.v1.BufferConfigList.buffer_config)
    pub buffer_config: ::std::vec::Vec<BufferConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.config.v1.BufferConfigList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BufferConfigList {
    fn default() -> &'a BufferConfigList {
        <BufferConfigList as ::protobuf::Message>::default_instance()
    }
}

impl BufferConfigList {
    pub fn new() -> BufferConfigList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "buffer_config",
            |m: &BufferConfigList| { &m.buffer_config },
            |m: &mut BufferConfigList| { &mut m.buffer_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BufferConfigList>(
            "BufferConfigList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BufferConfigList {
    const NAME: &'static str = "BufferConfigList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.buffer_config.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.buffer_config {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.buffer_config {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BufferConfigList {
        BufferConfigList::new()
    }

    fn clear(&mut self) {
        self.buffer_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BufferConfigList {
        static instance: BufferConfigList = BufferConfigList {
            buffer_config: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BufferConfigList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BufferConfigList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BufferConfigList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferConfigList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/bitdrift_public/protobuf/config/v1/config.proto\x12\"bitdrift_public.\
    protobuf.config.v1\x1a0bitdrift_public/protobuf/client/v1/matcher.proto\
    \x1a\x17validate/validate.proto\"\x80\x10\n\nLogMatcher\x12b\n\x0cbase_m\
    atcher\x18\x01\x20\x01(\x0b2=.bitdrift_public.protobuf.config.v1.LogMatc\
    her.BaseLogMatcherH\0R\x0bbaseMatcher\x12[\n\nor_matcher\x18\x02\x20\x01\
    (\x0b2:.bitdrift_public.protobuf.config.v1.LogMatcher.MatcherListH\0R\to\
    rMatcher\x12]\n\x0band_matcher\x18\x03\x20\x01(\x0b2:.bitdrift_public.pr\
    otobuf.config.v1.LogMatcher.MatcherListH\0R\nandMatcher\x12Q\n\x0bnot_ma\
    tcher\x18\x04\x20\x01(\x0b2..bitdrift_public.protobuf.config.v1.LogMatch\
    erH\0R\nnotMatcher\x1a\x88\x0c\n\x0eBaseLogMatcher\x12u\n\x0flog_level_m\
    atch\x18\x01\x20\x01(\x0b2K.bitdrift_public.protobuf.config.v1.LogMatche\
    r.BaseLogMatcher.LogLevelMatchH\0R\rlogLevelMatch\x12q\n\rmessage_match\
    \x18\x02\x20\x01(\x0b2J.bitdrift_public.protobuf.config.v1.LogMatcher.Ba\
    seLogMatcher.MessageMatchH\0R\x0cmessageMatch\x12e\n\ttag_match\x18\x03\
    \x20\x01(\x0b2F.bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMat\
    cher.TagMatchH\0R\x08tagMatch\x12h\n\ntype_match\x18\x05\x20\x01(\x0b2G.\
    bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.TypeMatchH\
    \0R\ttypeMatch\x12e\n\tany_match\x18\x04\x20\x01(\x0b2F.bitdrift_public.\
    protobuf.config.v1.LogMatcher.BaseLogMatcher.AnyMatchH\0R\x08anyMatch\
    \x1a\xd8\x03\n\rLogLevelMatch\x12\x84\x01\n\x08operator\x18\x01\x20\x01(\
    \x0e2^.bitdrift_public.protobuf.config.v1.LogMatcher.BaseLogMatcher.LogL\
    evelMatch.ComparisonOperatorR\x08operatorB\x08\xfaB\x05\x82\x01\x02\x10\
    \x01\x12{\n\tlog_level\x18\x02\x20\x01(\x0e2T.bitdrift_public.protobuf.c\
    onfig.v1.LogMatcher.BaseLogMatcher.LogLevelMatch.LogLevelR\x08logLevelB\
    \x08\xfaB\x05\x82\x01\x02\x10\x01\"t\n\x12ComparisonOperator\x12\r\n\tLE\
    SS_THAN\x10\0\x12\x16\n\x12LESS_THAN_OR_EQUAL\x10\x01\x12\n\n\x06EQUALS\
    \x10\x02\x12\x10\n\x0cGREATER_THAN\x10\x03\x12\x19\n\x15GREATER_THAN_OR_\
    EQUAL\x10\x04\"M\n\x08LogLevel\x12\t\n\x05TRACE\x10\0\x12\t\n\x05DEBUG\
    \x10\x01\x12\x08\n\x04INFO\x10\x02\x12\x08\n\x04WARN\x10\x03\x12\t\n\x05\
    ERROR\x10\x04\x12\x0c\n\x08CRITICAL\x10\x05\x1a\xb0\x01\n\x0cMessageMatc\
    h\x12v\n\nmatch_type\x18\x01\x20\x01(\x0e2M.bitdrift_public.protobuf.con\
    fig.v1.LogMatcher.BaseLogMatcher.StringMatchTypeR\tmatchTypeB\x08\xfaB\
    \x05\x82\x01\x02\x10\x01\x12(\n\x0bmatch_value\x18\x02\x20\x01(\tR\nmatc\
    hValueB\x07\xfaB\x04r\x02\x10\x01\x1a\xd0\x01\n\x08TagMatch\x12v\n\nmatc\
    h_type\x18\x01\x20\x01(\x0e2M.bitdrift_public.protobuf.config.v1.LogMatc\
    her.BaseLogMatcher.StringMatchTypeR\tmatchTypeB\x08\xfaB\x05\x82\x01\x02\
    \x10\x01\x12\"\n\x07tag_key\x18\x02\x20\x01(\tR\x06tagKeyB\t\xfaB\x06r\
    \x04\x10\x01\x18@\x12(\n\x0bmatch_value\x18\x03\x20\x01(\tR\nmatchValueB\
    \x07\xfaB\x04r\x02\x10\x01\x1a\n\n\x08AnyMatch\x1a\x1f\n\tTypeMatch\x12\
    \x12\n\x04type\x18\x01\x20\x01(\rR\x04type\"3\n\x0fStringMatchType\x12\t\
    \n\x05EXACT\x10\0\x12\n\n\x06PREFIX\x10\x01\x12\t\n\x05REGEX\x10\x02B\
    \x11\n\nmatch_type\x12\x03\xf8B\x01\x1aa\n\x0bMatcherList\x12R\n\x07matc\
    her\x18\x01\x20\x03(\x0b2..bitdrift_public.protobuf.config.v1.LogMatcher\
    R\x07matcherB\x08\xfaB\x05\x92\x01\x02\x08\x02B\x11\n\nmatch_type\x12\
    \x03\xf8B\x01\"\x84\x06\n\x0cBufferConfig\x12\x1b\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\x07\xfaB\x04r\x02\x10\x01\x12\x17\n\x02id\x18\x02\x20\
    \x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\x12W\n\x07filters\x18\x03\x20\
    \x03(\x0b2=.bitdrift_public.protobuf.config.v1.BufferConfig.BufferFilter\
    R\x07filters\x12I\n\x04type\x18\x04\x20\x01(\x0e25.bitdrift_public.proto\
    buf.config.v1.BufferConfig.TypeR\x04type\x12_\n\x0cbuffer_sizes\x18\x05\
    \x20\x01(\x0b2<.bitdrift_public.protobuf.config.v1.BufferConfig.BufferSi\
    zesR\x0bbufferSizes\x12X\n\x0fcontext_matcher\x18\x06\x20\x01(\x0b2/.bit\
    drift_public.protobuf.client.v1.RootMatcherR\x0econtextMatcher\x1a\x96\
    \x01\n\x0cBufferFilter\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\
    \x07\xfaB\x04r\x02\x10\x01\x12\x17\n\x02id\x18\x02\x20\x01(\tR\x02idB\
    \x07\xfaB\x04r\x02\x10\x01\x12P\n\x06filter\x18\x03\x20\x01(\x0b2..bitdr\
    ift_public.protobuf.config.v1.LogMatcherR\x06filterB\x08\xfaB\x05\x8a\
    \x01\x02\x10\x01\x1a\xa0\x01\n\x0bBufferSizes\x12D\n\x1avolatile_buffer_\
    size_bytes\x18\x01\x20\x01(\rR\x17volatileBufferSizeBytesB\x07\xfaB\x04*\
    \x02\x20\0\x12K\n\x1enon_volatile_buffer_size_bytes\x18\x02\x20\x01(\rR\
    \x1anonVolatileBufferSizeBytesB\x07\xfaB\x04*\x02\x20\0\"#\n\x04Type\x12\
    \x0b\n\x07TRIGGER\x10\0\x12\x0e\n\nCONTINUOUS\x10\x01\"i\n\x10BufferConf\
    igList\x12U\n\rbuffer_config\x18\x01\x20\x03(\x0b20.bitdrift_public.prot\
    obuf.config.v1.BufferConfigR\x0cbufferConfigb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::matcher::file_descriptor().clone());
            deps.push(super::validate::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(LogMatcher::generated_message_descriptor_data());
            messages.push(BufferConfig::generated_message_descriptor_data());
            messages.push(BufferConfigList::generated_message_descriptor_data());
            messages.push(log_matcher::BaseLogMatcher::generated_message_descriptor_data());
            messages.push(log_matcher::MatcherList::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::LogLevelMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::MessageMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::TagMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::AnyMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::TypeMatch::generated_message_descriptor_data());
            messages.push(buffer_config::BufferFilter::generated_message_descriptor_data());
            messages.push(buffer_config::BufferSizes::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(log_matcher::base_log_matcher::StringMatchType::generated_enum_descriptor_data());
            enums.push(log_matcher::base_log_matcher::log_level_match::ComparisonOperator::generated_enum_descriptor_data());
            enums.push(log_matcher::base_log_matcher::log_level_match::LogLevel::generated_enum_descriptor_data());
            enums.push(buffer_config::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
