// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 29.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/workflow/v1/workflow.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowsConfiguration {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration.workflows)
    pub workflows: ::std::vec::Vec<Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowsConfiguration {
    fn default() -> &'a WorkflowsConfiguration {
        <WorkflowsConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowsConfiguration {
    pub fn new() -> WorkflowsConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &WorkflowsConfiguration| { &m.workflows },
            |m: &mut WorkflowsConfiguration| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowsConfiguration>(
            "WorkflowsConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowsConfiguration {
    const NAME: &'static str = "WorkflowsConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowsConfiguration {
        WorkflowsConfiguration::new()
    }

    fn clear(&mut self) {
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowsConfiguration {
        static instance: WorkflowsConfiguration = WorkflowsConfiguration {
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowsConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowsConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowsConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowsConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Workflow {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.states)
    pub states: ::std::vec::Vec<workflow::State>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.execution)
    pub execution: ::protobuf::MessageField<workflow::Execution>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.limit_matched_logs_count)
    pub limit_matched_logs_count: ::protobuf::MessageField<workflow::LimitMatchedLogsCount>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.limit_duration)
    pub limit_duration: ::protobuf::MessageField<workflow::LimitDuration>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Workflow {
    fn default() -> &'a Workflow {
        <Workflow as ::protobuf::Message>::default_instance()
    }
}

impl Workflow {
    pub fn new() -> Workflow {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Workflow| { &m.id },
            |m: &mut Workflow| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "states",
            |m: &Workflow| { &m.states },
            |m: &mut Workflow| { &mut m.states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::Execution>(
            "execution",
            |m: &Workflow| { &m.execution },
            |m: &mut Workflow| { &mut m.execution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::LimitMatchedLogsCount>(
            "limit_matched_logs_count",
            |m: &Workflow| { &m.limit_matched_logs_count },
            |m: &mut Workflow| { &mut m.limit_matched_logs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::LimitDuration>(
            "limit_duration",
            |m: &Workflow| { &m.limit_duration },
            |m: &mut Workflow| { &mut m.limit_duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Workflow>(
            "Workflow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Workflow {
    const NAME: &'static str = "Workflow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.states.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.execution)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limit_matched_logs_count)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limit_duration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.execution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.limit_matched_logs_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.limit_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.states {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.execution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.limit_matched_logs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.limit_duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Workflow {
        Workflow::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.states.clear();
        self.execution.clear();
        self.limit_matched_logs_count.clear();
        self.limit_duration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Workflow {
        static instance: Workflow = Workflow {
            id: ::std::string::String::new(),
            states: ::std::vec::Vec::new(),
            execution: ::protobuf::MessageField::none(),
            limit_matched_logs_count: ::protobuf::MessageField::none(),
            limit_duration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Workflow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Workflow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Workflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Workflow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Workflow`
pub mod workflow {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.State)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct State {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.State.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.State.transitions)
        pub transitions: ::std::vec::Vec<Transition>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.State.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a State {
        fn default() -> &'a State {
            <State as ::protobuf::Message>::default_instance()
        }
    }

    impl State {
        pub fn new() -> State {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &State| { &m.id },
                |m: &mut State| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "transitions",
                |m: &State| { &m.transitions },
                |m: &mut State| { &mut m.transitions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<State>(
                "Workflow.State",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for State {
        const NAME: &'static str = "State";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    },
                    18 => {
                        self.transitions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            for value in &self.transitions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            for v in &self.transitions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> State {
            State::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.transitions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static State {
            static instance: State = State {
                id: ::std::string::String::new(),
                transitions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for State {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.State").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for State {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for State {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Transition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Transition {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.target_state_id)
        pub target_state_id: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.rule)
        pub rule: ::protobuf::MessageField<Rule>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.actions)
        pub actions: ::std::vec::Vec<Action>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.extensions)
        pub extensions: ::std::vec::Vec<TransitionExtension>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Transition {
        fn default() -> &'a Transition {
            <Transition as ::protobuf::Message>::default_instance()
        }
    }

    impl Transition {
        pub fn new() -> Transition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "target_state_id",
                |m: &Transition| { &m.target_state_id },
                |m: &mut Transition| { &mut m.target_state_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rule>(
                "rule",
                |m: &Transition| { &m.rule },
                |m: &mut Transition| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "actions",
                |m: &Transition| { &m.actions },
                |m: &mut Transition| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "extensions",
                |m: &Transition| { &m.extensions },
                |m: &mut Transition| { &mut m.extensions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transition>(
                "Workflow.Transition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Transition {
        const NAME: &'static str = "Transition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.target_state_id = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rule)?;
                    },
                    26 => {
                        self.actions.push(is.read_message()?);
                    },
                    34 => {
                        self.extensions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.target_state_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.target_state_id);
            }
            if let Some(v) = self.rule.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.actions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.extensions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.target_state_id.is_empty() {
                os.write_string(1, &self.target_state_id)?;
            }
            if let Some(v) = self.rule.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.actions {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.extensions {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Transition {
            Transition::new()
        }

        fn clear(&mut self) {
            self.target_state_id.clear();
            self.rule.clear();
            self.actions.clear();
            self.extensions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Transition {
            static instance: Transition = Transition {
                target_state_id: ::std::string::String::new(),
                rule: ::protobuf::MessageField::none(),
                actions: ::std::vec::Vec::new(),
                extensions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Transition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Transition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Transition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Transition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Rule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Rule {
        // message oneof groups
        pub rule_type: ::std::option::Option<rule::Rule_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Rule {
        fn default() -> &'a Rule {
            <Rule as ::protobuf::Message>::default_instance()
        }
    }

    impl Rule {
        pub fn new() -> Rule {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch rule_log_match = 1;

        pub fn rule_log_match(&self) -> &RuleLogMatch {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(ref v)) => v,
                _ => <RuleLogMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_rule_log_match(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_log_match(&self) -> bool {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_rule_log_match(&mut self, v: RuleLogMatch) {
            self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_rule_log_match(&mut self) -> &mut RuleLogMatch {
            if let ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(_)) = self.rule_type {
            } else {
                self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(RuleLogMatch::new()));
            }
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_rule_log_match(&mut self) -> RuleLogMatch {
            if self.has_rule_log_match() {
                match self.rule_type.take() {
                    ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                RuleLogMatch::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RuleLogMatch>(
                "rule_log_match",
                Rule::has_rule_log_match,
                Rule::rule_log_match,
                Rule::mut_rule_log_match,
                Rule::set_rule_log_match,
            ));
            oneofs.push(rule::Rule_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rule>(
                "Workflow.Rule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Rule {
        const NAME: &'static str = "Rule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.rule_type {
                match v {
                    &rule::Rule_type::RuleLogMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.rule_type {
                match v {
                    &rule::Rule_type::RuleLogMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Rule {
            Rule::new()
        }

        fn clear(&mut self) {
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Rule {
            static instance: Rule = Rule {
                rule_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Rule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Rule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Rule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Rule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Rule`
    pub mod rule {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.rule_type)
        pub enum Rule_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.rule_log_match)
            RuleLogMatch(super::RuleLogMatch),
        }

        impl ::protobuf::Oneof for Rule_type {
        }

        impl ::protobuf::OneofFull for Rule_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Rule as ::protobuf::MessageFull>::descriptor().oneof_by_name("rule_type").unwrap()).clone()
            }
        }

        impl Rule_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Rule_type>("rule_type")
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TransitionExtension {
        // message oneof groups
        pub extension_type: ::std::option::Option<transition_extension::Extension_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TransitionExtension {
        fn default() -> &'a TransitionExtension {
            <TransitionExtension as ::protobuf::Message>::default_instance()
        }
    }

    impl TransitionExtension {
        pub fn new() -> TransitionExtension {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction sankey_diagram_value_extraction = 1;

        pub fn sankey_diagram_value_extraction(&self) -> &transition_extension::SankeyDiagramValueExtraction {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(ref v)) => v,
                _ => <transition_extension::SankeyDiagramValueExtraction as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_sankey_diagram_value_extraction(&mut self) {
            self.extension_type = ::std::option::Option::None;
        }

        pub fn has_sankey_diagram_value_extraction(&self) -> bool {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_sankey_diagram_value_extraction(&mut self, v: transition_extension::SankeyDiagramValueExtraction) {
            self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(v))
        }

        // Mutable pointer to the field.
        pub fn mut_sankey_diagram_value_extraction(&mut self) -> &mut transition_extension::SankeyDiagramValueExtraction {
            if let ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(_)) = self.extension_type {
            } else {
                self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(transition_extension::SankeyDiagramValueExtraction::new()));
            }
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_sankey_diagram_value_extraction(&mut self) -> transition_extension::SankeyDiagramValueExtraction {
            if self.has_sankey_diagram_value_extraction() {
                match self.extension_type.take() {
                    ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(v)) => v,
                    _ => panic!(),
                }
            } else {
                transition_extension::SankeyDiagramValueExtraction::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveTimestamp save_timestamp = 2;

        pub fn save_timestamp(&self) -> &transition_extension::SaveTimestamp {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(ref v)) => v,
                _ => <transition_extension::SaveTimestamp as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_save_timestamp(&mut self) {
            self.extension_type = ::std::option::Option::None;
        }

        pub fn has_save_timestamp(&self) -> bool {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_save_timestamp(&mut self, v: transition_extension::SaveTimestamp) {
            self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(v))
        }

        // Mutable pointer to the field.
        pub fn mut_save_timestamp(&mut self) -> &mut transition_extension::SaveTimestamp {
            if let ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(_)) = self.extension_type {
            } else {
                self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(transition_extension::SaveTimestamp::new()));
            }
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_save_timestamp(&mut self) -> transition_extension::SaveTimestamp {
            if self.has_save_timestamp() {
                match self.extension_type.take() {
                    ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(v)) => v,
                    _ => panic!(),
                }
            } else {
                transition_extension::SaveTimestamp::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveField save_field = 3;

        pub fn save_field(&self) -> &transition_extension::SaveField {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveField(ref v)) => v,
                _ => <transition_extension::SaveField as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_save_field(&mut self) {
            self.extension_type = ::std::option::Option::None;
        }

        pub fn has_save_field(&self) -> bool {
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveField(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_save_field(&mut self, v: transition_extension::SaveField) {
            self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveField(v))
        }

        // Mutable pointer to the field.
        pub fn mut_save_field(&mut self) -> &mut transition_extension::SaveField {
            if let ::std::option::Option::Some(transition_extension::Extension_type::SaveField(_)) = self.extension_type {
            } else {
                self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveField(transition_extension::SaveField::new()));
            }
            match self.extension_type {
                ::std::option::Option::Some(transition_extension::Extension_type::SaveField(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_save_field(&mut self) -> transition_extension::SaveField {
            if self.has_save_field() {
                match self.extension_type.take() {
                    ::std::option::Option::Some(transition_extension::Extension_type::SaveField(v)) => v,
                    _ => panic!(),
                }
            } else {
                transition_extension::SaveField::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transition_extension::SankeyDiagramValueExtraction>(
                "sankey_diagram_value_extraction",
                TransitionExtension::has_sankey_diagram_value_extraction,
                TransitionExtension::sankey_diagram_value_extraction,
                TransitionExtension::mut_sankey_diagram_value_extraction,
                TransitionExtension::set_sankey_diagram_value_extraction,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transition_extension::SaveTimestamp>(
                "save_timestamp",
                TransitionExtension::has_save_timestamp,
                TransitionExtension::save_timestamp,
                TransitionExtension::mut_save_timestamp,
                TransitionExtension::set_save_timestamp,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, transition_extension::SaveField>(
                "save_field",
                TransitionExtension::has_save_field,
                TransitionExtension::save_field,
                TransitionExtension::mut_save_field,
                TransitionExtension::set_save_field,
            ));
            oneofs.push(transition_extension::Extension_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransitionExtension>(
                "Workflow.TransitionExtension",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TransitionExtension {
        const NAME: &'static str = "TransitionExtension";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SankeyDiagramValueExtraction(is.read_message()?));
                    },
                    18 => {
                        self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveTimestamp(is.read_message()?));
                    },
                    26 => {
                        self.extension_type = ::std::option::Option::Some(transition_extension::Extension_type::SaveField(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.extension_type {
                match v {
                    &transition_extension::Extension_type::SankeyDiagramValueExtraction(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &transition_extension::Extension_type::SaveTimestamp(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &transition_extension::Extension_type::SaveField(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.extension_type {
                match v {
                    &transition_extension::Extension_type::SankeyDiagramValueExtraction(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &transition_extension::Extension_type::SaveTimestamp(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &transition_extension::Extension_type::SaveField(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TransitionExtension {
            TransitionExtension::new()
        }

        fn clear(&mut self) {
            self.extension_type = ::std::option::Option::None;
            self.extension_type = ::std::option::Option::None;
            self.extension_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TransitionExtension {
            static instance: TransitionExtension = TransitionExtension {
                extension_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TransitionExtension {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.TransitionExtension").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TransitionExtension {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TransitionExtension {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TransitionExtension`
    pub mod transition_extension {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.extension_type)
        pub enum Extension_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.sankey_diagram_value_extraction)
            SankeyDiagramValueExtraction(SankeyDiagramValueExtraction),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.save_timestamp)
            SaveTimestamp(SaveTimestamp),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.save_field)
            SaveField(SaveField),
        }

        impl ::protobuf::Oneof for Extension_type {
        }

        impl ::protobuf::OneofFull for Extension_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::TransitionExtension as ::protobuf::MessageFull>::descriptor().oneof_by_name("extension_type").unwrap()).clone()
            }
        }

        impl Extension_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Extension_type>("extension_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveTimestamp)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SaveTimestamp {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveTimestamp.id)
            pub id: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveTimestamp.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SaveTimestamp {
            fn default() -> &'a SaveTimestamp {
                <SaveTimestamp as ::protobuf::Message>::default_instance()
            }
        }

        impl SaveTimestamp {
            pub fn new() -> SaveTimestamp {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &SaveTimestamp| { &m.id },
                    |m: &mut SaveTimestamp| { &mut m.id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SaveTimestamp>(
                    "Workflow.TransitionExtension.SaveTimestamp",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SaveTimestamp {
            const NAME: &'static str = "SaveTimestamp";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SaveTimestamp {
                SaveTimestamp::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SaveTimestamp {
                static instance: SaveTimestamp = SaveTimestamp {
                    id: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SaveTimestamp {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.TransitionExtension.SaveTimestamp").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SaveTimestamp {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SaveTimestamp {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveField)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SaveField {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveField.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveField.field_name)
            pub field_name: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SaveField.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SaveField {
            fn default() -> &'a SaveField {
                <SaveField as ::protobuf::Message>::default_instance()
            }
        }

        impl SaveField {
            pub fn new() -> SaveField {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &SaveField| { &m.id },
                    |m: &mut SaveField| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "field_name",
                    |m: &SaveField| { &m.field_name },
                    |m: &mut SaveField| { &mut m.field_name },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SaveField>(
                    "Workflow.TransitionExtension.SaveField",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SaveField {
            const NAME: &'static str = "SaveField";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        18 => {
                            self.field_name = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                if !self.field_name.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.field_name);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                if !self.field_name.is_empty() {
                    os.write_string(2, &self.field_name)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SaveField {
                SaveField::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.field_name.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SaveField {
                static instance: SaveField = SaveField {
                    id: ::std::string::String::new(),
                    field_name: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SaveField {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.TransitionExtension.SaveField").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SaveField {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SaveField {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SankeyDiagramValueExtraction {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.sankey_diagram_id)
            pub sankey_diagram_id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.counts_toward_sankey_extraction_limit)
            pub counts_toward_sankey_extraction_limit: bool,
            // message oneof groups
            pub value_type: ::std::option::Option<sankey_diagram_value_extraction::Value_type>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SankeyDiagramValueExtraction {
            fn default() -> &'a SankeyDiagramValueExtraction {
                <SankeyDiagramValueExtraction as ::protobuf::Message>::default_instance()
            }
        }

        impl SankeyDiagramValueExtraction {
            pub fn new() -> SankeyDiagramValueExtraction {
                ::std::default::Default::default()
            }

            // string fixed = 2;

            pub fn fixed(&self) -> &str {
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(ref v)) => v,
                    _ => "",
                }
            }

            pub fn clear_fixed(&mut self) {
                self.value_type = ::std::option::Option::None;
            }

            pub fn has_fixed(&self) -> bool {
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_fixed(&mut self, v: ::std::string::String) {
                self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(v))
            }

            // Mutable pointer to the field.
            pub fn mut_fixed(&mut self) -> &mut ::std::string::String {
                if let ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(_)) = self.value_type {
                } else {
                    self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(::std::string::String::new()));
                }
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_fixed(&mut self) -> ::std::string::String {
                if self.has_fixed() {
                    match self.value_type.take() {
                        ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    ::std::string::String::new()
                }
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted field_extracted = 3;

            pub fn field_extracted(&self) -> &super::FieldExtracted {
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(ref v)) => v,
                    _ => <super::FieldExtracted as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_field_extracted(&mut self) {
                self.value_type = ::std::option::Option::None;
            }

            pub fn has_field_extracted(&self) -> bool {
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_field_extracted(&mut self, v: super::FieldExtracted) {
                self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(v))
            }

            // Mutable pointer to the field.
            pub fn mut_field_extracted(&mut self) -> &mut super::FieldExtracted {
                if let ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(_)) = self.value_type {
                } else {
                    self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(super::FieldExtracted::new()));
                }
                match self.value_type {
                    ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_field_extracted(&mut self) -> super::FieldExtracted {
                if self.has_field_extracted() {
                    match self.value_type.take() {
                        ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::FieldExtracted::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "sankey_diagram_id",
                    |m: &SankeyDiagramValueExtraction| { &m.sankey_diagram_id },
                    |m: &mut SankeyDiagramValueExtraction| { &mut m.sankey_diagram_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                    "fixed",
                    SankeyDiagramValueExtraction::has_fixed,
                    SankeyDiagramValueExtraction::fixed,
                    SankeyDiagramValueExtraction::set_fixed,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FieldExtracted>(
                    "field_extracted",
                    SankeyDiagramValueExtraction::has_field_extracted,
                    SankeyDiagramValueExtraction::field_extracted,
                    SankeyDiagramValueExtraction::mut_field_extracted,
                    SankeyDiagramValueExtraction::set_field_extracted,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "counts_toward_sankey_extraction_limit",
                    |m: &SankeyDiagramValueExtraction| { &m.counts_toward_sankey_extraction_limit },
                    |m: &mut SankeyDiagramValueExtraction| { &mut m.counts_toward_sankey_extraction_limit },
                ));
                oneofs.push(sankey_diagram_value_extraction::Value_type::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SankeyDiagramValueExtraction>(
                    "Workflow.TransitionExtension.SankeyDiagramValueExtraction",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SankeyDiagramValueExtraction {
            const NAME: &'static str = "SankeyDiagramValueExtraction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.sankey_diagram_id = is.read_string()?;
                        },
                        18 => {
                            self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::Fixed(is.read_string()?));
                        },
                        26 => {
                            self.value_type = ::std::option::Option::Some(sankey_diagram_value_extraction::Value_type::FieldExtracted(is.read_message()?));
                        },
                        32 => {
                            self.counts_toward_sankey_extraction_limit = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.sankey_diagram_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.sankey_diagram_id);
                }
                if self.counts_toward_sankey_extraction_limit != false {
                    my_size += 1 + 1;
                }
                if let ::std::option::Option::Some(ref v) = self.value_type {
                    match v {
                        &sankey_diagram_value_extraction::Value_type::Fixed(ref v) => {
                            my_size += ::protobuf::rt::string_size(2, &v);
                        },
                        &sankey_diagram_value_extraction::Value_type::FieldExtracted(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.sankey_diagram_id.is_empty() {
                    os.write_string(1, &self.sankey_diagram_id)?;
                }
                if self.counts_toward_sankey_extraction_limit != false {
                    os.write_bool(4, self.counts_toward_sankey_extraction_limit)?;
                }
                if let ::std::option::Option::Some(ref v) = self.value_type {
                    match v {
                        &sankey_diagram_value_extraction::Value_type::Fixed(ref v) => {
                            os.write_string(2, v)?;
                        },
                        &sankey_diagram_value_extraction::Value_type::FieldExtracted(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SankeyDiagramValueExtraction {
                SankeyDiagramValueExtraction::new()
            }

            fn clear(&mut self) {
                self.sankey_diagram_id.clear();
                self.value_type = ::std::option::Option::None;
                self.value_type = ::std::option::Option::None;
                self.counts_toward_sankey_extraction_limit = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SankeyDiagramValueExtraction {
                static instance: SankeyDiagramValueExtraction = SankeyDiagramValueExtraction {
                    sankey_diagram_id: ::std::string::String::new(),
                    counts_toward_sankey_extraction_limit: false,
                    value_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SankeyDiagramValueExtraction {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.TransitionExtension.SankeyDiagramValueExtraction").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SankeyDiagramValueExtraction {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SankeyDiagramValueExtraction {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `SankeyDiagramValueExtraction`
        pub mod sankey_diagram_value_extraction {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.value_type)
            pub enum Value_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.fixed)
                Fixed(::std::string::String),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueExtraction.field_extracted)
                FieldExtracted(super::super::FieldExtracted),
            }

            impl ::protobuf::Oneof for Value_type {
            }

            impl ::protobuf::OneofFull for Value_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::SankeyDiagramValueExtraction as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_type").unwrap()).clone()
                }
            }

            impl Value_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_type>("value_type")
                }
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuleLogMatch {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.log_matcher)
        pub log_matcher: ::protobuf::MessageField<super::super::log_matcher::LogMatcher>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.count)
        pub count: u32,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuleLogMatch {
        fn default() -> &'a RuleLogMatch {
            <RuleLogMatch as ::protobuf::Message>::default_instance()
        }
    }

    impl RuleLogMatch {
        pub fn new() -> RuleLogMatch {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::log_matcher::LogMatcher>(
                "log_matcher",
                |m: &RuleLogMatch| { &m.log_matcher },
                |m: &mut RuleLogMatch| { &mut m.log_matcher },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &RuleLogMatch| { &m.count },
                |m: &mut RuleLogMatch| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleLogMatch>(
                "Workflow.RuleLogMatch",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuleLogMatch {
        const NAME: &'static str = "RuleLogMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.log_matcher)?;
                    },
                    16 => {
                        self.count = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.log_matcher.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.count != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.log_matcher.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.count != 0 {
                os.write_uint32(2, self.count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuleLogMatch {
            RuleLogMatch::new()
        }

        fn clear(&mut self) {
            self.log_matcher.clear();
            self.count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuleLogMatch {
            static instance: RuleLogMatch = RuleLogMatch {
                log_matcher: ::protobuf::MessageField::none(),
                count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RuleLogMatch {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.RuleLogMatch").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuleLogMatch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuleLogMatch {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Action {
        // message oneof groups
        pub action_type: ::std::option::Option<action::Action_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Action {
        fn default() -> &'a Action {
            <Action as ::protobuf::Message>::default_instance()
        }
    }

    impl Action {
        pub fn new() -> Action {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers action_flush_buffers = 1;

        pub fn action_flush_buffers(&self) -> &action::ActionFlushBuffers {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(ref v)) => v,
                _ => <action::ActionFlushBuffers as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_flush_buffers(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_flush_buffers(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_flush_buffers(&mut self, v: action::ActionFlushBuffers) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_flush_buffers(&mut self) -> &mut action::ActionFlushBuffers {
            if let ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(action::ActionFlushBuffers::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_flush_buffers(&mut self) -> action::ActionFlushBuffers {
            if self.has_action_flush_buffers() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionFlushBuffers::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric action_emit_metric = 2;

        pub fn action_emit_metric(&self) -> &action::ActionEmitMetric {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(ref v)) => v,
                _ => <action::ActionEmitMetric as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_emit_metric(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_emit_metric(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_emit_metric(&mut self, v: action::ActionEmitMetric) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_emit_metric(&mut self) -> &mut action::ActionEmitMetric {
            if let ::std::option::Option::Some(action::Action_type::ActionEmitMetric(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(action::ActionEmitMetric::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_emit_metric(&mut self) -> action::ActionEmitMetric {
            if self.has_action_emit_metric() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionEmitMetric(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionEmitMetric::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram action_emit_sankey_diagram = 3;

        pub fn action_emit_sankey_diagram(&self) -> &action::ActionEmitSankeyDiagram {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(ref v)) => v,
                _ => <action::ActionEmitSankeyDiagram as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_emit_sankey_diagram(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_emit_sankey_diagram(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_emit_sankey_diagram(&mut self, v: action::ActionEmitSankeyDiagram) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_emit_sankey_diagram(&mut self) -> &mut action::ActionEmitSankeyDiagram {
            if let ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(action::ActionEmitSankeyDiagram::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_emit_sankey_diagram(&mut self) -> action::ActionEmitSankeyDiagram {
            if self.has_action_emit_sankey_diagram() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionEmitSankeyDiagram::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionTakeScreenshot action_take_screenshot = 4;

        pub fn action_take_screenshot(&self) -> &action::ActionTakeScreenshot {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(ref v)) => v,
                _ => <action::ActionTakeScreenshot as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_take_screenshot(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_take_screenshot(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_take_screenshot(&mut self, v: action::ActionTakeScreenshot) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_take_screenshot(&mut self) -> &mut action::ActionTakeScreenshot {
            if let ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(action::ActionTakeScreenshot::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_take_screenshot(&mut self) -> action::ActionTakeScreenshot {
            if self.has_action_take_screenshot() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionTakeScreenshot::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog action_generate_log = 5;

        pub fn action_generate_log(&self) -> &action::ActionGenerateLog {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionGenerateLog(ref v)) => v,
                _ => <action::ActionGenerateLog as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_generate_log(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_generate_log(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionGenerateLog(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_generate_log(&mut self, v: action::ActionGenerateLog) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionGenerateLog(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_generate_log(&mut self) -> &mut action::ActionGenerateLog {
            if let ::std::option::Option::Some(action::Action_type::ActionGenerateLog(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionGenerateLog(action::ActionGenerateLog::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionGenerateLog(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_generate_log(&mut self) -> action::ActionGenerateLog {
            if self.has_action_generate_log() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionGenerateLog(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionGenerateLog::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionFlushBuffers>(
                "action_flush_buffers",
                Action::has_action_flush_buffers,
                Action::action_flush_buffers,
                Action::mut_action_flush_buffers,
                Action::set_action_flush_buffers,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionEmitMetric>(
                "action_emit_metric",
                Action::has_action_emit_metric,
                Action::action_emit_metric,
                Action::mut_action_emit_metric,
                Action::set_action_emit_metric,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionEmitSankeyDiagram>(
                "action_emit_sankey_diagram",
                Action::has_action_emit_sankey_diagram,
                Action::action_emit_sankey_diagram,
                Action::mut_action_emit_sankey_diagram,
                Action::set_action_emit_sankey_diagram,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionTakeScreenshot>(
                "action_take_screenshot",
                Action::has_action_take_screenshot,
                Action::action_take_screenshot,
                Action::mut_action_take_screenshot,
                Action::set_action_take_screenshot,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionGenerateLog>(
                "action_generate_log",
                Action::has_action_generate_log,
                Action::action_generate_log,
                Action::mut_action_generate_log,
                Action::set_action_generate_log,
            ));
            oneofs.push(action::Action_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
                "Workflow.Action",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Action {
        const NAME: &'static str = "Action";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(is.read_message()?));
                    },
                    18 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(is.read_message()?));
                    },
                    26 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitSankeyDiagram(is.read_message()?));
                    },
                    34 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionTakeScreenshot(is.read_message()?));
                    },
                    42 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionGenerateLog(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.action_type {
                match v {
                    &action::Action_type::ActionFlushBuffers(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &action::Action_type::ActionEmitMetric(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &action::Action_type::ActionEmitSankeyDiagram(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &action::Action_type::ActionTakeScreenshot(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &action::Action_type::ActionGenerateLog(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.action_type {
                match v {
                    &action::Action_type::ActionFlushBuffers(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &action::Action_type::ActionEmitMetric(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &action::Action_type::ActionEmitSankeyDiagram(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                    &action::Action_type::ActionTakeScreenshot(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                    &action::Action_type::ActionGenerateLog(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Action {
            Action::new()
        }

        fn clear(&mut self) {
            self.action_type = ::std::option::Option::None;
            self.action_type = ::std::option::Option::None;
            self.action_type = ::std::option::Option::None;
            self.action_type = ::std::option::Option::None;
            self.action_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Action {
            static instance: Action = Action {
                action_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Action {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Action").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Action {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Action {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Action`
    pub mod action {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_type)
        pub enum Action_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_flush_buffers)
            ActionFlushBuffers(ActionFlushBuffers),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_emit_metric)
            ActionEmitMetric(ActionEmitMetric),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_emit_sankey_diagram)
            ActionEmitSankeyDiagram(ActionEmitSankeyDiagram),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_take_screenshot)
            ActionTakeScreenshot(ActionTakeScreenshot),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_generate_log)
            ActionGenerateLog(ActionGenerateLog),
        }

        impl ::protobuf::Oneof for Action_type {
        }

        impl ::protobuf::OneofFull for Action_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Action as ::protobuf::MessageFull>::descriptor().oneof_by_name("action_type").unwrap()).clone()
            }
        }

        impl Action_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action_type>("action_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionGenerateLog {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.message)
            pub message: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.fields)
            pub fields: ::std::vec::Vec<action_generate_log::GeneratedField>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.log_type)
            pub log_type: u32,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionGenerateLog {
            fn default() -> &'a ActionGenerateLog {
                <ActionGenerateLog as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionGenerateLog {
            pub fn new() -> ActionGenerateLog {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "message",
                    |m: &ActionGenerateLog| { &m.message },
                    |m: &mut ActionGenerateLog| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "fields",
                    |m: &ActionGenerateLog| { &m.fields },
                    |m: &mut ActionGenerateLog| { &mut m.fields },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionGenerateLog| { &m.id },
                    |m: &mut ActionGenerateLog| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "log_type",
                    |m: &ActionGenerateLog| { &m.log_type },
                    |m: &mut ActionGenerateLog| { &mut m.log_type },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionGenerateLog>(
                    "Workflow.Action.ActionGenerateLog",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionGenerateLog {
            const NAME: &'static str = "ActionGenerateLog";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.message = is.read_string()?;
                        },
                        18 => {
                            self.fields.push(is.read_message()?);
                        },
                        26 => {
                            self.id = is.read_string()?;
                        },
                        32 => {
                            self.log_type = is.read_uint32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.message.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.message);
                }
                for value in &self.fields {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.id);
                }
                if self.log_type != 0 {
                    my_size += ::protobuf::rt::uint32_size(4, self.log_type);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.message.is_empty() {
                    os.write_string(1, &self.message)?;
                }
                for v in &self.fields {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                };
                if !self.id.is_empty() {
                    os.write_string(3, &self.id)?;
                }
                if self.log_type != 0 {
                    os.write_uint32(4, self.log_type)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionGenerateLog {
                ActionGenerateLog::new()
            }

            fn clear(&mut self) {
                self.message.clear();
                self.fields.clear();
                self.id.clear();
                self.log_type = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionGenerateLog {
                static instance: ActionGenerateLog = ActionGenerateLog {
                    message: ::std::string::String::new(),
                    fields: ::std::vec::Vec::new(),
                    id: ::std::string::String::new(),
                    log_type: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionGenerateLog {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionGenerateLog").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionGenerateLog {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionGenerateLog {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ActionGenerateLog`
        pub mod action_generate_log {
            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct ValueReference {
                // message oneof groups
                pub value_reference_type: ::std::option::Option<value_reference::Value_reference_type>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a ValueReference {
                fn default() -> &'a ValueReference {
                    <ValueReference as ::protobuf::Message>::default_instance()
                }
            }

            impl ValueReference {
                pub fn new() -> ValueReference {
                    ::std::default::Default::default()
                }

                // string fixed = 1;

                pub fn fixed(&self) -> &str {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(ref v)) => v,
                        _ => "",
                    }
                }

                pub fn clear_fixed(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                }

                pub fn has_fixed(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_fixed(&mut self, v: ::std::string::String) {
                    self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(v))
                }

                // Mutable pointer to the field.
                pub fn mut_fixed(&mut self) -> &mut ::std::string::String {
                    if let ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(_)) = self.value_reference_type {
                    } else {
                        self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(::std::string::String::new()));
                    }
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_fixed(&mut self) -> ::std::string::String {
                    if self.has_fixed() {
                        match self.value_reference_type.take() {
                            ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ::std::string::String::new()
                    }
                }

                // string field_from_current_log = 2;

                pub fn field_from_current_log(&self) -> &str {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(ref v)) => v,
                        _ => "",
                    }
                }

                pub fn clear_field_from_current_log(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                }

                pub fn has_field_from_current_log(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_field_from_current_log(&mut self, v: ::std::string::String) {
                    self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(v))
                }

                // Mutable pointer to the field.
                pub fn mut_field_from_current_log(&mut self) -> &mut ::std::string::String {
                    if let ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(_)) = self.value_reference_type {
                    } else {
                        self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(::std::string::String::new()));
                    }
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_field_from_current_log(&mut self) -> ::std::string::String {
                    if self.has_field_from_current_log() {
                        match self.value_reference_type.take() {
                            ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ::std::string::String::new()
                    }
                }

                // string saved_field_id = 3;

                pub fn saved_field_id(&self) -> &str {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(ref v)) => v,
                        _ => "",
                    }
                }

                pub fn clear_saved_field_id(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                }

                pub fn has_saved_field_id(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_saved_field_id(&mut self, v: ::std::string::String) {
                    self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(v))
                }

                // Mutable pointer to the field.
                pub fn mut_saved_field_id(&mut self) -> &mut ::std::string::String {
                    if let ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(_)) = self.value_reference_type {
                    } else {
                        self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(::std::string::String::new()));
                    }
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_saved_field_id(&mut self) -> ::std::string::String {
                    if self.has_saved_field_id() {
                        match self.value_reference_type.take() {
                            ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ::std::string::String::new()
                    }
                }

                // string saved_timestamp_id = 4;

                pub fn saved_timestamp_id(&self) -> &str {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(ref v)) => v,
                        _ => "",
                    }
                }

                pub fn clear_saved_timestamp_id(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                }

                pub fn has_saved_timestamp_id(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_saved_timestamp_id(&mut self, v: ::std::string::String) {
                    self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(v))
                }

                // Mutable pointer to the field.
                pub fn mut_saved_timestamp_id(&mut self) -> &mut ::std::string::String {
                    if let ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(_)) = self.value_reference_type {
                    } else {
                        self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(::std::string::String::new()));
                    }
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_saved_timestamp_id(&mut self) -> ::std::string::String {
                    if self.has_saved_timestamp_id() {
                        match self.value_reference_type.take() {
                            ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ::std::string::String::new()
                    }
                }

                // bool uuid = 5;

                pub fn uuid(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::Uuid(v)) => v,
                        _ => false,
                    }
                }

                pub fn clear_uuid(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                }

                pub fn has_uuid(&self) -> bool {
                    match self.value_reference_type {
                        ::std::option::Option::Some(value_reference::Value_reference_type::Uuid(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_uuid(&mut self, v: bool) {
                    self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::Uuid(v))
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(5);
                    let mut oneofs = ::std::vec::Vec::with_capacity(1);
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                        "fixed",
                        ValueReference::has_fixed,
                        ValueReference::fixed,
                        ValueReference::set_fixed,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                        "field_from_current_log",
                        ValueReference::has_field_from_current_log,
                        ValueReference::field_from_current_log,
                        ValueReference::set_field_from_current_log,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                        "saved_field_id",
                        ValueReference::has_saved_field_id,
                        ValueReference::saved_field_id,
                        ValueReference::set_saved_field_id,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                        "saved_timestamp_id",
                        ValueReference::has_saved_timestamp_id,
                        ValueReference::saved_timestamp_id,
                        ValueReference::set_saved_timestamp_id,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                        "uuid",
                        ValueReference::has_uuid,
                        ValueReference::uuid,
                        ValueReference::set_uuid,
                    ));
                    oneofs.push(value_reference::Value_reference_type::generated_oneof_descriptor_data());
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueReference>(
                        "Workflow.Action.ActionGenerateLog.ValueReference",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for ValueReference {
                const NAME: &'static str = "ValueReference";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::Fixed(is.read_string()?));
                            },
                            18 => {
                                self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::FieldFromCurrentLog(is.read_string()?));
                            },
                            26 => {
                                self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedFieldId(is.read_string()?));
                            },
                            34 => {
                                self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::SavedTimestampId(is.read_string()?));
                            },
                            40 => {
                                self.value_reference_type = ::std::option::Option::Some(value_reference::Value_reference_type::Uuid(is.read_bool()?));
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let ::std::option::Option::Some(ref v) = self.value_reference_type {
                        match v {
                            &value_reference::Value_reference_type::Fixed(ref v) => {
                                my_size += ::protobuf::rt::string_size(1, &v);
                            },
                            &value_reference::Value_reference_type::FieldFromCurrentLog(ref v) => {
                                my_size += ::protobuf::rt::string_size(2, &v);
                            },
                            &value_reference::Value_reference_type::SavedFieldId(ref v) => {
                                my_size += ::protobuf::rt::string_size(3, &v);
                            },
                            &value_reference::Value_reference_type::SavedTimestampId(ref v) => {
                                my_size += ::protobuf::rt::string_size(4, &v);
                            },
                            &value_reference::Value_reference_type::Uuid(v) => {
                                my_size += 1 + 1;
                            },
                        };
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let ::std::option::Option::Some(ref v) = self.value_reference_type {
                        match v {
                            &value_reference::Value_reference_type::Fixed(ref v) => {
                                os.write_string(1, v)?;
                            },
                            &value_reference::Value_reference_type::FieldFromCurrentLog(ref v) => {
                                os.write_string(2, v)?;
                            },
                            &value_reference::Value_reference_type::SavedFieldId(ref v) => {
                                os.write_string(3, v)?;
                            },
                            &value_reference::Value_reference_type::SavedTimestampId(ref v) => {
                                os.write_string(4, v)?;
                            },
                            &value_reference::Value_reference_type::Uuid(v) => {
                                os.write_bool(5, v)?;
                            },
                        };
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> ValueReference {
                    ValueReference::new()
                }

                fn clear(&mut self) {
                    self.value_reference_type = ::std::option::Option::None;
                    self.value_reference_type = ::std::option::Option::None;
                    self.value_reference_type = ::std::option::Option::None;
                    self.value_reference_type = ::std::option::Option::None;
                    self.value_reference_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static ValueReference {
                    static instance: ValueReference = ValueReference {
                        value_reference_type: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for ValueReference {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionGenerateLog.ValueReference").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for ValueReference {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for ValueReference {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `ValueReference`
            pub mod value_reference {

                #[derive(Clone,PartialEq,Debug)]
                // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.value_reference_type)
                pub enum Value_reference_type {
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.fixed)
                    Fixed(::std::string::String),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.field_from_current_log)
                    FieldFromCurrentLog(::std::string::String),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.saved_field_id)
                    SavedFieldId(::std::string::String),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.saved_timestamp_id)
                    SavedTimestampId(::std::string::String),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference.uuid)
                    Uuid(bool),
                }

                impl ::protobuf::Oneof for Value_reference_type {
                }

                impl ::protobuf::OneofFull for Value_reference_type {
                    fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| <super::ValueReference as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_reference_type").unwrap()).clone()
                    }
                }

                impl Value_reference_type {
                    pub(in super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                        ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_reference_type>("value_reference_type")
                    }
                }
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct ValueReferencePair {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair.lhs)
                pub lhs: ::protobuf::MessageField<ValueReference>,
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair.rhs)
                pub rhs: ::protobuf::MessageField<ValueReference>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a ValueReferencePair {
                fn default() -> &'a ValueReferencePair {
                    <ValueReferencePair as ::protobuf::Message>::default_instance()
                }
            }

            impl ValueReferencePair {
                pub fn new() -> ValueReferencePair {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValueReference>(
                        "lhs",
                        |m: &ValueReferencePair| { &m.lhs },
                        |m: &mut ValueReferencePair| { &mut m.lhs },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ValueReference>(
                        "rhs",
                        |m: &ValueReferencePair| { &m.rhs },
                        |m: &mut ValueReferencePair| { &mut m.rhs },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValueReferencePair>(
                        "Workflow.Action.ActionGenerateLog.ValueReferencePair",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for ValueReferencePair {
                const NAME: &'static str = "ValueReferencePair";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.lhs)?;
                            },
                            18 => {
                                ::protobuf::rt::read_singular_message_into_field(is, &mut self.rhs)?;
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.lhs.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    if let Some(v) = self.rhs.as_ref() {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if let Some(v) = self.lhs.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    }
                    if let Some(v) = self.rhs.as_ref() {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> ValueReferencePair {
                    ValueReferencePair::new()
                }

                fn clear(&mut self) {
                    self.lhs.clear();
                    self.rhs.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static ValueReferencePair {
                    static instance: ValueReferencePair = ValueReferencePair {
                        lhs: ::protobuf::MessageField::none(),
                        rhs: ::protobuf::MessageField::none(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for ValueReferencePair {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionGenerateLog.ValueReferencePair").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for ValueReferencePair {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for ValueReferencePair {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct GeneratedField {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.name)
                pub name: ::std::string::String,
                // message oneof groups
                pub generated_field_value_type: ::std::option::Option<generated_field::Generated_field_value_type>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a GeneratedField {
                fn default() -> &'a GeneratedField {
                    <GeneratedField as ::protobuf::Message>::default_instance()
                }
            }

            impl GeneratedField {
                pub fn new() -> GeneratedField {
                    ::std::default::Default::default()
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReference single = 2;

                pub fn single(&self) -> &ValueReference {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(ref v)) => v,
                        _ => <ValueReference as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_single(&mut self) {
                    self.generated_field_value_type = ::std::option::Option::None;
                }

                pub fn has_single(&self) -> bool {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_single(&mut self, v: ValueReference) {
                    self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(v))
                }

                // Mutable pointer to the field.
                pub fn mut_single(&mut self) -> &mut ValueReference {
                    if let ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(_)) = self.generated_field_value_type {
                    } else {
                        self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(ValueReference::new()));
                    }
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_single(&mut self) -> ValueReference {
                    if self.has_single() {
                        match self.generated_field_value_type.take() {
                            ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ValueReference::new()
                    }
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair subtract = 3;

                pub fn subtract(&self) -> &ValueReferencePair {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(ref v)) => v,
                        _ => <ValueReferencePair as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_subtract(&mut self) {
                    self.generated_field_value_type = ::std::option::Option::None;
                }

                pub fn has_subtract(&self) -> bool {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_subtract(&mut self, v: ValueReferencePair) {
                    self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(v))
                }

                // Mutable pointer to the field.
                pub fn mut_subtract(&mut self) -> &mut ValueReferencePair {
                    if let ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(_)) = self.generated_field_value_type {
                    } else {
                        self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(ValueReferencePair::new()));
                    }
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_subtract(&mut self) -> ValueReferencePair {
                    if self.has_subtract() {
                        match self.generated_field_value_type.take() {
                            ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ValueReferencePair::new()
                    }
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair add = 4;

                pub fn add(&self) -> &ValueReferencePair {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(ref v)) => v,
                        _ => <ValueReferencePair as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_add(&mut self) {
                    self.generated_field_value_type = ::std::option::Option::None;
                }

                pub fn has_add(&self) -> bool {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_add(&mut self, v: ValueReferencePair) {
                    self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(v))
                }

                // Mutable pointer to the field.
                pub fn mut_add(&mut self) -> &mut ValueReferencePair {
                    if let ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(_)) = self.generated_field_value_type {
                    } else {
                        self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(ValueReferencePair::new()));
                    }
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_add(&mut self) -> ValueReferencePair {
                    if self.has_add() {
                        match self.generated_field_value_type.take() {
                            ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ValueReferencePair::new()
                    }
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair multiply = 5;

                pub fn multiply(&self) -> &ValueReferencePair {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(ref v)) => v,
                        _ => <ValueReferencePair as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_multiply(&mut self) {
                    self.generated_field_value_type = ::std::option::Option::None;
                }

                pub fn has_multiply(&self) -> bool {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_multiply(&mut self, v: ValueReferencePair) {
                    self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(v))
                }

                // Mutable pointer to the field.
                pub fn mut_multiply(&mut self) -> &mut ValueReferencePair {
                    if let ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(_)) = self.generated_field_value_type {
                    } else {
                        self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(ValueReferencePair::new()));
                    }
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_multiply(&mut self) -> ValueReferencePair {
                    if self.has_multiply() {
                        match self.generated_field_value_type.take() {
                            ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ValueReferencePair::new()
                    }
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePair divide = 6;

                pub fn divide(&self) -> &ValueReferencePair {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(ref v)) => v,
                        _ => <ValueReferencePair as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_divide(&mut self) {
                    self.generated_field_value_type = ::std::option::Option::None;
                }

                pub fn has_divide(&self) -> bool {
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_divide(&mut self, v: ValueReferencePair) {
                    self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(v))
                }

                // Mutable pointer to the field.
                pub fn mut_divide(&mut self) -> &mut ValueReferencePair {
                    if let ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(_)) = self.generated_field_value_type {
                    } else {
                        self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(ValueReferencePair::new()));
                    }
                    match self.generated_field_value_type {
                        ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_divide(&mut self) -> ValueReferencePair {
                    if self.has_divide() {
                        match self.generated_field_value_type.take() {
                            ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ValueReferencePair::new()
                    }
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(6);
                    let mut oneofs = ::std::vec::Vec::with_capacity(1);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "name",
                        |m: &GeneratedField| { &m.name },
                        |m: &mut GeneratedField| { &mut m.name },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueReference>(
                        "single",
                        GeneratedField::has_single,
                        GeneratedField::single,
                        GeneratedField::mut_single,
                        GeneratedField::set_single,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueReferencePair>(
                        "subtract",
                        GeneratedField::has_subtract,
                        GeneratedField::subtract,
                        GeneratedField::mut_subtract,
                        GeneratedField::set_subtract,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueReferencePair>(
                        "add",
                        GeneratedField::has_add,
                        GeneratedField::add,
                        GeneratedField::mut_add,
                        GeneratedField::set_add,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueReferencePair>(
                        "multiply",
                        GeneratedField::has_multiply,
                        GeneratedField::multiply,
                        GeneratedField::mut_multiply,
                        GeneratedField::set_multiply,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ValueReferencePair>(
                        "divide",
                        GeneratedField::has_divide,
                        GeneratedField::divide,
                        GeneratedField::mut_divide,
                        GeneratedField::set_divide,
                    ));
                    oneofs.push(generated_field::Generated_field_value_type::generated_oneof_descriptor_data());
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeneratedField>(
                        "Workflow.Action.ActionGenerateLog.GeneratedField",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for GeneratedField {
                const NAME: &'static str = "GeneratedField";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.name = is.read_string()?;
                            },
                            18 => {
                                self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Single(is.read_message()?));
                            },
                            26 => {
                                self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Subtract(is.read_message()?));
                            },
                            34 => {
                                self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Add(is.read_message()?));
                            },
                            42 => {
                                self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Multiply(is.read_message()?));
                            },
                            50 => {
                                self.generated_field_value_type = ::std::option::Option::Some(generated_field::Generated_field_value_type::Divide(is.read_message()?));
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.name.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.name);
                    }
                    if let ::std::option::Option::Some(ref v) = self.generated_field_value_type {
                        match v {
                            &generated_field::Generated_field_value_type::Single(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                            &generated_field::Generated_field_value_type::Subtract(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                            &generated_field::Generated_field_value_type::Add(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                            &generated_field::Generated_field_value_type::Multiply(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                            &generated_field::Generated_field_value_type::Divide(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                        };
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.name.is_empty() {
                        os.write_string(1, &self.name)?;
                    }
                    if let ::std::option::Option::Some(ref v) = self.generated_field_value_type {
                        match v {
                            &generated_field::Generated_field_value_type::Single(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                            },
                            &generated_field::Generated_field_value_type::Subtract(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                            },
                            &generated_field::Generated_field_value_type::Add(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                            },
                            &generated_field::Generated_field_value_type::Multiply(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                            },
                            &generated_field::Generated_field_value_type::Divide(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                            },
                        };
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> GeneratedField {
                    GeneratedField::new()
                }

                fn clear(&mut self) {
                    self.name.clear();
                    self.generated_field_value_type = ::std::option::Option::None;
                    self.generated_field_value_type = ::std::option::Option::None;
                    self.generated_field_value_type = ::std::option::Option::None;
                    self.generated_field_value_type = ::std::option::Option::None;
                    self.generated_field_value_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static GeneratedField {
                    static instance: GeneratedField = GeneratedField {
                        name: ::std::string::String::new(),
                        generated_field_value_type: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for GeneratedField {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionGenerateLog.GeneratedField").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for GeneratedField {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for GeneratedField {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `GeneratedField`
            pub mod generated_field {

                #[derive(Clone,PartialEq,Debug)]
                // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.generated_field_value_type)
                pub enum Generated_field_value_type {
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.single)
                    Single(super::ValueReference),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.subtract)
                    Subtract(super::ValueReferencePair),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.add)
                    Add(super::ValueReferencePair),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.multiply)
                    Multiply(super::ValueReferencePair),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.GeneratedField.divide)
                    Divide(super::ValueReferencePair),
                }

                impl ::protobuf::Oneof for Generated_field_value_type {
                }

                impl ::protobuf::OneofFull for Generated_field_value_type {
                    fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| <super::GeneratedField as ::protobuf::MessageFull>::descriptor().oneof_by_name("generated_field_value_type").unwrap()).clone()
                    }
                }

                impl Generated_field_value_type {
                    pub(in super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                        ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Generated_field_value_type>("generated_field_value_type")
                    }
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionFlushBuffers {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.buffer_ids)
            pub buffer_ids: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.streaming)
            pub streaming: ::protobuf::MessageField<action_flush_buffers::Streaming>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionFlushBuffers {
            fn default() -> &'a ActionFlushBuffers {
                <ActionFlushBuffers as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionFlushBuffers {
            pub fn new() -> ActionFlushBuffers {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "buffer_ids",
                    |m: &ActionFlushBuffers| { &m.buffer_ids },
                    |m: &mut ActionFlushBuffers| { &mut m.buffer_ids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionFlushBuffers| { &m.id },
                    |m: &mut ActionFlushBuffers| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, action_flush_buffers::Streaming>(
                    "streaming",
                    |m: &ActionFlushBuffers| { &m.streaming },
                    |m: &mut ActionFlushBuffers| { &mut m.streaming },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionFlushBuffers>(
                    "Workflow.Action.ActionFlushBuffers",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionFlushBuffers {
            const NAME: &'static str = "ActionFlushBuffers";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.buffer_ids.push(is.read_string()?);
                        },
                        18 => {
                            self.id = is.read_string()?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.streaming)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.buffer_ids {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.id);
                }
                if let Some(v) = self.streaming.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.buffer_ids {
                    os.write_string(1, &v)?;
                };
                if !self.id.is_empty() {
                    os.write_string(2, &self.id)?;
                }
                if let Some(v) = self.streaming.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionFlushBuffers {
                ActionFlushBuffers::new()
            }

            fn clear(&mut self) {
                self.buffer_ids.clear();
                self.id.clear();
                self.streaming.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionFlushBuffers {
                static instance: ActionFlushBuffers = ActionFlushBuffers {
                    buffer_ids: ::std::vec::Vec::new(),
                    id: ::std::string::String::new(),
                    streaming: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionFlushBuffers {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionFlushBuffers {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionFlushBuffers {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ActionFlushBuffers`
        pub mod action_flush_buffers {
            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Streaming {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.destination_streaming_buffer_ids)
                pub destination_streaming_buffer_ids: ::std::vec::Vec<::std::string::String>,
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.termination_criteria)
                pub termination_criteria: ::std::vec::Vec<streaming::TerminationCriterion>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Streaming {
                fn default() -> &'a Streaming {
                    <Streaming as ::protobuf::Message>::default_instance()
                }
            }

            impl Streaming {
                pub fn new() -> Streaming {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "destination_streaming_buffer_ids",
                        |m: &Streaming| { &m.destination_streaming_buffer_ids },
                        |m: &mut Streaming| { &mut m.destination_streaming_buffer_ids },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "termination_criteria",
                        |m: &Streaming| { &m.termination_criteria },
                        |m: &mut Streaming| { &mut m.termination_criteria },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Streaming>(
                        "Workflow.Action.ActionFlushBuffers.Streaming",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Streaming {
                const NAME: &'static str = "Streaming";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.destination_streaming_buffer_ids.push(is.read_string()?);
                            },
                            18 => {
                                self.termination_criteria.push(is.read_message()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    for value in &self.destination_streaming_buffer_ids {
                        my_size += ::protobuf::rt::string_size(1, &value);
                    };
                    for value in &self.termination_criteria {
                        let len = value.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    for v in &self.destination_streaming_buffer_ids {
                        os.write_string(1, &v)?;
                    };
                    for v in &self.termination_criteria {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Streaming {
                    Streaming::new()
                }

                fn clear(&mut self) {
                    self.destination_streaming_buffer_ids.clear();
                    self.termination_criteria.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Streaming {
                    static instance: Streaming = Streaming {
                        destination_streaming_buffer_ids: ::std::vec::Vec::new(),
                        termination_criteria: ::std::vec::Vec::new(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Streaming {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Streaming {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Streaming {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `Streaming`
            pub mod streaming {
                // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct TerminationCriterion {
                    // message oneof groups
                    pub type_: ::std::option::Option<termination_criterion::Type>,
                    // special fields
                    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a TerminationCriterion {
                    fn default() -> &'a TerminationCriterion {
                        <TerminationCriterion as ::protobuf::Message>::default_instance()
                    }
                }

                impl TerminationCriterion {
                    pub fn new() -> TerminationCriterion {
                        ::std::default::Default::default()
                    }

                    // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount logs_count = 1;

                    pub fn logs_count(&self) -> &termination_criterion::LogsCount {
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(ref v)) => v,
                            _ => <termination_criterion::LogsCount as ::protobuf::Message>::default_instance(),
                        }
                    }

                    pub fn clear_logs_count(&mut self) {
                        self.type_ = ::std::option::Option::None;
                    }

                    pub fn has_logs_count(&self) -> bool {
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(..)) => true,
                            _ => false,
                        }
                    }

                    // Param is passed by value, moved
                    pub fn set_logs_count(&mut self, v: termination_criterion::LogsCount) {
                        self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(v))
                    }

                    // Mutable pointer to the field.
                    pub fn mut_logs_count(&mut self) -> &mut termination_criterion::LogsCount {
                        if let ::std::option::Option::Some(termination_criterion::Type::LogsCount(_)) = self.type_ {
                        } else {
                            self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(termination_criterion::LogsCount::new()));
                        }
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(ref mut v)) => v,
                            _ => panic!(),
                        }
                    }

                    // Take field
                    pub fn take_logs_count(&mut self) -> termination_criterion::LogsCount {
                        if self.has_logs_count() {
                            match self.type_.take() {
                                ::std::option::Option::Some(termination_criterion::Type::LogsCount(v)) => v,
                                _ => panic!(),
                            }
                        } else {
                            termination_criterion::LogsCount::new()
                        }
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(1);
                        let mut oneofs = ::std::vec::Vec::with_capacity(1);
                        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, termination_criterion::LogsCount>(
                            "logs_count",
                            TerminationCriterion::has_logs_count,
                            TerminationCriterion::logs_count,
                            TerminationCriterion::mut_logs_count,
                            TerminationCriterion::set_logs_count,
                        ));
                        oneofs.push(termination_criterion::Type::generated_oneof_descriptor_data());
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TerminationCriterion>(
                            "Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for TerminationCriterion {
                    const NAME: &'static str = "TerminationCriterion";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => {
                                    self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(is.read_message()?));
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let ::std::option::Option::Some(ref v) = self.type_ {
                            match v {
                                &termination_criterion::Type::LogsCount(ref v) => {
                                    let len = v.compute_size();
                                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                                },
                            };
                        }
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let ::std::option::Option::Some(ref v) = self.type_ {
                            match v {
                                &termination_criterion::Type::LogsCount(ref v) => {
                                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                                },
                            };
                        }
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> TerminationCriterion {
                        TerminationCriterion::new()
                    }

                    fn clear(&mut self) {
                        self.type_ = ::std::option::Option::None;
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static TerminationCriterion {
                        static instance: TerminationCriterion = TerminationCriterion {
                            type_: ::std::option::Option::None,
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for TerminationCriterion {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for TerminationCriterion {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for TerminationCriterion {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }

                /// Nested message and enums of message `TerminationCriterion`
                pub mod termination_criterion {

                    #[derive(Clone,PartialEq,Debug)]
                    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.type)
                    pub enum Type {
                        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.logs_count)
                        LogsCount(LogsCount),
                    }

                    impl ::protobuf::Oneof for Type {
                    }

                    impl ::protobuf::OneofFull for Type {
                        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| <super::TerminationCriterion as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
                        }
                    }

                    impl Type {
                        pub(in super::super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
                        }
                    }
                    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct LogsCount {
                        // message fields
                        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount.max_logs_count)
                        pub max_logs_count: u64,
                        // special fields
                        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount.special_fields)
                        pub special_fields: ::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a LogsCount {
                        fn default() -> &'a LogsCount {
                            <LogsCount as ::protobuf::Message>::default_instance()
                        }
                    }

                    impl LogsCount {
                        pub fn new() -> LogsCount {
                            ::std::default::Default::default()
                        }

                        pub(in super::super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                            let mut fields = ::std::vec::Vec::with_capacity(1);
                            let mut oneofs = ::std::vec::Vec::with_capacity(0);
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "max_logs_count",
                                |m: &LogsCount| { &m.max_logs_count },
                                |m: &mut LogsCount| { &mut m.max_logs_count },
                            ));
                            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogsCount>(
                                "Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount",
                                fields,
                                oneofs,
                            )
                        }
                    }

                    impl ::protobuf::Message for LogsCount {
                        const NAME: &'static str = "LogsCount";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.max_logs_count = is.read_uint64()?;
                                    },
                                    tag => {
                                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if self.max_logs_count != 0 {
                                my_size += ::protobuf::rt::uint64_size(1, self.max_logs_count);
                            }
                            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                            if self.max_logs_count != 0 {
                                os.write_uint64(1, self.max_logs_count)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> LogsCount {
                            LogsCount::new()
                        }

                        fn clear(&mut self) {
                            self.max_logs_count = 0;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static LogsCount {
                            static instance: LogsCount = LogsCount {
                                max_logs_count: 0,
                                special_fields: ::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }

                    impl ::protobuf::MessageFull for LogsCount {
                        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| super::super::super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount").unwrap()).clone()
                        }
                    }

                    impl ::std::fmt::Display for LogsCount {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            ::protobuf::text_format::fmt(self, f)
                        }
                    }

                    impl ::protobuf::reflect::ProtobufValue for LogsCount {
                        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                    }
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionEmitMetric {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.tags)
            pub tags: ::std::vec::Vec<Tag>,
            // message oneof groups
            pub metric_type: ::std::option::Option<action_emit_metric::Metric_type>,
            pub value_extractor_type: ::std::option::Option<action_emit_metric::Value_extractor_type>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionEmitMetric {
            fn default() -> &'a ActionEmitMetric {
                <ActionEmitMetric as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionEmitMetric {
            pub fn new() -> ActionEmitMetric {
                ::std::default::Default::default()
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter counter = 2;

            pub fn counter(&self) -> &action_emit_metric::Counter {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(ref v)) => v,
                    _ => <action_emit_metric::Counter as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_counter(&mut self) {
                self.metric_type = ::std::option::Option::None;
            }

            pub fn has_counter(&self) -> bool {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_counter(&mut self, v: action_emit_metric::Counter) {
                self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(v))
            }

            // Mutable pointer to the field.
            pub fn mut_counter(&mut self) -> &mut action_emit_metric::Counter {
                if let ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(_)) = self.metric_type {
                } else {
                    self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(action_emit_metric::Counter::new()));
                }
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_counter(&mut self) -> action_emit_metric::Counter {
                if self.has_counter() {
                    match self.metric_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    action_emit_metric::Counter::new()
                }
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram histogram = 5;

            pub fn histogram(&self) -> &action_emit_metric::Histogram {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(ref v)) => v,
                    _ => <action_emit_metric::Histogram as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_histogram(&mut self) {
                self.metric_type = ::std::option::Option::None;
            }

            pub fn has_histogram(&self) -> bool {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_histogram(&mut self, v: action_emit_metric::Histogram) {
                self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(v))
            }

            // Mutable pointer to the field.
            pub fn mut_histogram(&mut self) -> &mut action_emit_metric::Histogram {
                if let ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(_)) = self.metric_type {
                } else {
                    self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(action_emit_metric::Histogram::new()));
                }
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_histogram(&mut self) -> action_emit_metric::Histogram {
                if self.has_histogram() {
                    match self.metric_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    action_emit_metric::Histogram::new()
                }
            }

            // uint32 fixed = 3;

            pub fn fixed(&self) -> u32 {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(v)) => v,
                    _ => 0,
                }
            }

            pub fn clear_fixed(&mut self) {
                self.value_extractor_type = ::std::option::Option::None;
            }

            pub fn has_fixed(&self) -> bool {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_fixed(&mut self, v: u32) {
                self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(v))
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted field_extracted = 6;

            pub fn field_extracted(&self) -> &super::FieldExtracted {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(ref v)) => v,
                    _ => <super::FieldExtracted as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_field_extracted(&mut self) {
                self.value_extractor_type = ::std::option::Option::None;
            }

            pub fn has_field_extracted(&self) -> bool {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_field_extracted(&mut self, v: super::FieldExtracted) {
                self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(v))
            }

            // Mutable pointer to the field.
            pub fn mut_field_extracted(&mut self) -> &mut super::FieldExtracted {
                if let ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(_)) = self.value_extractor_type {
                } else {
                    self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(super::FieldExtracted::new()));
                }
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_field_extracted(&mut self) -> super::FieldExtracted {
                if self.has_field_extracted() {
                    match self.value_extractor_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::FieldExtracted::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(2);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionEmitMetric| { &m.id },
                    |m: &mut ActionEmitMetric| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action_emit_metric::Counter>(
                    "counter",
                    ActionEmitMetric::has_counter,
                    ActionEmitMetric::counter,
                    ActionEmitMetric::mut_counter,
                    ActionEmitMetric::set_counter,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action_emit_metric::Histogram>(
                    "histogram",
                    ActionEmitMetric::has_histogram,
                    ActionEmitMetric::histogram,
                    ActionEmitMetric::mut_histogram,
                    ActionEmitMetric::set_histogram,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                    "fixed",
                    ActionEmitMetric::has_fixed,
                    ActionEmitMetric::fixed,
                    ActionEmitMetric::set_fixed,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FieldExtracted>(
                    "field_extracted",
                    ActionEmitMetric::has_field_extracted,
                    ActionEmitMetric::field_extracted,
                    ActionEmitMetric::mut_field_extracted,
                    ActionEmitMetric::set_field_extracted,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tags",
                    |m: &ActionEmitMetric| { &m.tags },
                    |m: &mut ActionEmitMetric| { &mut m.tags },
                ));
                oneofs.push(action_emit_metric::Metric_type::generated_oneof_descriptor_data());
                oneofs.push(action_emit_metric::Value_extractor_type::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionEmitMetric>(
                    "Workflow.Action.ActionEmitMetric",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionEmitMetric {
            const NAME: &'static str = "ActionEmitMetric";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        18 => {
                            self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(is.read_message()?));
                        },
                        42 => {
                            self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(is.read_message()?));
                        },
                        24 => {
                            self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(is.read_uint32()?));
                        },
                        50 => {
                            self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(is.read_message()?));
                        },
                        34 => {
                            self.tags.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                for value in &self.tags {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let ::std::option::Option::Some(ref v) = self.metric_type {
                    match v {
                        &action_emit_metric::Metric_type::Counter(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &action_emit_metric::Metric_type::Histogram(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                if let ::std::option::Option::Some(ref v) = self.value_extractor_type {
                    match v {
                        &action_emit_metric::Value_extractor_type::Fixed(v) => {
                            my_size += ::protobuf::rt::uint32_size(3, v);
                        },
                        &action_emit_metric::Value_extractor_type::FieldExtracted(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                for v in &self.tags {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                if let ::std::option::Option::Some(ref v) = self.metric_type {
                    match v {
                        &action_emit_metric::Metric_type::Counter(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                        &action_emit_metric::Metric_type::Histogram(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                        },
                    };
                }
                if let ::std::option::Option::Some(ref v) = self.value_extractor_type {
                    match v {
                        &action_emit_metric::Value_extractor_type::Fixed(v) => {
                            os.write_uint32(3, v)?;
                        },
                        &action_emit_metric::Value_extractor_type::FieldExtracted(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionEmitMetric {
                ActionEmitMetric::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.metric_type = ::std::option::Option::None;
                self.metric_type = ::std::option::Option::None;
                self.value_extractor_type = ::std::option::Option::None;
                self.value_extractor_type = ::std::option::Option::None;
                self.tags.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionEmitMetric {
                static instance: ActionEmitMetric = ActionEmitMetric {
                    id: ::std::string::String::new(),
                    tags: ::std::vec::Vec::new(),
                    metric_type: ::std::option::Option::None,
                    value_extractor_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionEmitMetric {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionEmitMetric {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionEmitMetric {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ActionEmitMetric`
        pub mod action_emit_metric {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.metric_type)
            pub enum Metric_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.counter)
                Counter(Counter),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.histogram)
                Histogram(Histogram),
            }

            impl ::protobuf::Oneof for Metric_type {
            }

            impl ::protobuf::OneofFull for Metric_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::ActionEmitMetric as ::protobuf::MessageFull>::descriptor().oneof_by_name("metric_type").unwrap()).clone()
                }
            }

            impl Metric_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Metric_type>("metric_type")
                }
            }

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.value_extractor_type)
            pub enum Value_extractor_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.fixed)
                Fixed(u32),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.field_extracted)
                FieldExtracted(super::super::FieldExtracted),
            }

            impl ::protobuf::Oneof for Value_extractor_type {
            }

            impl ::protobuf::OneofFull for Value_extractor_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::ActionEmitMetric as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_extractor_type").unwrap()).clone()
                }
            }

            impl Value_extractor_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_extractor_type>("value_extractor_type")
                }
            }
            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Counter {
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Counter {
                fn default() -> &'a Counter {
                    <Counter as ::protobuf::Message>::default_instance()
                }
            }

            impl Counter {
                pub fn new() -> Counter {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(0);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Counter>(
                        "Workflow.Action.ActionEmitMetric.Counter",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Counter {
                const NAME: &'static str = "Counter";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Counter {
                    Counter::new()
                }

                fn clear(&mut self) {
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Counter {
                    static instance: Counter = Counter {
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Counter {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.Counter").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Counter {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Counter {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Histogram {
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Histogram {
                fn default() -> &'a Histogram {
                    <Histogram as ::protobuf::Message>::default_instance()
                }
            }

            impl Histogram {
                pub fn new() -> Histogram {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(0);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Histogram>(
                        "Workflow.Action.ActionEmitMetric.Histogram",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Histogram {
                const NAME: &'static str = "Histogram";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Histogram {
                    Histogram::new()
                }

                fn clear(&mut self) {
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Histogram {
                    static instance: Histogram = Histogram {
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Histogram {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.Histogram").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Histogram {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Histogram {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionEmitSankeyDiagram {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram.limit)
            pub limit: u32,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram.tags)
            pub tags: ::std::vec::Vec<Tag>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitSankeyDiagram.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionEmitSankeyDiagram {
            fn default() -> &'a ActionEmitSankeyDiagram {
                <ActionEmitSankeyDiagram as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionEmitSankeyDiagram {
            pub fn new() -> ActionEmitSankeyDiagram {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionEmitSankeyDiagram| { &m.id },
                    |m: &mut ActionEmitSankeyDiagram| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "limit",
                    |m: &ActionEmitSankeyDiagram| { &m.limit },
                    |m: &mut ActionEmitSankeyDiagram| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tags",
                    |m: &ActionEmitSankeyDiagram| { &m.tags },
                    |m: &mut ActionEmitSankeyDiagram| { &mut m.tags },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionEmitSankeyDiagram>(
                    "Workflow.Action.ActionEmitSankeyDiagram",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionEmitSankeyDiagram {
            const NAME: &'static str = "ActionEmitSankeyDiagram";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        16 => {
                            self.limit = is.read_uint32()?;
                        },
                        26 => {
                            self.tags.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                if self.limit != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.limit);
                }
                for value in &self.tags {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                if self.limit != 0 {
                    os.write_uint32(2, self.limit)?;
                }
                for v in &self.tags {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionEmitSankeyDiagram {
                ActionEmitSankeyDiagram::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.limit = 0;
                self.tags.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionEmitSankeyDiagram {
                static instance: ActionEmitSankeyDiagram = ActionEmitSankeyDiagram {
                    id: ::std::string::String::new(),
                    limit: 0,
                    tags: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionEmitSankeyDiagram {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitSankeyDiagram").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionEmitSankeyDiagram {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionEmitSankeyDiagram {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Tag {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag.name)
            pub name: ::std::string::String,
            // message oneof groups
            pub tag_type: ::std::option::Option<tag::Tag_type>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Tag {
            fn default() -> &'a Tag {
                <Tag as ::protobuf::Message>::default_instance()
            }
        }

        impl Tag {
            pub fn new() -> Tag {
                ::std::default::Default::default()
            }

            // string fixed_value = 2;

            pub fn fixed_value(&self) -> &str {
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FixedValue(ref v)) => v,
                    _ => "",
                }
            }

            pub fn clear_fixed_value(&mut self) {
                self.tag_type = ::std::option::Option::None;
            }

            pub fn has_fixed_value(&self) -> bool {
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FixedValue(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_fixed_value(&mut self, v: ::std::string::String) {
                self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(v))
            }

            // Mutable pointer to the field.
            pub fn mut_fixed_value(&mut self) -> &mut ::std::string::String {
                if let ::std::option::Option::Some(tag::Tag_type::FixedValue(_)) = self.tag_type {
                } else {
                    self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(::std::string::String::new()));
                }
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FixedValue(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_fixed_value(&mut self) -> ::std::string::String {
                if self.has_fixed_value() {
                    match self.tag_type.take() {
                        ::std::option::Option::Some(tag::Tag_type::FixedValue(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    ::std::string::String::new()
                }
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted field_extracted = 3;

            pub fn field_extracted(&self) -> &super::FieldExtracted {
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FieldExtracted(ref v)) => v,
                    _ => <super::FieldExtracted as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_field_extracted(&mut self) {
                self.tag_type = ::std::option::Option::None;
            }

            pub fn has_field_extracted(&self) -> bool {
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FieldExtracted(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_field_extracted(&mut self, v: super::FieldExtracted) {
                self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(v))
            }

            // Mutable pointer to the field.
            pub fn mut_field_extracted(&mut self) -> &mut super::FieldExtracted {
                if let ::std::option::Option::Some(tag::Tag_type::FieldExtracted(_)) = self.tag_type {
                } else {
                    self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(super::FieldExtracted::new()));
                }
                match self.tag_type {
                    ::std::option::Option::Some(tag::Tag_type::FieldExtracted(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_field_extracted(&mut self) -> super::FieldExtracted {
                if self.has_field_extracted() {
                    match self.tag_type.take() {
                        ::std::option::Option::Some(tag::Tag_type::FieldExtracted(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::FieldExtracted::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "name",
                    |m: &Tag| { &m.name },
                    |m: &mut Tag| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                    "fixed_value",
                    Tag::has_fixed_value,
                    Tag::fixed_value,
                    Tag::set_fixed_value,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::FieldExtracted>(
                    "field_extracted",
                    Tag::has_field_extracted,
                    Tag::field_extracted,
                    Tag::mut_field_extracted,
                    Tag::set_field_extracted,
                ));
                oneofs.push(tag::Tag_type::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                    "Workflow.Action.Tag",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Tag {
            const NAME: &'static str = "Tag";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = is.read_string()?;
                        },
                        18 => {
                            self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(is.read_string()?));
                        },
                        26 => {
                            self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.name);
                }
                if let ::std::option::Option::Some(ref v) = self.tag_type {
                    match v {
                        &tag::Tag_type::FixedValue(ref v) => {
                            my_size += ::protobuf::rt::string_size(2, &v);
                        },
                        &tag::Tag_type::FieldExtracted(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.name.is_empty() {
                    os.write_string(1, &self.name)?;
                }
                if let ::std::option::Option::Some(ref v) = self.tag_type {
                    match v {
                        &tag::Tag_type::FixedValue(ref v) => {
                            os.write_string(2, v)?;
                        },
                        &tag::Tag_type::FieldExtracted(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Tag {
                Tag::new()
            }

            fn clear(&mut self) {
                self.name.clear();
                self.tag_type = ::std::option::Option::None;
                self.tag_type = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Tag {
                static instance: Tag = Tag {
                    name: ::std::string::String::new(),
                    tag_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Tag {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.Tag").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Tag {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Tag {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `Tag`
        pub mod tag {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag.tag_type)
            pub enum Tag_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag.fixed_value)
                FixedValue(::std::string::String),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.Tag.field_extracted)
                FieldExtracted(super::super::FieldExtracted),
            }

            impl ::protobuf::Oneof for Tag_type {
            }

            impl ::protobuf::OneofFull for Tag_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::Tag as ::protobuf::MessageFull>::descriptor().oneof_by_name("tag_type").unwrap()).clone()
                }
            }

            impl Tag_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Tag_type>("tag_type")
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionTakeScreenshot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionTakeScreenshot {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionTakeScreenshot.id)
            pub id: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionTakeScreenshot.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionTakeScreenshot {
            fn default() -> &'a ActionTakeScreenshot {
                <ActionTakeScreenshot as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionTakeScreenshot {
            pub fn new() -> ActionTakeScreenshot {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionTakeScreenshot| { &m.id },
                    |m: &mut ActionTakeScreenshot| { &mut m.id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionTakeScreenshot>(
                    "Workflow.Action.ActionTakeScreenshot",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionTakeScreenshot {
            const NAME: &'static str = "ActionTakeScreenshot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionTakeScreenshot {
                ActionTakeScreenshot::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionTakeScreenshot {
                static instance: ActionTakeScreenshot = ActionTakeScreenshot {
                    id: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionTakeScreenshot {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionTakeScreenshot").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionTakeScreenshot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionTakeScreenshot {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Execution {
        // message oneof groups
        pub execution_type: ::std::option::Option<execution::Execution_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Execution {
        fn default() -> &'a Execution {
            <Execution as ::protobuf::Message>::default_instance()
        }
    }

    impl Execution {
        pub fn new() -> Execution {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive execution_exclusive = 1;

        pub fn execution_exclusive(&self) -> &execution::ExecutionExclusive {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(ref v)) => v,
                _ => <execution::ExecutionExclusive as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_execution_exclusive(&mut self) {
            self.execution_type = ::std::option::Option::None;
        }

        pub fn has_execution_exclusive(&self) -> bool {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_execution_exclusive(&mut self, v: execution::ExecutionExclusive) {
            self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(v))
        }

        // Mutable pointer to the field.
        pub fn mut_execution_exclusive(&mut self) -> &mut execution::ExecutionExclusive {
            if let ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(_)) = self.execution_type {
            } else {
                self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(execution::ExecutionExclusive::new()));
            }
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_execution_exclusive(&mut self) -> execution::ExecutionExclusive {
            if self.has_execution_exclusive() {
                match self.execution_type.take() {
                    ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(v)) => v,
                    _ => panic!(),
                }
            } else {
                execution::ExecutionExclusive::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel execution_parallel = 2;

        pub fn execution_parallel(&self) -> &execution::ExecutionParallel {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(ref v)) => v,
                _ => <execution::ExecutionParallel as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_execution_parallel(&mut self) {
            self.execution_type = ::std::option::Option::None;
        }

        pub fn has_execution_parallel(&self) -> bool {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_execution_parallel(&mut self, v: execution::ExecutionParallel) {
            self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(v))
        }

        // Mutable pointer to the field.
        pub fn mut_execution_parallel(&mut self) -> &mut execution::ExecutionParallel {
            if let ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(_)) = self.execution_type {
            } else {
                self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(execution::ExecutionParallel::new()));
            }
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_execution_parallel(&mut self) -> execution::ExecutionParallel {
            if self.has_execution_parallel() {
                match self.execution_type.take() {
                    ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(v)) => v,
                    _ => panic!(),
                }
            } else {
                execution::ExecutionParallel::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, execution::ExecutionExclusive>(
                "execution_exclusive",
                Execution::has_execution_exclusive,
                Execution::execution_exclusive,
                Execution::mut_execution_exclusive,
                Execution::set_execution_exclusive,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, execution::ExecutionParallel>(
                "execution_parallel",
                Execution::has_execution_parallel,
                Execution::execution_parallel,
                Execution::mut_execution_parallel,
                Execution::set_execution_parallel,
            ));
            oneofs.push(execution::Execution_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Execution>(
                "Workflow.Execution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Execution {
        const NAME: &'static str = "Execution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(is.read_message()?));
                    },
                    18 => {
                        self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.execution_type {
                match v {
                    &execution::Execution_type::ExecutionExclusive(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &execution::Execution_type::ExecutionParallel(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.execution_type {
                match v {
                    &execution::Execution_type::ExecutionExclusive(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &execution::Execution_type::ExecutionParallel(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Execution {
            Execution::new()
        }

        fn clear(&mut self) {
            self.execution_type = ::std::option::Option::None;
            self.execution_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Execution {
            static instance: Execution = Execution {
                execution_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Execution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Execution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Execution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Execution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Execution`
    pub mod execution {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_type)
        pub enum Execution_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_exclusive)
            ExecutionExclusive(ExecutionExclusive),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_parallel)
            ExecutionParallel(ExecutionParallel),
        }

        impl ::protobuf::Oneof for Execution_type {
        }

        impl ::protobuf::OneofFull for Execution_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Execution as ::protobuf::MessageFull>::descriptor().oneof_by_name("execution_type").unwrap()).clone()
            }
        }

        impl Execution_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Execution_type>("execution_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ExecutionExclusive {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ExecutionExclusive {
            fn default() -> &'a ExecutionExclusive {
                <ExecutionExclusive as ::protobuf::Message>::default_instance()
            }
        }

        impl ExecutionExclusive {
            pub fn new() -> ExecutionExclusive {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionExclusive>(
                    "Workflow.Execution.ExecutionExclusive",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ExecutionExclusive {
            const NAME: &'static str = "ExecutionExclusive";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ExecutionExclusive {
                ExecutionExclusive::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ExecutionExclusive {
                static instance: ExecutionExclusive = ExecutionExclusive {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ExecutionExclusive {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Execution.ExecutionExclusive").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ExecutionExclusive {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ExecutionExclusive {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ExecutionParallel {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ExecutionParallel {
            fn default() -> &'a ExecutionParallel {
                <ExecutionParallel as ::protobuf::Message>::default_instance()
            }
        }

        impl ExecutionParallel {
            pub fn new() -> ExecutionParallel {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionParallel>(
                    "Workflow.Execution.ExecutionParallel",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ExecutionParallel {
            const NAME: &'static str = "ExecutionParallel";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ExecutionParallel {
                ExecutionParallel::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ExecutionParallel {
                static instance: ExecutionParallel = ExecutionParallel {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ExecutionParallel {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Execution.ExecutionParallel").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ExecutionParallel {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ExecutionParallel {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LimitMatchedLogsCount {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount.count)
        pub count: u32,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LimitMatchedLogsCount {
        fn default() -> &'a LimitMatchedLogsCount {
            <LimitMatchedLogsCount as ::protobuf::Message>::default_instance()
        }
    }

    impl LimitMatchedLogsCount {
        pub fn new() -> LimitMatchedLogsCount {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &LimitMatchedLogsCount| { &m.count },
                |m: &mut LimitMatchedLogsCount| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitMatchedLogsCount>(
                "Workflow.LimitMatchedLogsCount",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LimitMatchedLogsCount {
        const NAME: &'static str = "LimitMatchedLogsCount";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.count = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.count != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.count != 0 {
                os.write_uint32(1, self.count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LimitMatchedLogsCount {
            LimitMatchedLogsCount::new()
        }

        fn clear(&mut self) {
            self.count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LimitMatchedLogsCount {
            static instance: LimitMatchedLogsCount = LimitMatchedLogsCount {
                count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LimitMatchedLogsCount {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.LimitMatchedLogsCount").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LimitMatchedLogsCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LimitMatchedLogsCount {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LimitDuration {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration.duration_ms)
        pub duration_ms: u64,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LimitDuration {
        fn default() -> &'a LimitDuration {
            <LimitDuration as ::protobuf::Message>::default_instance()
        }
    }

    impl LimitDuration {
        pub fn new() -> LimitDuration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "duration_ms",
                |m: &LimitDuration| { &m.duration_ms },
                |m: &mut LimitDuration| { &mut m.duration_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitDuration>(
                "Workflow.LimitDuration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LimitDuration {
        const NAME: &'static str = "LimitDuration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.duration_ms = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.duration_ms != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.duration_ms);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.duration_ms != 0 {
                os.write_uint64(2, self.duration_ms)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LimitDuration {
            LimitDuration::new()
        }

        fn clear(&mut self) {
            self.duration_ms = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LimitDuration {
            static instance: LimitDuration = LimitDuration {
                duration_ms: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LimitDuration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.LimitDuration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LimitDuration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LimitDuration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FieldExtracted {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.field_name)
        pub field_name: ::std::string::String,
        // message oneof groups
        pub extraction_type: ::std::option::Option<field_extracted::Extraction_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FieldExtracted {
        fn default() -> &'a FieldExtracted {
            <FieldExtracted as ::protobuf::Message>::default_instance()
        }
    }

    impl FieldExtracted {
        pub fn new() -> FieldExtracted {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.Exact exact = 2;

        pub fn exact(&self) -> &field_extracted::Exact {
            match self.extraction_type {
                ::std::option::Option::Some(field_extracted::Extraction_type::Exact(ref v)) => v,
                _ => <field_extracted::Exact as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_exact(&mut self) {
            self.extraction_type = ::std::option::Option::None;
        }

        pub fn has_exact(&self) -> bool {
            match self.extraction_type {
                ::std::option::Option::Some(field_extracted::Extraction_type::Exact(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_exact(&mut self, v: field_extracted::Exact) {
            self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(v))
        }

        // Mutable pointer to the field.
        pub fn mut_exact(&mut self) -> &mut field_extracted::Exact {
            if let ::std::option::Option::Some(field_extracted::Extraction_type::Exact(_)) = self.extraction_type {
            } else {
                self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(field_extracted::Exact::new()));
            }
            match self.extraction_type {
                ::std::option::Option::Some(field_extracted::Extraction_type::Exact(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_exact(&mut self) -> field_extracted::Exact {
            if self.has_exact() {
                match self.extraction_type.take() {
                    ::std::option::Option::Some(field_extracted::Extraction_type::Exact(v)) => v,
                    _ => panic!(),
                }
            } else {
                field_extracted::Exact::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "field_name",
                |m: &FieldExtracted| { &m.field_name },
                |m: &mut FieldExtracted| { &mut m.field_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, field_extracted::Exact>(
                "exact",
                FieldExtracted::has_exact,
                FieldExtracted::exact,
                FieldExtracted::mut_exact,
                FieldExtracted::set_exact,
            ));
            oneofs.push(field_extracted::Extraction_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldExtracted>(
                "Workflow.FieldExtracted",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FieldExtracted {
        const NAME: &'static str = "FieldExtracted";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.field_name = is.read_string()?;
                    },
                    18 => {
                        self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.field_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.field_name);
            }
            if let ::std::option::Option::Some(ref v) = self.extraction_type {
                match v {
                    &field_extracted::Extraction_type::Exact(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.field_name.is_empty() {
                os.write_string(1, &self.field_name)?;
            }
            if let ::std::option::Option::Some(ref v) = self.extraction_type {
                match v {
                    &field_extracted::Extraction_type::Exact(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FieldExtracted {
            FieldExtracted::new()
        }

        fn clear(&mut self) {
            self.field_name.clear();
            self.extraction_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FieldExtracted {
            static instance: FieldExtracted = FieldExtracted {
                field_name: ::std::string::String::new(),
                extraction_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FieldExtracted {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.FieldExtracted").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FieldExtracted {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FieldExtracted {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FieldExtracted`
    pub mod field_extracted {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.extraction_type)
        pub enum Extraction_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.exact)
            Exact(Exact),
        }

        impl ::protobuf::Oneof for Extraction_type {
        }

        impl ::protobuf::OneofFull for Extraction_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::FieldExtracted as ::protobuf::MessageFull>::descriptor().oneof_by_name("extraction_type").unwrap()).clone()
            }
        }

        impl Extraction_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Extraction_type>("extraction_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.Exact)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Exact {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.FieldExtracted.Exact.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Exact {
            fn default() -> &'a Exact {
                <Exact as ::protobuf::Message>::default_instance()
            }
        }

        impl Exact {
            pub fn new() -> Exact {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exact>(
                    "Workflow.FieldExtracted.Exact",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Exact {
            const NAME: &'static str = "Exact";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Exact {
                Exact::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Exact {
                static instance: Exact = Exact {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Exact {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.FieldExtracted.Exact").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Exact {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Exact {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n3bitdrift_public/protobuf/workflow/v1/workflow.proto\x12$bitdrift_publ\
    ic.protobuf.workflow.v1\x1a\x17validate/validate.proto\x1a5bitdrift_publ\
    ic/protobuf/matcher/v1/log_matcher.proto\"f\n\x16WorkflowsConfiguration\
    \x12L\n\tworkflows\x18\x01\x20\x03(\x0b2..bitdrift_public.protobuf.workf\
    low.v1.WorkflowR\tworkflows\"\xb51\n\x08Workflow\x12\x17\n\x02id\x18\x01\
    \x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\x12V\n\x06states\x18\x02\
    \x20\x03(\x0b24.bitdrift_public.protobuf.workflow.v1.Workflow.StateR\x06\
    statesB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12V\n\texecution\x18\x03\x20\
    \x01(\x0b28.bitdrift_public.protobuf.workflow.v1.Workflow.ExecutionR\tex\
    ecution\x12}\n\x18limit_matched_logs_count\x18\x04\x20\x01(\x0b2D.bitdri\
    ft_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCountR\x15limitM\
    atchedLogsCount\x12c\n\x0elimit_duration\x18\x05\x20\x01(\x0b2<.bitdrift\
    _public.protobuf.workflow.v1.Workflow.LimitDurationR\rlimitDuration\x1a}\
    \n\x05State\x12\x17\n\x02id\x18\x01\x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\
    \x10\x01\x12[\n\x0btransitions\x18\x02\x20\x03(\x0b29.bitdrift_public.pr\
    otobuf.workflow.v1.Workflow.TransitionR\x0btransitions\x1a\xc5\x02\n\nTr\
    ansition\x12/\n\x0ftarget_state_id\x18\x01\x20\x01(\tR\rtargetStateIdB\
    \x07\xfaB\x04r\x02\x10\x01\x12Q\n\x04rule\x18\x02\x20\x01(\x0b23.bitdrif\
    t_public.protobuf.workflow.v1.Workflow.RuleR\x04ruleB\x08\xfaB\x05\x8a\
    \x01\x02\x10\x01\x12O\n\x07actions\x18\x03\x20\x03(\x0b25.bitdrift_publi\
    c.protobuf.workflow.v1.Workflow.ActionR\x07actions\x12b\n\nextensions\
    \x18\x04\x20\x03(\x0b2B.bitdrift_public.protobuf.workflow.v1.Workflow.Tr\
    ansitionExtensionR\nextensions\x1a\x83\x01\n\x04Rule\x12c\n\x0erule_log_\
    match\x18\x01\x20\x01(\x0b2;.bitdrift_public.protobuf.workflow.v1.Workfl\
    ow.RuleLogMatchH\0R\x0cruleLogMatchB\x10\n\trule_type\x12\x03\xf8B\x01J\
    \x04\x08\x02\x10\x03\x1a\xe4\x06\n\x13TransitionExtension\x12\xa8\x01\n\
    \x1fsankey_diagram_value_extraction\x18\x01\x20\x01(\x0b2_.bitdrift_publ\
    ic.protobuf.workflow.v1.Workflow.TransitionExtension.SankeyDiagramValueE\
    xtractionH\0R\x1csankeyDiagramValueExtraction\x12y\n\x0esave_timestamp\
    \x18\x02\x20\x01(\x0b2P.bitdrift_public.protobuf.workflow.v1.Workflow.Tr\
    ansitionExtension.SaveTimestampH\0R\rsaveTimestamp\x12m\n\nsave_field\
    \x18\x03\x20\x01(\x0b2L.bitdrift_public.protobuf.workflow.v1.Workflow.Tr\
    ansitionExtension.SaveFieldH\0R\tsaveField\x1a\x1f\n\rSaveTimestamp\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x1a:\n\tSaveField\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\tR\x02id\x12\x1d\n\nfield_name\x18\x02\x20\x01(\tR\tfi\
    eldName\x1a\xc3\x02\n\x1cSankeyDiagramValueExtraction\x123\n\x11sankey_d\
    iagram_id\x18\x01\x20\x01(\tR\x0fsankeyDiagramIdB\x07\xfaB\x04r\x02\x10\
    \x01\x12\x1f\n\x05fixed\x18\x02\x20\x01(\tH\0R\x05fixedB\x07\xfaB\x04r\
    \x02\x10\x01\x12h\n\x0ffield_extracted\x18\x03\x20\x01(\x0b2=.bitdrift_p\
    ublic.protobuf.workflow.v1.Workflow.FieldExtractedH\0R\x0efieldExtracted\
    \x12P\n%counts_toward_sankey_extraction_limit\x18\x04\x20\x01(\x08R!coun\
    tsTowardSankeyExtractionLimitB\x11\n\nvalue_type\x12\x03\xf8B\x01B\x15\n\
    \x0eextension_type\x12\x03\xf8B\x01\x1a\x89\x01\n\x0cRuleLogMatch\x12Z\n\
    \x0blog_matcher\x18\x01\x20\x01(\x0b2/.bitdrift_public.protobuf.matcher.\
    v1.LogMatcherR\nlogMatcherB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x12\x1d\n\
    \x05count\x18\x02\x20\x01(\rR\x05countB\x07\xfaB\x04*\x02\x20\0\x1a\xc7\
    \x1c\n\x06Action\x12|\n\x14action_flush_buffers\x18\x01\x20\x01(\x0b2H.b\
    itdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffersH\
    \0R\x12actionFlushBuffers\x12v\n\x12action_emit_metric\x18\x02\x20\x01(\
    \x0b2F.bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMe\
    tricH\0R\x10actionEmitMetric\x12\x8c\x01\n\x1aaction_emit_sankey_diagram\
    \x18\x03\x20\x01(\x0b2M.bitdrift_public.protobuf.workflow.v1.Workflow.Ac\
    tion.ActionEmitSankeyDiagramH\0R\x17actionEmitSankeyDiagram\x12\x82\x01\
    \n\x16action_take_screenshot\x18\x04\x20\x01(\x0b2J.bitdrift_public.prot\
    obuf.workflow.v1.Workflow.Action.ActionTakeScreenshotH\0R\x14actionTakeS\
    creenshot\x12y\n\x13action_generate_log\x18\x05\x20\x01(\x0b2G.bitdrift_\
    public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLogH\0R\x11act\
    ionGenerateLog\x1a\xb1\n\n\x11ActionGenerateLog\x12\x18\n\x07message\x18\
    \x01\x20\x01(\tR\x07message\x12n\n\x06fields\x18\x02\x20\x03(\x0b2V.bitd\
    rift_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.Gener\
    atedFieldR\x06fields\x12\x0e\n\x02id\x18\x03\x20\x01(\tR\x02id\x12\x19\n\
    \x08log_type\x18\x04\x20\x01(\rR\x07logType\x1a\xe5\x01\n\x0eValueRefere\
    nce\x12\x16\n\x05fixed\x18\x01\x20\x01(\tH\0R\x05fixed\x125\n\x16field_f\
    rom_current_log\x18\x02\x20\x01(\tH\0R\x13fieldFromCurrentLog\x12&\n\x0e\
    saved_field_id\x18\x03\x20\x01(\tH\0R\x0csavedFieldId\x12.\n\x12saved_ti\
    mestamp_id\x18\x04\x20\x01(\tH\0R\x10savedTimestampId\x12\x14\n\x04uuid\
    \x18\x05\x20\x01(\x08H\0R\x04uuidB\x16\n\x14value_reference_type\x1a\xe8\
    \x01\n\x12ValueReferencePair\x12h\n\x03lhs\x18\x01\x20\x01(\x0b2V.bitdri\
    ft_public.protobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueRe\
    ferenceR\x03lhs\x12h\n\x03rhs\x18\x02\x20\x01(\x0b2V.bitdrift_public.pro\
    tobuf.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferenceR\x03r\
    hs\x1a\x93\x05\n\x0eGeneratedField\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12p\n\x06single\x18\x02\x20\x01(\x0b2V.bitdrift_public.protobu\
    f.workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferenceH\0R\x06si\
    ngle\x12x\n\x08subtract\x18\x03\x20\x01(\x0b2Z.bitdrift_public.protobuf.\
    workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePairH\0R\x08\
    subtract\x12n\n\x03add\x18\x04\x20\x01(\x0b2Z.bitdrift_public.protobuf.w\
    orkflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePairH\0R\x03a\
    dd\x12x\n\x08multiply\x18\x05\x20\x01(\x0b2Z.bitdrift_public.protobuf.wo\
    rkflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePairH\0R\x08mu\
    ltiply\x12t\n\x06divide\x18\x06\x20\x01(\x0b2Z.bitdrift_public.protobuf.\
    workflow.v1.Workflow.Action.ActionGenerateLog.ValueReferencePairH\0R\x06\
    divideB!\n\x1agenerated_field_value_type\x12\x03\xf8B\x01\x1a\xa9\x05\n\
    \x12ActionFlushBuffers\x12\x1d\n\nbuffer_ids\x18\x01\x20\x03(\tR\tbuffer\
    Ids\x12\x17\n\x02id\x18\x02\x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\
    \x12p\n\tstreaming\x18\x03\x20\x01(\x0b2R.bitdrift_public.protobuf.workf\
    low.v1.Workflow.Action.ActionFlushBuffers.StreamingR\tstreaming\x1a\xe8\
    \x03\n\tStreaming\x12G\n\x20destination_streaming_buffer_ids\x18\x01\x20\
    \x03(\tR\x1ddestinationStreamingBufferIds\x12\x9a\x01\n\x14termination_c\
    riteria\x18\x02\x20\x03(\x0b2g.bitdrift_public.protobuf.workflow.v1.Work\
    flow.Action.ActionFlushBuffers.Streaming.TerminationCriterionR\x13termin\
    ationCriteria\x1a\xf4\x01\n\x14TerminationCriterion\x12\x92\x01\n\nlogs_\
    count\x18\x01\x20\x01(\x0b2q.bitdrift_public.protobuf.workflow.v1.Workfl\
    ow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCountH\0\
    R\tlogsCount\x1a:\n\tLogsCount\x12-\n\x0emax_logs_count\x18\x01\x20\x01(\
    \x04R\x0cmaxLogsCountB\x07\xfaB\x042\x02\x20\0B\x0b\n\x04type\x12\x03\
    \xf8B\x01\x1a\xa3\x04\n\x10ActionEmitMetric\x12\x17\n\x02id\x18\x01\x20\
    \x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\x12j\n\x07counter\x18\x02\x20\
    \x01(\x0b2N.bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionE\
    mitMetric.CounterH\0R\x07counter\x12p\n\thistogram\x18\x05\x20\x01(\x0b2\
    P.bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.\
    HistogramH\0R\thistogram\x12\x16\n\x05fixed\x18\x03\x20\x01(\rH\x01R\x05\
    fixed\x12h\n\x0ffield_extracted\x18\x06\x20\x01(\x0b2=.bitdrift_public.p\
    rotobuf.workflow.v1.Workflow.FieldExtractedH\x01R\x0efieldExtracted\x12M\
    \n\x04tags\x18\x04\x20\x03(\x0b29.bitdrift_public.protobuf.workflow.v1.W\
    orkflow.Action.TagR\x04tags\x1a\t\n\x07Counter\x1a\x0b\n\tHistogramB\x12\
    \n\x0bmetric_type\x12\x03\xf8B\x01B\x1b\n\x14value_extractor_type\x12\
    \x03\xf8B\x01\x1a\xa0\x01\n\x17ActionEmitSankeyDiagram\x12\x17\n\x02id\
    \x18\x01\x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\x12\x1d\n\x05limit\
    \x18\x02\x20\x01(\rR\x05limitB\x07\xfaB\x04*\x02\x20\0\x12M\n\x04tags\
    \x18\x03\x20\x03(\x0b29.bitdrift_public.protobuf.workflow.v1.Workflow.Ac\
    tion.TagR\x04tags\x1a\xc9\x01\n\x03Tag\x12\x1b\n\x04name\x18\x01\x20\x01\
    (\tR\x04nameB\x07\xfaB\x04r\x02\x10\x01\x12*\n\x0bfixed_value\x18\x02\
    \x20\x01(\tH\0R\nfixedValueB\x07\xfaB\x04r\x02\x10\x01\x12h\n\x0ffield_e\
    xtracted\x18\x03\x20\x01(\x0b2=.bitdrift_public.protobuf.workflow.v1.Wor\
    kflow.FieldExtractedH\0R\x0efieldExtractedB\x0f\n\x08tag_type\x12\x03\
    \xf8B\x01\x1a/\n\x14ActionTakeScreenshot\x12\x17\n\x02id\x18\x01\x20\x01\
    (\tR\x02idB\x07\xfaB\x04r\x02\x10\x01B\x12\n\x0baction_type\x12\x03\xf8B\
    \x01\x1a\xc5\x02\n\tExecution\x12~\n\x13execution_exclusive\x18\x01\x20\
    \x01(\x0b2K.bitdrift_public.protobuf.workflow.v1.Workflow.Execution.Exec\
    utionExclusiveH\0R\x12executionExclusive\x12{\n\x12execution_parallel\
    \x18\x02\x20\x01(\x0b2J.bitdrift_public.protobuf.workflow.v1.Workflow.Ex\
    ecution.ExecutionParallelH\0R\x11executionParallel\x1a\x14\n\x12Executio\
    nExclusive\x1a\x13\n\x11ExecutionParallelB\x10\n\x0eexecution_type\x1a6\
    \n\x15LimitMatchedLogsCount\x12\x1d\n\x05count\x18\x01\x20\x01(\rR\x05co\
    untB\x07\xfaB\x04*\x02\x20\0\x1a9\n\rLimitDuration\x12(\n\x0bduration_ms\
    \x18\x02\x20\x01(\x04R\ndurationMsB\x07\xfaB\x042\x02\x20\0\x1a\xb6\x01\
    \n\x0eFieldExtracted\x12&\n\nfield_name\x18\x01\x20\x01(\tR\tfieldNameB\
    \x07\xfaB\x04r\x02\x10\x01\x12[\n\x05exact\x18\x02\x20\x01(\x0b2C.bitdri\
    ft_public.protobuf.workflow.v1.Workflow.FieldExtracted.ExactH\0R\x05exac\
    t\x1a\x07\n\x05ExactB\x16\n\x0fextraction_type\x12\x03\xf8B\x01b\x06prot\
    o3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::validate::file_descriptor().clone());
            deps.push(super::log_matcher::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(32);
            messages.push(WorkflowsConfiguration::generated_message_descriptor_data());
            messages.push(Workflow::generated_message_descriptor_data());
            messages.push(workflow::State::generated_message_descriptor_data());
            messages.push(workflow::Transition::generated_message_descriptor_data());
            messages.push(workflow::Rule::generated_message_descriptor_data());
            messages.push(workflow::TransitionExtension::generated_message_descriptor_data());
            messages.push(workflow::RuleLogMatch::generated_message_descriptor_data());
            messages.push(workflow::Action::generated_message_descriptor_data());
            messages.push(workflow::Execution::generated_message_descriptor_data());
            messages.push(workflow::LimitMatchedLogsCount::generated_message_descriptor_data());
            messages.push(workflow::LimitDuration::generated_message_descriptor_data());
            messages.push(workflow::FieldExtracted::generated_message_descriptor_data());
            messages.push(workflow::transition_extension::SaveTimestamp::generated_message_descriptor_data());
            messages.push(workflow::transition_extension::SaveField::generated_message_descriptor_data());
            messages.push(workflow::transition_extension::SankeyDiagramValueExtraction::generated_message_descriptor_data());
            messages.push(workflow::action::ActionGenerateLog::generated_message_descriptor_data());
            messages.push(workflow::action::ActionFlushBuffers::generated_message_descriptor_data());
            messages.push(workflow::action::ActionEmitMetric::generated_message_descriptor_data());
            messages.push(workflow::action::ActionEmitSankeyDiagram::generated_message_descriptor_data());
            messages.push(workflow::action::Tag::generated_message_descriptor_data());
            messages.push(workflow::action::ActionTakeScreenshot::generated_message_descriptor_data());
            messages.push(workflow::action::action_generate_log::ValueReference::generated_message_descriptor_data());
            messages.push(workflow::action::action_generate_log::ValueReferencePair::generated_message_descriptor_data());
            messages.push(workflow::action::action_generate_log::GeneratedField::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::Streaming::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::streaming::TerminationCriterion::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::streaming::termination_criterion::LogsCount::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::Counter::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::Histogram::generated_message_descriptor_data());
            messages.push(workflow::execution::ExecutionExclusive::generated_message_descriptor_data());
            messages.push(workflow::execution::ExecutionParallel::generated_message_descriptor_data());
            messages.push(workflow::field_extracted::Exact::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
