// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/workflow/v1/workflow.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WorkflowsConfiguration {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration.workflows)
    pub workflows: ::std::vec::Vec<Workflow>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.WorkflowsConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WorkflowsConfiguration {
    fn default() -> &'a WorkflowsConfiguration {
        <WorkflowsConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl WorkflowsConfiguration {
    pub fn new() -> WorkflowsConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "workflows",
            |m: &WorkflowsConfiguration| { &m.workflows },
            |m: &mut WorkflowsConfiguration| { &mut m.workflows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkflowsConfiguration>(
            "WorkflowsConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WorkflowsConfiguration {
    const NAME: &'static str = "WorkflowsConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.workflows.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.workflows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.workflows {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WorkflowsConfiguration {
        WorkflowsConfiguration::new()
    }

    fn clear(&mut self) {
        self.workflows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WorkflowsConfiguration {
        static instance: WorkflowsConfiguration = WorkflowsConfiguration {
            workflows: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WorkflowsConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WorkflowsConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WorkflowsConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkflowsConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Workflow {
    // message fields
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.states)
    pub states: ::std::vec::Vec<workflow::State>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.execution)
    pub execution: ::protobuf::MessageField<workflow::Execution>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.limit_matched_logs_count)
    pub limit_matched_logs_count: ::protobuf::MessageField<workflow::LimitMatchedLogsCount>,
    // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.limit_duration)
    pub limit_duration: ::protobuf::MessageField<workflow::LimitDuration>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Workflow {
    fn default() -> &'a Workflow {
        <Workflow as ::protobuf::Message>::default_instance()
    }
}

impl Workflow {
    pub fn new() -> Workflow {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Workflow| { &m.id },
            |m: &mut Workflow| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "states",
            |m: &Workflow| { &m.states },
            |m: &mut Workflow| { &mut m.states },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::Execution>(
            "execution",
            |m: &Workflow| { &m.execution },
            |m: &mut Workflow| { &mut m.execution },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::LimitMatchedLogsCount>(
            "limit_matched_logs_count",
            |m: &Workflow| { &m.limit_matched_logs_count },
            |m: &mut Workflow| { &mut m.limit_matched_logs_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, workflow::LimitDuration>(
            "limit_duration",
            |m: &Workflow| { &m.limit_duration },
            |m: &mut Workflow| { &mut m.limit_duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Workflow>(
            "Workflow",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Workflow {
    const NAME: &'static str = "Workflow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.states.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.execution)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limit_matched_logs_count)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.limit_duration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        for value in &self.states {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.execution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.limit_matched_logs_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.limit_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        for v in &self.states {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.execution.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.limit_matched_logs_count.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.limit_duration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Workflow {
        Workflow::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.states.clear();
        self.execution.clear();
        self.limit_matched_logs_count.clear();
        self.limit_duration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Workflow {
        static instance: Workflow = Workflow {
            id: ::std::string::String::new(),
            states: ::std::vec::Vec::new(),
            execution: ::protobuf::MessageField::none(),
            limit_matched_logs_count: ::protobuf::MessageField::none(),
            limit_duration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Workflow {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Workflow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Workflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Workflow {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Workflow`
pub mod workflow {
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.State)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct State {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.State.id)
        pub id: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.State.transitions)
        pub transitions: ::std::vec::Vec<Transition>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.State.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a State {
        fn default() -> &'a State {
            <State as ::protobuf::Message>::default_instance()
        }
    }

    impl State {
        pub fn new() -> State {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &State| { &m.id },
                |m: &mut State| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "transitions",
                |m: &State| { &m.transitions },
                |m: &mut State| { &mut m.transitions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<State>(
                "Workflow.State",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for State {
        const NAME: &'static str = "State";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.id = is.read_string()?;
                    },
                    18 => {
                        self.transitions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.id);
            }
            for value in &self.transitions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.id.is_empty() {
                os.write_string(1, &self.id)?;
            }
            for v in &self.transitions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> State {
            State::new()
        }

        fn clear(&mut self) {
            self.id.clear();
            self.transitions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static State {
            static instance: State = State {
                id: ::std::string::String::new(),
                transitions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for State {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.State").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for State {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for State {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Transition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Transition {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.target_state_id)
        pub target_state_id: ::std::string::String,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.rule)
        pub rule: ::protobuf::MessageField<Rule>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.actions)
        pub actions: ::std::vec::Vec<Action>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Transition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Transition {
        fn default() -> &'a Transition {
            <Transition as ::protobuf::Message>::default_instance()
        }
    }

    impl Transition {
        pub fn new() -> Transition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "target_state_id",
                |m: &Transition| { &m.target_state_id },
                |m: &mut Transition| { &mut m.target_state_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Rule>(
                "rule",
                |m: &Transition| { &m.rule },
                |m: &mut Transition| { &mut m.rule },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "actions",
                |m: &Transition| { &m.actions },
                |m: &mut Transition| { &mut m.actions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transition>(
                "Workflow.Transition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Transition {
        const NAME: &'static str = "Transition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.target_state_id = is.read_string()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.rule)?;
                    },
                    26 => {
                        self.actions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.target_state_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.target_state_id);
            }
            if let Some(v) = self.rule.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.actions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.target_state_id.is_empty() {
                os.write_string(1, &self.target_state_id)?;
            }
            if let Some(v) = self.rule.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.actions {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Transition {
            Transition::new()
        }

        fn clear(&mut self) {
            self.target_state_id.clear();
            self.rule.clear();
            self.actions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Transition {
            static instance: Transition = Transition {
                target_state_id: ::std::string::String::new(),
                rule: ::protobuf::MessageField::none(),
                actions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Transition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Transition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Transition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Transition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Rule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Rule {
        // message oneof groups
        pub rule_type: ::std::option::Option<rule::Rule_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Rule {
        fn default() -> &'a Rule {
            <Rule as ::protobuf::Message>::default_instance()
        }
    }

    impl Rule {
        pub fn new() -> Rule {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch rule_log_match = 1;

        pub fn rule_log_match(&self) -> &RuleLogMatch {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(ref v)) => v,
                _ => <RuleLogMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_rule_log_match(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_log_match(&self) -> bool {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_rule_log_match(&mut self, v: RuleLogMatch) {
            self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_rule_log_match(&mut self) -> &mut RuleLogMatch {
            if let ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(_)) = self.rule_type {
            } else {
                self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(RuleLogMatch::new()));
            }
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_rule_log_match(&mut self) -> RuleLogMatch {
            if self.has_rule_log_match() {
                match self.rule_type.take() {
                    ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                RuleLogMatch::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.RuleTimeout rule_timeout = 2;

        pub fn rule_timeout(&self) -> &RuleTimeout {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleTimeout(ref v)) => v,
                _ => <RuleTimeout as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_rule_timeout(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_timeout(&self) -> bool {
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleTimeout(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_rule_timeout(&mut self, v: RuleTimeout) {
            self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleTimeout(v))
        }

        // Mutable pointer to the field.
        pub fn mut_rule_timeout(&mut self) -> &mut RuleTimeout {
            if let ::std::option::Option::Some(rule::Rule_type::RuleTimeout(_)) = self.rule_type {
            } else {
                self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleTimeout(RuleTimeout::new()));
            }
            match self.rule_type {
                ::std::option::Option::Some(rule::Rule_type::RuleTimeout(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_rule_timeout(&mut self) -> RuleTimeout {
            if self.has_rule_timeout() {
                match self.rule_type.take() {
                    ::std::option::Option::Some(rule::Rule_type::RuleTimeout(v)) => v,
                    _ => panic!(),
                }
            } else {
                RuleTimeout::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RuleLogMatch>(
                "rule_log_match",
                Rule::has_rule_log_match,
                Rule::rule_log_match,
                Rule::mut_rule_log_match,
                Rule::set_rule_log_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RuleTimeout>(
                "rule_timeout",
                Rule::has_rule_timeout,
                Rule::rule_timeout,
                Rule::mut_rule_timeout,
                Rule::set_rule_timeout,
            ));
            oneofs.push(rule::Rule_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Rule>(
                "Workflow.Rule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Rule {
        const NAME: &'static str = "Rule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleLogMatch(is.read_message()?));
                    },
                    18 => {
                        self.rule_type = ::std::option::Option::Some(rule::Rule_type::RuleTimeout(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.rule_type {
                match v {
                    &rule::Rule_type::RuleLogMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &rule::Rule_type::RuleTimeout(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.rule_type {
                match v {
                    &rule::Rule_type::RuleLogMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &rule::Rule_type::RuleTimeout(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Rule {
            Rule::new()
        }

        fn clear(&mut self) {
            self.rule_type = ::std::option::Option::None;
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Rule {
            static instance: Rule = Rule {
                rule_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Rule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Rule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Rule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Rule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Rule`
    pub mod rule {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.rule_type)
        pub enum Rule_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.rule_log_match)
            RuleLogMatch(super::RuleLogMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Rule.rule_timeout)
            RuleTimeout(super::RuleTimeout),
        }

        impl ::protobuf::Oneof for Rule_type {
        }

        impl ::protobuf::OneofFull for Rule_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Rule as ::protobuf::MessageFull>::descriptor().oneof_by_name("rule_type").unwrap()).clone()
            }
        }

        impl Rule_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Rule_type>("rule_type")
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuleLogMatch {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.log_matcher)
        pub log_matcher: ::protobuf::MessageField<super::super::log_matcher::LogMatcher>,
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.count)
        pub count: u32,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleLogMatch.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuleLogMatch {
        fn default() -> &'a RuleLogMatch {
            <RuleLogMatch as ::protobuf::Message>::default_instance()
        }
    }

    impl RuleLogMatch {
        pub fn new() -> RuleLogMatch {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::log_matcher::LogMatcher>(
                "log_matcher",
                |m: &RuleLogMatch| { &m.log_matcher },
                |m: &mut RuleLogMatch| { &mut m.log_matcher },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &RuleLogMatch| { &m.count },
                |m: &mut RuleLogMatch| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleLogMatch>(
                "Workflow.RuleLogMatch",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuleLogMatch {
        const NAME: &'static str = "RuleLogMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.log_matcher)?;
                    },
                    16 => {
                        self.count = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.log_matcher.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.count != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.log_matcher.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.count != 0 {
                os.write_uint32(2, self.count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuleLogMatch {
            RuleLogMatch::new()
        }

        fn clear(&mut self) {
            self.log_matcher.clear();
            self.count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuleLogMatch {
            static instance: RuleLogMatch = RuleLogMatch {
                log_matcher: ::protobuf::MessageField::none(),
                count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RuleLogMatch {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.RuleLogMatch").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuleLogMatch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuleLogMatch {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.RuleTimeout)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuleTimeout {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleTimeout.duration_ms)
        pub duration_ms: u64,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.RuleTimeout.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuleTimeout {
        fn default() -> &'a RuleTimeout {
            <RuleTimeout as ::protobuf::Message>::default_instance()
        }
    }

    impl RuleTimeout {
        pub fn new() -> RuleTimeout {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "duration_ms",
                |m: &RuleTimeout| { &m.duration_ms },
                |m: &mut RuleTimeout| { &mut m.duration_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuleTimeout>(
                "Workflow.RuleTimeout",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuleTimeout {
        const NAME: &'static str = "RuleTimeout";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.duration_ms = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.duration_ms != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.duration_ms);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.duration_ms != 0 {
                os.write_uint64(1, self.duration_ms)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuleTimeout {
            RuleTimeout::new()
        }

        fn clear(&mut self) {
            self.duration_ms = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuleTimeout {
            static instance: RuleTimeout = RuleTimeout {
                duration_ms: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RuleTimeout {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.RuleTimeout").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuleTimeout {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuleTimeout {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Action {
        // message oneof groups
        pub action_type: ::std::option::Option<action::Action_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Action {
        fn default() -> &'a Action {
            <Action as ::protobuf::Message>::default_instance()
        }
    }

    impl Action {
        pub fn new() -> Action {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers action_flush_buffers = 1;

        pub fn action_flush_buffers(&self) -> &action::ActionFlushBuffers {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(ref v)) => v,
                _ => <action::ActionFlushBuffers as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_flush_buffers(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_flush_buffers(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_flush_buffers(&mut self, v: action::ActionFlushBuffers) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_flush_buffers(&mut self) -> &mut action::ActionFlushBuffers {
            if let ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(action::ActionFlushBuffers::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_flush_buffers(&mut self) -> action::ActionFlushBuffers {
            if self.has_action_flush_buffers() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionFlushBuffers::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric action_emit_metric = 2;

        pub fn action_emit_metric(&self) -> &action::ActionEmitMetric {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(ref v)) => v,
                _ => <action::ActionEmitMetric as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_action_emit_metric(&mut self) {
            self.action_type = ::std::option::Option::None;
        }

        pub fn has_action_emit_metric(&self) -> bool {
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_action_emit_metric(&mut self, v: action::ActionEmitMetric) {
            self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(v))
        }

        // Mutable pointer to the field.
        pub fn mut_action_emit_metric(&mut self) -> &mut action::ActionEmitMetric {
            if let ::std::option::Option::Some(action::Action_type::ActionEmitMetric(_)) = self.action_type {
            } else {
                self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(action::ActionEmitMetric::new()));
            }
            match self.action_type {
                ::std::option::Option::Some(action::Action_type::ActionEmitMetric(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_action_emit_metric(&mut self) -> action::ActionEmitMetric {
            if self.has_action_emit_metric() {
                match self.action_type.take() {
                    ::std::option::Option::Some(action::Action_type::ActionEmitMetric(v)) => v,
                    _ => panic!(),
                }
            } else {
                action::ActionEmitMetric::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionFlushBuffers>(
                "action_flush_buffers",
                Action::has_action_flush_buffers,
                Action::action_flush_buffers,
                Action::mut_action_flush_buffers,
                Action::set_action_flush_buffers,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action::ActionEmitMetric>(
                "action_emit_metric",
                Action::has_action_emit_metric,
                Action::action_emit_metric,
                Action::mut_action_emit_metric,
                Action::set_action_emit_metric,
            ));
            oneofs.push(action::Action_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Action>(
                "Workflow.Action",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Action {
        const NAME: &'static str = "Action";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionFlushBuffers(is.read_message()?));
                    },
                    18 => {
                        self.action_type = ::std::option::Option::Some(action::Action_type::ActionEmitMetric(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.action_type {
                match v {
                    &action::Action_type::ActionFlushBuffers(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &action::Action_type::ActionEmitMetric(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.action_type {
                match v {
                    &action::Action_type::ActionFlushBuffers(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &action::Action_type::ActionEmitMetric(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Action {
            Action::new()
        }

        fn clear(&mut self) {
            self.action_type = ::std::option::Option::None;
            self.action_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Action {
            static instance: Action = Action {
                action_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Action {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Action").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Action {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Action {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Action`
    pub mod action {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_type)
        pub enum Action_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_flush_buffers)
            ActionFlushBuffers(ActionFlushBuffers),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.action_emit_metric)
            ActionEmitMetric(ActionEmitMetric),
        }

        impl ::protobuf::Oneof for Action_type {
        }

        impl ::protobuf::OneofFull for Action_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Action as ::protobuf::MessageFull>::descriptor().oneof_by_name("action_type").unwrap()).clone()
            }
        }

        impl Action_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Action_type>("action_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionFlushBuffers {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.buffer_ids)
            pub buffer_ids: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.streaming)
            pub streaming: ::protobuf::MessageField<action_flush_buffers::Streaming>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionFlushBuffers {
            fn default() -> &'a ActionFlushBuffers {
                <ActionFlushBuffers as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionFlushBuffers {
            pub fn new() -> ActionFlushBuffers {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "buffer_ids",
                    |m: &ActionFlushBuffers| { &m.buffer_ids },
                    |m: &mut ActionFlushBuffers| { &mut m.buffer_ids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionFlushBuffers| { &m.id },
                    |m: &mut ActionFlushBuffers| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, action_flush_buffers::Streaming>(
                    "streaming",
                    |m: &ActionFlushBuffers| { &m.streaming },
                    |m: &mut ActionFlushBuffers| { &mut m.streaming },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionFlushBuffers>(
                    "Workflow.Action.ActionFlushBuffers",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionFlushBuffers {
            const NAME: &'static str = "ActionFlushBuffers";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.buffer_ids.push(is.read_string()?);
                        },
                        18 => {
                            self.id = is.read_string()?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.streaming)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.buffer_ids {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.id);
                }
                if let Some(v) = self.streaming.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.buffer_ids {
                    os.write_string(1, &v)?;
                };
                if !self.id.is_empty() {
                    os.write_string(2, &self.id)?;
                }
                if let Some(v) = self.streaming.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionFlushBuffers {
                ActionFlushBuffers::new()
            }

            fn clear(&mut self) {
                self.buffer_ids.clear();
                self.id.clear();
                self.streaming.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionFlushBuffers {
                static instance: ActionFlushBuffers = ActionFlushBuffers {
                    buffer_ids: ::std::vec::Vec::new(),
                    id: ::std::string::String::new(),
                    streaming: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionFlushBuffers {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionFlushBuffers {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionFlushBuffers {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ActionFlushBuffers`
        pub mod action_flush_buffers {
            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Streaming {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.destination_streaming_buffer_ids)
                pub destination_streaming_buffer_ids: ::std::vec::Vec<::std::string::String>,
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.termination_criteria)
                pub termination_criteria: ::std::vec::Vec<streaming::TerminationCriterion>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Streaming {
                fn default() -> &'a Streaming {
                    <Streaming as ::protobuf::Message>::default_instance()
                }
            }

            impl Streaming {
                pub fn new() -> Streaming {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "destination_streaming_buffer_ids",
                        |m: &Streaming| { &m.destination_streaming_buffer_ids },
                        |m: &mut Streaming| { &mut m.destination_streaming_buffer_ids },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                        "termination_criteria",
                        |m: &Streaming| { &m.termination_criteria },
                        |m: &mut Streaming| { &mut m.termination_criteria },
                    ));
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Streaming>(
                        "Workflow.Action.ActionFlushBuffers.Streaming",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Streaming {
                const NAME: &'static str = "Streaming";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.destination_streaming_buffer_ids.push(is.read_string()?);
                            },
                            18 => {
                                self.termination_criteria.push(is.read_message()?);
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    for value in &self.destination_streaming_buffer_ids {
                        my_size += ::protobuf::rt::string_size(1, &value);
                    };
                    for value in &self.termination_criteria {
                        let len = value.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    };
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    for v in &self.destination_streaming_buffer_ids {
                        os.write_string(1, &v)?;
                    };
                    for v in &self.termination_criteria {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    };
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Streaming {
                    Streaming::new()
                }

                fn clear(&mut self) {
                    self.destination_streaming_buffer_ids.clear();
                    self.termination_criteria.clear();
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Streaming {
                    static instance: Streaming = Streaming {
                        destination_streaming_buffer_ids: ::std::vec::Vec::new(),
                        termination_criteria: ::std::vec::Vec::new(),
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Streaming {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Streaming {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Streaming {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `Streaming`
            pub mod streaming {
                // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct TerminationCriterion {
                    // message oneof groups
                    pub type_: ::std::option::Option<termination_criterion::Type>,
                    // special fields
                    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a TerminationCriterion {
                    fn default() -> &'a TerminationCriterion {
                        <TerminationCriterion as ::protobuf::Message>::default_instance()
                    }
                }

                impl TerminationCriterion {
                    pub fn new() -> TerminationCriterion {
                        ::std::default::Default::default()
                    }

                    // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount logs_count = 1;

                    pub fn logs_count(&self) -> &termination_criterion::LogsCount {
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(ref v)) => v,
                            _ => <termination_criterion::LogsCount as ::protobuf::Message>::default_instance(),
                        }
                    }

                    pub fn clear_logs_count(&mut self) {
                        self.type_ = ::std::option::Option::None;
                    }

                    pub fn has_logs_count(&self) -> bool {
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(..)) => true,
                            _ => false,
                        }
                    }

                    // Param is passed by value, moved
                    pub fn set_logs_count(&mut self, v: termination_criterion::LogsCount) {
                        self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(v))
                    }

                    // Mutable pointer to the field.
                    pub fn mut_logs_count(&mut self) -> &mut termination_criterion::LogsCount {
                        if let ::std::option::Option::Some(termination_criterion::Type::LogsCount(_)) = self.type_ {
                        } else {
                            self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(termination_criterion::LogsCount::new()));
                        }
                        match self.type_ {
                            ::std::option::Option::Some(termination_criterion::Type::LogsCount(ref mut v)) => v,
                            _ => panic!(),
                        }
                    }

                    // Take field
                    pub fn take_logs_count(&mut self) -> termination_criterion::LogsCount {
                        if self.has_logs_count() {
                            match self.type_.take() {
                                ::std::option::Option::Some(termination_criterion::Type::LogsCount(v)) => v,
                                _ => panic!(),
                            }
                        } else {
                            termination_criterion::LogsCount::new()
                        }
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(1);
                        let mut oneofs = ::std::vec::Vec::with_capacity(1);
                        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, termination_criterion::LogsCount>(
                            "logs_count",
                            TerminationCriterion::has_logs_count,
                            TerminationCriterion::logs_count,
                            TerminationCriterion::mut_logs_count,
                            TerminationCriterion::set_logs_count,
                        ));
                        oneofs.push(termination_criterion::Type::generated_oneof_descriptor_data());
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TerminationCriterion>(
                            "Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for TerminationCriterion {
                    const NAME: &'static str = "TerminationCriterion";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => {
                                    self.type_ = ::std::option::Option::Some(termination_criterion::Type::LogsCount(is.read_message()?));
                                },
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        if let ::std::option::Option::Some(ref v) = self.type_ {
                            match v {
                                &termination_criterion::Type::LogsCount(ref v) => {
                                    let len = v.compute_size();
                                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                                },
                            };
                        }
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        if let ::std::option::Option::Some(ref v) = self.type_ {
                            match v {
                                &termination_criterion::Type::LogsCount(ref v) => {
                                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                                },
                            };
                        }
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> TerminationCriterion {
                        TerminationCriterion::new()
                    }

                    fn clear(&mut self) {
                        self.type_ = ::std::option::Option::None;
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static TerminationCriterion {
                        static instance: TerminationCriterion = TerminationCriterion {
                            type_: ::std::option::Option::None,
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for TerminationCriterion {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for TerminationCriterion {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for TerminationCriterion {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }

                /// Nested message and enums of message `TerminationCriterion`
                pub mod termination_criterion {

                    #[derive(Clone,PartialEq,Debug)]
                    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.type)
                    pub enum Type {
                        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.logs_count)
                        LogsCount(LogsCount),
                    }

                    impl ::protobuf::Oneof for Type {
                    }

                    impl ::protobuf::OneofFull for Type {
                        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| <super::TerminationCriterion as ::protobuf::MessageFull>::descriptor().oneof_by_name("type").unwrap()).clone()
                        }
                    }

                    impl Type {
                        pub(in super::super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("type")
                        }
                    }
                    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount)
                    #[derive(PartialEq,Clone,Default,Debug)]
                    pub struct LogsCount {
                        // message fields
                        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount.max_logs_count)
                        pub max_logs_count: u64,
                        // special fields
                        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount.special_fields)
                        pub special_fields: ::protobuf::SpecialFields,
                    }

                    impl<'a> ::std::default::Default for &'a LogsCount {
                        fn default() -> &'a LogsCount {
                            <LogsCount as ::protobuf::Message>::default_instance()
                        }
                    }

                    impl LogsCount {
                        pub fn new() -> LogsCount {
                            ::std::default::Default::default()
                        }

                        pub(in super::super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                            let mut fields = ::std::vec::Vec::with_capacity(1);
                            let mut oneofs = ::std::vec::Vec::with_capacity(0);
                            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                                "max_logs_count",
                                |m: &LogsCount| { &m.max_logs_count },
                                |m: &mut LogsCount| { &mut m.max_logs_count },
                            ));
                            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogsCount>(
                                "Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount",
                                fields,
                                oneofs,
                            )
                        }
                    }

                    impl ::protobuf::Message for LogsCount {
                        const NAME: &'static str = "LogsCount";

                        fn is_initialized(&self) -> bool {
                            true
                        }

                        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    8 => {
                                        self.max_logs_count = is.read_uint64()?;
                                    },
                                    tag => {
                                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                    },
                                };
                            }
                            ::std::result::Result::Ok(())
                        }

                        // Compute sizes of nested messages
                        #[allow(unused_variables)]
                        fn compute_size(&self) -> u64 {
                            let mut my_size = 0;
                            if self.max_logs_count != 0 {
                                my_size += ::protobuf::rt::uint64_size(1, self.max_logs_count);
                            }
                            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                            self.special_fields.cached_size().set(my_size as u32);
                            my_size
                        }

                        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                            if self.max_logs_count != 0 {
                                os.write_uint64(1, self.max_logs_count)?;
                            }
                            os.write_unknown_fields(self.special_fields.unknown_fields())?;
                            ::std::result::Result::Ok(())
                        }

                        fn special_fields(&self) -> &::protobuf::SpecialFields {
                            &self.special_fields
                        }

                        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                            &mut self.special_fields
                        }

                        fn new() -> LogsCount {
                            LogsCount::new()
                        }

                        fn clear(&mut self) {
                            self.max_logs_count = 0;
                            self.special_fields.clear();
                        }

                        fn default_instance() -> &'static LogsCount {
                            static instance: LogsCount = LogsCount {
                                max_logs_count: 0,
                                special_fields: ::protobuf::SpecialFields::new(),
                            };
                            &instance
                        }
                    }

                    impl ::protobuf::MessageFull for LogsCount {
                        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                            descriptor.get(|| super::super::super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionFlushBuffers.Streaming.TerminationCriterion.LogsCount").unwrap()).clone()
                        }
                    }

                    impl ::std::fmt::Display for LogsCount {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                            ::protobuf::text_format::fmt(self, f)
                        }
                    }

                    impl ::protobuf::reflect::ProtobufValue for LogsCount {
                        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                    }
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ActionEmitMetric {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.id)
            pub id: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.tags)
            pub tags: ::std::vec::Vec<action_emit_metric::Tag>,
            // message oneof groups
            pub metric_type: ::std::option::Option<action_emit_metric::Metric_type>,
            pub value_extractor_type: ::std::option::Option<action_emit_metric::Value_extractor_type>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ActionEmitMetric {
            fn default() -> &'a ActionEmitMetric {
                <ActionEmitMetric as ::protobuf::Message>::default_instance()
            }
        }

        impl ActionEmitMetric {
            pub fn new() -> ActionEmitMetric {
                ::std::default::Default::default()
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter counter = 2;

            pub fn counter(&self) -> &action_emit_metric::Counter {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(ref v)) => v,
                    _ => <action_emit_metric::Counter as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_counter(&mut self) {
                self.metric_type = ::std::option::Option::None;
            }

            pub fn has_counter(&self) -> bool {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_counter(&mut self, v: action_emit_metric::Counter) {
                self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(v))
            }

            // Mutable pointer to the field.
            pub fn mut_counter(&mut self) -> &mut action_emit_metric::Counter {
                if let ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(_)) = self.metric_type {
                } else {
                    self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(action_emit_metric::Counter::new()));
                }
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_counter(&mut self) -> action_emit_metric::Counter {
                if self.has_counter() {
                    match self.metric_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    action_emit_metric::Counter::new()
                }
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram histogram = 5;

            pub fn histogram(&self) -> &action_emit_metric::Histogram {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(ref v)) => v,
                    _ => <action_emit_metric::Histogram as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_histogram(&mut self) {
                self.metric_type = ::std::option::Option::None;
            }

            pub fn has_histogram(&self) -> bool {
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_histogram(&mut self, v: action_emit_metric::Histogram) {
                self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(v))
            }

            // Mutable pointer to the field.
            pub fn mut_histogram(&mut self) -> &mut action_emit_metric::Histogram {
                if let ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(_)) = self.metric_type {
                } else {
                    self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(action_emit_metric::Histogram::new()));
                }
                match self.metric_type {
                    ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_histogram(&mut self) -> action_emit_metric::Histogram {
                if self.has_histogram() {
                    match self.metric_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    action_emit_metric::Histogram::new()
                }
            }

            // uint32 fixed = 3;

            pub fn fixed(&self) -> u32 {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(v)) => v,
                    _ => 0,
                }
            }

            pub fn clear_fixed(&mut self) {
                self.value_extractor_type = ::std::option::Option::None;
            }

            pub fn has_fixed(&self) -> bool {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_fixed(&mut self, v: u32) {
                self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(v))
            }

            // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted field_extracted = 6;

            pub fn field_extracted(&self) -> &action_emit_metric::FieldExtracted {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(ref v)) => v,
                    _ => <action_emit_metric::FieldExtracted as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_field_extracted(&mut self) {
                self.value_extractor_type = ::std::option::Option::None;
            }

            pub fn has_field_extracted(&self) -> bool {
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_field_extracted(&mut self, v: action_emit_metric::FieldExtracted) {
                self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(v))
            }

            // Mutable pointer to the field.
            pub fn mut_field_extracted(&mut self) -> &mut action_emit_metric::FieldExtracted {
                if let ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(_)) = self.value_extractor_type {
                } else {
                    self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(action_emit_metric::FieldExtracted::new()));
                }
                match self.value_extractor_type {
                    ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_field_extracted(&mut self) -> action_emit_metric::FieldExtracted {
                if self.has_field_extracted() {
                    match self.value_extractor_type.take() {
                        ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    action_emit_metric::FieldExtracted::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(2);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "id",
                    |m: &ActionEmitMetric| { &m.id },
                    |m: &mut ActionEmitMetric| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action_emit_metric::Counter>(
                    "counter",
                    ActionEmitMetric::has_counter,
                    ActionEmitMetric::counter,
                    ActionEmitMetric::mut_counter,
                    ActionEmitMetric::set_counter,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action_emit_metric::Histogram>(
                    "histogram",
                    ActionEmitMetric::has_histogram,
                    ActionEmitMetric::histogram,
                    ActionEmitMetric::mut_histogram,
                    ActionEmitMetric::set_histogram,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                    "fixed",
                    ActionEmitMetric::has_fixed,
                    ActionEmitMetric::fixed,
                    ActionEmitMetric::set_fixed,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, action_emit_metric::FieldExtracted>(
                    "field_extracted",
                    ActionEmitMetric::has_field_extracted,
                    ActionEmitMetric::field_extracted,
                    ActionEmitMetric::mut_field_extracted,
                    ActionEmitMetric::set_field_extracted,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tags",
                    |m: &ActionEmitMetric| { &m.tags },
                    |m: &mut ActionEmitMetric| { &mut m.tags },
                ));
                oneofs.push(action_emit_metric::Metric_type::generated_oneof_descriptor_data());
                oneofs.push(action_emit_metric::Value_extractor_type::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActionEmitMetric>(
                    "Workflow.Action.ActionEmitMetric",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ActionEmitMetric {
            const NAME: &'static str = "ActionEmitMetric";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.id = is.read_string()?;
                        },
                        18 => {
                            self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Counter(is.read_message()?));
                        },
                        42 => {
                            self.metric_type = ::std::option::Option::Some(action_emit_metric::Metric_type::Histogram(is.read_message()?));
                        },
                        24 => {
                            self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::Fixed(is.read_uint32()?));
                        },
                        50 => {
                            self.value_extractor_type = ::std::option::Option::Some(action_emit_metric::Value_extractor_type::FieldExtracted(is.read_message()?));
                        },
                        34 => {
                            self.tags.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.id);
                }
                for value in &self.tags {
                    let len = value.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let ::std::option::Option::Some(ref v) = self.metric_type {
                    match v {
                        &action_emit_metric::Metric_type::Counter(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &action_emit_metric::Metric_type::Histogram(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                if let ::std::option::Option::Some(ref v) = self.value_extractor_type {
                    match v {
                        &action_emit_metric::Value_extractor_type::Fixed(v) => {
                            my_size += ::protobuf::rt::uint32_size(3, v);
                        },
                        &action_emit_metric::Value_extractor_type::FieldExtracted(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.id.is_empty() {
                    os.write_string(1, &self.id)?;
                }
                for v in &self.tags {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                if let ::std::option::Option::Some(ref v) = self.metric_type {
                    match v {
                        &action_emit_metric::Metric_type::Counter(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                        &action_emit_metric::Metric_type::Histogram(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                        },
                    };
                }
                if let ::std::option::Option::Some(ref v) = self.value_extractor_type {
                    match v {
                        &action_emit_metric::Value_extractor_type::Fixed(v) => {
                            os.write_uint32(3, v)?;
                        },
                        &action_emit_metric::Value_extractor_type::FieldExtracted(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ActionEmitMetric {
                ActionEmitMetric::new()
            }

            fn clear(&mut self) {
                self.id.clear();
                self.metric_type = ::std::option::Option::None;
                self.metric_type = ::std::option::Option::None;
                self.value_extractor_type = ::std::option::Option::None;
                self.value_extractor_type = ::std::option::Option::None;
                self.tags.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ActionEmitMetric {
                static instance: ActionEmitMetric = ActionEmitMetric {
                    id: ::std::string::String::new(),
                    tags: ::std::vec::Vec::new(),
                    metric_type: ::std::option::Option::None,
                    value_extractor_type: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ActionEmitMetric {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ActionEmitMetric {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ActionEmitMetric {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `ActionEmitMetric`
        pub mod action_emit_metric {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.metric_type)
            pub enum Metric_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.counter)
                Counter(Counter),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.histogram)
                Histogram(Histogram),
            }

            impl ::protobuf::Oneof for Metric_type {
            }

            impl ::protobuf::OneofFull for Metric_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::ActionEmitMetric as ::protobuf::MessageFull>::descriptor().oneof_by_name("metric_type").unwrap()).clone()
                }
            }

            impl Metric_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Metric_type>("metric_type")
                }
            }

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.value_extractor_type)
            pub enum Value_extractor_type {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.fixed)
                Fixed(u32),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.field_extracted)
                FieldExtracted(FieldExtracted),
            }

            impl ::protobuf::Oneof for Value_extractor_type {
            }

            impl ::protobuf::OneofFull for Value_extractor_type {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::ActionEmitMetric as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_extractor_type").unwrap()).clone()
                }
            }

            impl Value_extractor_type {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_extractor_type>("value_extractor_type")
                }
            }
            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct FieldExtracted {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.field_name)
                pub field_name: ::std::string::String,
                // message oneof groups
                pub extraction_type: ::std::option::Option<field_extracted::Extraction_type>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a FieldExtracted {
                fn default() -> &'a FieldExtracted {
                    <FieldExtracted as ::protobuf::Message>::default_instance()
                }
            }

            impl FieldExtracted {
                pub fn new() -> FieldExtracted {
                    ::std::default::Default::default()
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.Exact exact = 2;

                pub fn exact(&self) -> &field_extracted::Exact {
                    match self.extraction_type {
                        ::std::option::Option::Some(field_extracted::Extraction_type::Exact(ref v)) => v,
                        _ => <field_extracted::Exact as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_exact(&mut self) {
                    self.extraction_type = ::std::option::Option::None;
                }

                pub fn has_exact(&self) -> bool {
                    match self.extraction_type {
                        ::std::option::Option::Some(field_extracted::Extraction_type::Exact(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_exact(&mut self, v: field_extracted::Exact) {
                    self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(v))
                }

                // Mutable pointer to the field.
                pub fn mut_exact(&mut self) -> &mut field_extracted::Exact {
                    if let ::std::option::Option::Some(field_extracted::Extraction_type::Exact(_)) = self.extraction_type {
                    } else {
                        self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(field_extracted::Exact::new()));
                    }
                    match self.extraction_type {
                        ::std::option::Option::Some(field_extracted::Extraction_type::Exact(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_exact(&mut self) -> field_extracted::Exact {
                    if self.has_exact() {
                        match self.extraction_type.take() {
                            ::std::option::Option::Some(field_extracted::Extraction_type::Exact(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        field_extracted::Exact::new()
                    }
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(2);
                    let mut oneofs = ::std::vec::Vec::with_capacity(1);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "field_name",
                        |m: &FieldExtracted| { &m.field_name },
                        |m: &mut FieldExtracted| { &mut m.field_name },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, field_extracted::Exact>(
                        "exact",
                        FieldExtracted::has_exact,
                        FieldExtracted::exact,
                        FieldExtracted::mut_exact,
                        FieldExtracted::set_exact,
                    ));
                    oneofs.push(field_extracted::Extraction_type::generated_oneof_descriptor_data());
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FieldExtracted>(
                        "Workflow.Action.ActionEmitMetric.FieldExtracted",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for FieldExtracted {
                const NAME: &'static str = "FieldExtracted";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.field_name = is.read_string()?;
                            },
                            18 => {
                                self.extraction_type = ::std::option::Option::Some(field_extracted::Extraction_type::Exact(is.read_message()?));
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.field_name.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.field_name);
                    }
                    if let ::std::option::Option::Some(ref v) = self.extraction_type {
                        match v {
                            &field_extracted::Extraction_type::Exact(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                        };
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.field_name.is_empty() {
                        os.write_string(1, &self.field_name)?;
                    }
                    if let ::std::option::Option::Some(ref v) = self.extraction_type {
                        match v {
                            &field_extracted::Extraction_type::Exact(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                            },
                        };
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> FieldExtracted {
                    FieldExtracted::new()
                }

                fn clear(&mut self) {
                    self.field_name.clear();
                    self.extraction_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static FieldExtracted {
                    static instance: FieldExtracted = FieldExtracted {
                        field_name: ::std::string::String::new(),
                        extraction_type: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for FieldExtracted {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.FieldExtracted").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for FieldExtracted {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for FieldExtracted {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `FieldExtracted`
            pub mod field_extracted {

                #[derive(Clone,PartialEq,Debug)]
                // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.extraction_type)
                pub enum Extraction_type {
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.exact)
                    Exact(Exact),
                }

                impl ::protobuf::Oneof for Extraction_type {
                }

                impl ::protobuf::OneofFull for Extraction_type {
                    fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| <super::FieldExtracted as ::protobuf::MessageFull>::descriptor().oneof_by_name("extraction_type").unwrap()).clone()
                    }
                }

                impl Extraction_type {
                    pub(in super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                        ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Extraction_type>("extraction_type")
                    }
                }
                // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.Exact)
                #[derive(PartialEq,Clone,Default,Debug)]
                pub struct Exact {
                    // special fields
                    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.Exact.special_fields)
                    pub special_fields: ::protobuf::SpecialFields,
                }

                impl<'a> ::std::default::Default for &'a Exact {
                    fn default() -> &'a Exact {
                        <Exact as ::protobuf::Message>::default_instance()
                    }
                }

                impl Exact {
                    pub fn new() -> Exact {
                        ::std::default::Default::default()
                    }

                    pub(in super::super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                        let mut fields = ::std::vec::Vec::with_capacity(0);
                        let mut oneofs = ::std::vec::Vec::with_capacity(0);
                        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Exact>(
                            "Workflow.Action.ActionEmitMetric.FieldExtracted.Exact",
                            fields,
                            oneofs,
                        )
                    }
                }

                impl ::protobuf::Message for Exact {
                    const NAME: &'static str = "Exact";

                    fn is_initialized(&self) -> bool {
                        true
                    }

                    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                tag => {
                                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                                },
                            };
                        }
                        ::std::result::Result::Ok(())
                    }

                    // Compute sizes of nested messages
                    #[allow(unused_variables)]
                    fn compute_size(&self) -> u64 {
                        let mut my_size = 0;
                        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                        self.special_fields.cached_size().set(my_size as u32);
                        my_size
                    }

                    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                        os.write_unknown_fields(self.special_fields.unknown_fields())?;
                        ::std::result::Result::Ok(())
                    }

                    fn special_fields(&self) -> &::protobuf::SpecialFields {
                        &self.special_fields
                    }

                    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                        &mut self.special_fields
                    }

                    fn new() -> Exact {
                        Exact::new()
                    }

                    fn clear(&mut self) {
                        self.special_fields.clear();
                    }

                    fn default_instance() -> &'static Exact {
                        static instance: Exact = Exact {
                            special_fields: ::protobuf::SpecialFields::new(),
                        };
                        &instance
                    }
                }

                impl ::protobuf::MessageFull for Exact {
                    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| super::super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.FieldExtracted.Exact").unwrap()).clone()
                    }
                }

                impl ::std::fmt::Display for Exact {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                        ::protobuf::text_format::fmt(self, f)
                    }
                }

                impl ::protobuf::reflect::ProtobufValue for Exact {
                    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
                }
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Tag {
                // message fields
                // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag.name)
                pub name: ::std::string::String,
                // message oneof groups
                pub tag_type: ::std::option::Option<tag::Tag_type>,
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Tag {
                fn default() -> &'a Tag {
                    <Tag as ::protobuf::Message>::default_instance()
                }
            }

            impl Tag {
                pub fn new() -> Tag {
                    ::std::default::Default::default()
                }

                // string fixed_value = 2;

                pub fn fixed_value(&self) -> &str {
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FixedValue(ref v)) => v,
                        _ => "",
                    }
                }

                pub fn clear_fixed_value(&mut self) {
                    self.tag_type = ::std::option::Option::None;
                }

                pub fn has_fixed_value(&self) -> bool {
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FixedValue(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_fixed_value(&mut self, v: ::std::string::String) {
                    self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(v))
                }

                // Mutable pointer to the field.
                pub fn mut_fixed_value(&mut self) -> &mut ::std::string::String {
                    if let ::std::option::Option::Some(tag::Tag_type::FixedValue(_)) = self.tag_type {
                    } else {
                        self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(::std::string::String::new()));
                    }
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FixedValue(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_fixed_value(&mut self) -> ::std::string::String {
                    if self.has_fixed_value() {
                        match self.tag_type.take() {
                            ::std::option::Option::Some(tag::Tag_type::FixedValue(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        ::std::string::String::new()
                    }
                }

                // .bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted field_extracted = 3;

                pub fn field_extracted(&self) -> &FieldExtracted {
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FieldExtracted(ref v)) => v,
                        _ => <FieldExtracted as ::protobuf::Message>::default_instance(),
                    }
                }

                pub fn clear_field_extracted(&mut self) {
                    self.tag_type = ::std::option::Option::None;
                }

                pub fn has_field_extracted(&self) -> bool {
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FieldExtracted(..)) => true,
                        _ => false,
                    }
                }

                // Param is passed by value, moved
                pub fn set_field_extracted(&mut self, v: FieldExtracted) {
                    self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(v))
                }

                // Mutable pointer to the field.
                pub fn mut_field_extracted(&mut self) -> &mut FieldExtracted {
                    if let ::std::option::Option::Some(tag::Tag_type::FieldExtracted(_)) = self.tag_type {
                    } else {
                        self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(FieldExtracted::new()));
                    }
                    match self.tag_type {
                        ::std::option::Option::Some(tag::Tag_type::FieldExtracted(ref mut v)) => v,
                        _ => panic!(),
                    }
                }

                // Take field
                pub fn take_field_extracted(&mut self) -> FieldExtracted {
                    if self.has_field_extracted() {
                        match self.tag_type.take() {
                            ::std::option::Option::Some(tag::Tag_type::FieldExtracted(v)) => v,
                            _ => panic!(),
                        }
                    } else {
                        FieldExtracted::new()
                    }
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(3);
                    let mut oneofs = ::std::vec::Vec::with_capacity(1);
                    fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                        "name",
                        |m: &Tag| { &m.name },
                        |m: &mut Tag| { &mut m.name },
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                        "fixed_value",
                        Tag::has_fixed_value,
                        Tag::fixed_value,
                        Tag::set_fixed_value,
                    ));
                    fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FieldExtracted>(
                        "field_extracted",
                        Tag::has_field_extracted,
                        Tag::field_extracted,
                        Tag::mut_field_extracted,
                        Tag::set_field_extracted,
                    ));
                    oneofs.push(tag::Tag_type::generated_oneof_descriptor_data());
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                        "Workflow.Action.ActionEmitMetric.Tag",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Tag {
                const NAME: &'static str = "Tag";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => {
                                self.name = is.read_string()?;
                            },
                            18 => {
                                self.tag_type = ::std::option::Option::Some(tag::Tag_type::FixedValue(is.read_string()?));
                            },
                            26 => {
                                self.tag_type = ::std::option::Option::Some(tag::Tag_type::FieldExtracted(is.read_message()?));
                            },
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if !self.name.is_empty() {
                        my_size += ::protobuf::rt::string_size(1, &self.name);
                    }
                    if let ::std::option::Option::Some(ref v) = self.tag_type {
                        match v {
                            &tag::Tag_type::FixedValue(ref v) => {
                                my_size += ::protobuf::rt::string_size(2, &v);
                            },
                            &tag::Tag_type::FieldExtracted(ref v) => {
                                let len = v.compute_size();
                                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                            },
                        };
                    }
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    if !self.name.is_empty() {
                        os.write_string(1, &self.name)?;
                    }
                    if let ::std::option::Option::Some(ref v) = self.tag_type {
                        match v {
                            &tag::Tag_type::FixedValue(ref v) => {
                                os.write_string(2, v)?;
                            },
                            &tag::Tag_type::FieldExtracted(ref v) => {
                                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                            },
                        };
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Tag {
                    Tag::new()
                }

                fn clear(&mut self) {
                    self.name.clear();
                    self.tag_type = ::std::option::Option::None;
                    self.tag_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Tag {
                    static instance: Tag = Tag {
                        name: ::std::string::String::new(),
                        tag_type: ::std::option::Option::None,
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Tag {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.Tag").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Tag {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Tag {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            /// Nested message and enums of message `Tag`
            pub mod tag {

                #[derive(Clone,PartialEq,Debug)]
                // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag.tag_type)
                pub enum Tag_type {
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag.fixed_value)
                    FixedValue(::std::string::String),
                    // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Tag.field_extracted)
                    FieldExtracted(super::FieldExtracted),
                }

                impl ::protobuf::Oneof for Tag_type {
                }

                impl ::protobuf::OneofFull for Tag_type {
                    fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                        descriptor.get(|| <super::Tag as ::protobuf::MessageFull>::descriptor().oneof_by_name("tag_type").unwrap()).clone()
                    }
                }

                impl Tag_type {
                    pub(in super::super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                        ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Tag_type>("tag_type")
                    }
                }
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Counter {
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Counter.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Counter {
                fn default() -> &'a Counter {
                    <Counter as ::protobuf::Message>::default_instance()
                }
            }

            impl Counter {
                pub fn new() -> Counter {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(0);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Counter>(
                        "Workflow.Action.ActionEmitMetric.Counter",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Counter {
                const NAME: &'static str = "Counter";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Counter {
                    Counter::new()
                }

                fn clear(&mut self) {
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Counter {
                    static instance: Counter = Counter {
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Counter {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.Counter").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Counter {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Counter {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }

            // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct Histogram {
                // special fields
                // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetric.Histogram.special_fields)
                pub special_fields: ::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a Histogram {
                fn default() -> &'a Histogram {
                    <Histogram as ::protobuf::Message>::default_instance()
                }
            }

            impl Histogram {
                pub fn new() -> Histogram {
                    ::std::default::Default::default()
                }

                pub(in super::super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                    let mut fields = ::std::vec::Vec::with_capacity(0);
                    let mut oneofs = ::std::vec::Vec::with_capacity(0);
                    ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Histogram>(
                        "Workflow.Action.ActionEmitMetric.Histogram",
                        fields,
                        oneofs,
                    )
                }
            }

            impl ::protobuf::Message for Histogram {
                const NAME: &'static str = "Histogram";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            tag => {
                                ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> Histogram {
                    Histogram::new()
                }

                fn clear(&mut self) {
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static Histogram {
                    static instance: Histogram = Histogram {
                        special_fields: ::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            impl ::protobuf::MessageFull for Histogram {
                fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().message_by_package_relative_name("Workflow.Action.ActionEmitMetric.Histogram").unwrap()).clone()
                }
            }

            impl ::std::fmt::Display for Histogram {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    ::protobuf::text_format::fmt(self, f)
                }
            }

            impl ::protobuf::reflect::ProtobufValue for Histogram {
                type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Execution {
        // message oneof groups
        pub execution_type: ::std::option::Option<execution::Execution_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Execution {
        fn default() -> &'a Execution {
            <Execution as ::protobuf::Message>::default_instance()
        }
    }

    impl Execution {
        pub fn new() -> Execution {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive execution_exclusive = 1;

        pub fn execution_exclusive(&self) -> &execution::ExecutionExclusive {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(ref v)) => v,
                _ => <execution::ExecutionExclusive as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_execution_exclusive(&mut self) {
            self.execution_type = ::std::option::Option::None;
        }

        pub fn has_execution_exclusive(&self) -> bool {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_execution_exclusive(&mut self, v: execution::ExecutionExclusive) {
            self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(v))
        }

        // Mutable pointer to the field.
        pub fn mut_execution_exclusive(&mut self) -> &mut execution::ExecutionExclusive {
            if let ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(_)) = self.execution_type {
            } else {
                self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(execution::ExecutionExclusive::new()));
            }
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_execution_exclusive(&mut self) -> execution::ExecutionExclusive {
            if self.has_execution_exclusive() {
                match self.execution_type.take() {
                    ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(v)) => v,
                    _ => panic!(),
                }
            } else {
                execution::ExecutionExclusive::new()
            }
        }

        // .bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel execution_parallel = 2;

        pub fn execution_parallel(&self) -> &execution::ExecutionParallel {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(ref v)) => v,
                _ => <execution::ExecutionParallel as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_execution_parallel(&mut self) {
            self.execution_type = ::std::option::Option::None;
        }

        pub fn has_execution_parallel(&self) -> bool {
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_execution_parallel(&mut self, v: execution::ExecutionParallel) {
            self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(v))
        }

        // Mutable pointer to the field.
        pub fn mut_execution_parallel(&mut self) -> &mut execution::ExecutionParallel {
            if let ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(_)) = self.execution_type {
            } else {
                self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(execution::ExecutionParallel::new()));
            }
            match self.execution_type {
                ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_execution_parallel(&mut self) -> execution::ExecutionParallel {
            if self.has_execution_parallel() {
                match self.execution_type.take() {
                    ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(v)) => v,
                    _ => panic!(),
                }
            } else {
                execution::ExecutionParallel::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, execution::ExecutionExclusive>(
                "execution_exclusive",
                Execution::has_execution_exclusive,
                Execution::execution_exclusive,
                Execution::mut_execution_exclusive,
                Execution::set_execution_exclusive,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, execution::ExecutionParallel>(
                "execution_parallel",
                Execution::has_execution_parallel,
                Execution::execution_parallel,
                Execution::mut_execution_parallel,
                Execution::set_execution_parallel,
            ));
            oneofs.push(execution::Execution_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Execution>(
                "Workflow.Execution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Execution {
        const NAME: &'static str = "Execution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionExclusive(is.read_message()?));
                    },
                    18 => {
                        self.execution_type = ::std::option::Option::Some(execution::Execution_type::ExecutionParallel(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.execution_type {
                match v {
                    &execution::Execution_type::ExecutionExclusive(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &execution::Execution_type::ExecutionParallel(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.execution_type {
                match v {
                    &execution::Execution_type::ExecutionExclusive(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &execution::Execution_type::ExecutionParallel(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Execution {
            Execution::new()
        }

        fn clear(&mut self) {
            self.execution_type = ::std::option::Option::None;
            self.execution_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Execution {
            static instance: Execution = Execution {
                execution_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Execution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.Execution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Execution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Execution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Execution`
    pub mod execution {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_type)
        pub enum Execution_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_exclusive)
            ExecutionExclusive(ExecutionExclusive),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.execution_parallel)
            ExecutionParallel(ExecutionParallel),
        }

        impl ::protobuf::Oneof for Execution_type {
        }

        impl ::protobuf::OneofFull for Execution_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Execution as ::protobuf::MessageFull>::descriptor().oneof_by_name("execution_type").unwrap()).clone()
            }
        }

        impl Execution_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Execution_type>("execution_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ExecutionExclusive {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionExclusive.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ExecutionExclusive {
            fn default() -> &'a ExecutionExclusive {
                <ExecutionExclusive as ::protobuf::Message>::default_instance()
            }
        }

        impl ExecutionExclusive {
            pub fn new() -> ExecutionExclusive {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionExclusive>(
                    "Workflow.Execution.ExecutionExclusive",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ExecutionExclusive {
            const NAME: &'static str = "ExecutionExclusive";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ExecutionExclusive {
                ExecutionExclusive::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ExecutionExclusive {
                static instance: ExecutionExclusive = ExecutionExclusive {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ExecutionExclusive {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Execution.ExecutionExclusive").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ExecutionExclusive {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ExecutionExclusive {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ExecutionParallel {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.Execution.ExecutionParallel.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ExecutionParallel {
            fn default() -> &'a ExecutionParallel {
                <ExecutionParallel as ::protobuf::Message>::default_instance()
            }
        }

        impl ExecutionParallel {
            pub fn new() -> ExecutionParallel {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecutionParallel>(
                    "Workflow.Execution.ExecutionParallel",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ExecutionParallel {
            const NAME: &'static str = "ExecutionParallel";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ExecutionParallel {
                ExecutionParallel::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ExecutionParallel {
                static instance: ExecutionParallel = ExecutionParallel {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ExecutionParallel {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Workflow.Execution.ExecutionParallel").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ExecutionParallel {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ExecutionParallel {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LimitMatchedLogsCount {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount.count)
        pub count: u32,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCount.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LimitMatchedLogsCount {
        fn default() -> &'a LimitMatchedLogsCount {
            <LimitMatchedLogsCount as ::protobuf::Message>::default_instance()
        }
    }

    impl LimitMatchedLogsCount {
        pub fn new() -> LimitMatchedLogsCount {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "count",
                |m: &LimitMatchedLogsCount| { &m.count },
                |m: &mut LimitMatchedLogsCount| { &mut m.count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitMatchedLogsCount>(
                "Workflow.LimitMatchedLogsCount",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LimitMatchedLogsCount {
        const NAME: &'static str = "LimitMatchedLogsCount";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.count = is.read_uint32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.count != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.count != 0 {
                os.write_uint32(1, self.count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LimitMatchedLogsCount {
            LimitMatchedLogsCount::new()
        }

        fn clear(&mut self) {
            self.count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LimitMatchedLogsCount {
            static instance: LimitMatchedLogsCount = LimitMatchedLogsCount {
                count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LimitMatchedLogsCount {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.LimitMatchedLogsCount").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LimitMatchedLogsCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LimitMatchedLogsCount {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LimitDuration {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration.duration_ms)
        pub duration_ms: u64,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.workflow.v1.Workflow.LimitDuration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LimitDuration {
        fn default() -> &'a LimitDuration {
            <LimitDuration as ::protobuf::Message>::default_instance()
        }
    }

    impl LimitDuration {
        pub fn new() -> LimitDuration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "duration_ms",
                |m: &LimitDuration| { &m.duration_ms },
                |m: &mut LimitDuration| { &mut m.duration_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LimitDuration>(
                "Workflow.LimitDuration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LimitDuration {
        const NAME: &'static str = "LimitDuration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.duration_ms = is.read_uint64()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.duration_ms != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.duration_ms);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.duration_ms != 0 {
                os.write_uint64(2, self.duration_ms)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LimitDuration {
            LimitDuration::new()
        }

        fn clear(&mut self) {
            self.duration_ms = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LimitDuration {
            static instance: LimitDuration = LimitDuration {
                duration_ms: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LimitDuration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Workflow.LimitDuration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LimitDuration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LimitDuration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n3bitdrift_public/protobuf/workflow/v1/workflow.proto\x12$bitdrift_publ\
    ic.protobuf.workflow.v1\x1a\x17validate/validate.proto\x1a5bitdrift_publ\
    ic/protobuf/matcher/v1/log_matcher.proto\"f\n\x16WorkflowsConfiguration\
    \x12L\n\tworkflows\x18\x01\x20\x03(\x0b2..bitdrift_public.protobuf.workf\
    low.v1.WorkflowR\tworkflows\"\xc2\x1c\n\x08Workflow\x12\x17\n\x02id\x18\
    \x01\x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\x01\x12V\n\x06states\x18\
    \x02\x20\x03(\x0b24.bitdrift_public.protobuf.workflow.v1.Workflow.StateR\
    \x06statesB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12V\n\texecution\x18\x03\
    \x20\x01(\x0b28.bitdrift_public.protobuf.workflow.v1.Workflow.ExecutionR\
    \texecution\x12}\n\x18limit_matched_logs_count\x18\x04\x20\x01(\x0b2D.bi\
    tdrift_public.protobuf.workflow.v1.Workflow.LimitMatchedLogsCountR\x15li\
    mitMatchedLogsCount\x12c\n\x0elimit_duration\x18\x05\x20\x01(\x0b2<.bitd\
    rift_public.protobuf.workflow.v1.Workflow.LimitDurationR\rlimitDuration\
    \x1a}\n\x05State\x12\x17\n\x02id\x18\x01\x20\x01(\tR\x02idB\x07\xfaB\x04\
    r\x02\x10\x01\x12[\n\x0btransitions\x18\x02\x20\x03(\x0b29.bitdrift_publ\
    ic.protobuf.workflow.v1.Workflow.TransitionR\x0btransitions\x1a\xe1\x01\
    \n\nTransition\x12/\n\x0ftarget_state_id\x18\x01\x20\x01(\tR\rtargetStat\
    eIdB\x07\xfaB\x04r\x02\x10\x01\x12Q\n\x04rule\x18\x02\x20\x01(\x0b23.bit\
    drift_public.protobuf.workflow.v1.Workflow.RuleR\x04ruleB\x08\xfaB\x05\
    \x8a\x01\x02\x10\x01\x12O\n\x07actions\x18\x03\x20\x03(\x0b25.bitdrift_p\
    ublic.protobuf.workflow.v1.Workflow.ActionR\x07actions\x1a\xde\x01\n\x04\
    Rule\x12c\n\x0erule_log_match\x18\x01\x20\x01(\x0b2;.bitdrift_public.pro\
    tobuf.workflow.v1.Workflow.RuleLogMatchH\0R\x0cruleLogMatch\x12_\n\x0cru\
    le_timeout\x18\x02\x20\x01(\x0b2:.bitdrift_public.protobuf.workflow.v1.W\
    orkflow.RuleTimeoutH\0R\x0bruleTimeoutB\x10\n\trule_type\x12\x03\xf8B\
    \x01\x1a\x89\x01\n\x0cRuleLogMatch\x12Z\n\x0blog_matcher\x18\x01\x20\x01\
    (\x0b2/.bitdrift_public.protobuf.matcher.v1.LogMatcherR\nlogMatcherB\x08\
    \xfaB\x05\x8a\x01\x02\x10\x01\x12\x1d\n\x05count\x18\x02\x20\x01(\rR\x05\
    countB\x07\xfaB\x04*\x02\x20\0\x1a7\n\x0bRuleTimeout\x12(\n\x0bduration_\
    ms\x18\x01\x20\x01(\x04R\ndurationMsB\x07\xfaB\x042\x02(\0\x1a\xc4\x0f\n\
    \x06Action\x12|\n\x14action_flush_buffers\x18\x01\x20\x01(\x0b2H.bitdrif\
    t_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffersH\0R\x12\
    actionFlushBuffers\x12v\n\x12action_emit_metric\x18\x02\x20\x01(\x0b2F.b\
    itdrift_public.protobuf.workflow.v1.Workflow.Action.ActionEmitMetricH\0R\
    \x10actionEmitMetric\x1a\xa9\x05\n\x12ActionFlushBuffers\x12\x1d\n\nbuff\
    er_ids\x18\x01\x20\x03(\tR\tbufferIds\x12\x17\n\x02id\x18\x02\x20\x01(\t\
    R\x02idB\x07\xfaB\x04r\x02\x10\x01\x12p\n\tstreaming\x18\x03\x20\x01(\
    \x0b2R.bitdrift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushB\
    uffers.StreamingR\tstreaming\x1a\xe8\x03\n\tStreaming\x12G\n\x20destinat\
    ion_streaming_buffer_ids\x18\x01\x20\x03(\tR\x1ddestinationStreamingBuff\
    erIds\x12\x9a\x01\n\x14termination_criteria\x18\x02\x20\x03(\x0b2g.bitdr\
    ift_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Strea\
    ming.TerminationCriterionR\x13terminationCriteria\x1a\xf4\x01\n\x14Termi\
    nationCriterion\x12\x92\x01\n\nlogs_count\x18\x01\x20\x01(\x0b2q.bitdrif\
    t_public.protobuf.workflow.v1.Workflow.Action.ActionFlushBuffers.Streami\
    ng.TerminationCriterion.LogsCountH\0R\tlogsCount\x1a:\n\tLogsCount\x12-\
    \n\x0emax_logs_count\x18\x01\x20\x01(\x04R\x0cmaxLogsCountB\x07\xfaB\x04\
    2\x02\x20\0B\x0b\n\x04type\x12\x03\xf8B\x01\x1a\x83\x08\n\x10ActionEmitM\
    etric\x12\x17\n\x02id\x18\x01\x20\x01(\tR\x02idB\x07\xfaB\x04r\x02\x10\
    \x01\x12j\n\x07counter\x18\x02\x20\x01(\x0b2N.bitdrift_public.protobuf.w\
    orkflow.v1.Workflow.Action.ActionEmitMetric.CounterH\0R\x07counter\x12p\
    \n\thistogram\x18\x05\x20\x01(\x0b2P.bitdrift_public.protobuf.workflow.v\
    1.Workflow.Action.ActionEmitMetric.HistogramH\0R\thistogram\x12\x16\n\
    \x05fixed\x18\x03\x20\x01(\rH\x01R\x05fixed\x12\x80\x01\n\x0ffield_extra\
    cted\x18\x06\x20\x01(\x0b2U.bitdrift_public.protobuf.workflow.v1.Workflo\
    w.Action.ActionEmitMetric.FieldExtractedH\x01R\x0efieldExtracted\x12^\n\
    \x04tags\x18\x04\x20\x03(\x0b2J.bitdrift_public.protobuf.workflow.v1.Wor\
    kflow.Action.ActionEmitMetric.TagR\x04tags\x1a\xce\x01\n\x0eFieldExtract\
    ed\x12&\n\nfield_name\x18\x01\x20\x01(\tR\tfieldNameB\x07\xfaB\x04r\x02\
    \x10\x01\x12s\n\x05exact\x18\x02\x20\x01(\x0b2[.bitdrift_public.protobuf\
    .workflow.v1.Workflow.Action.ActionEmitMetric.FieldExtracted.ExactH\0R\
    \x05exact\x1a\x07\n\x05ExactB\x16\n\x0fextraction_type\x12\x03\xf8B\x01\
    \x1a\xe2\x01\n\x03Tag\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\
    \xfaB\x04r\x02\x10\x01\x12*\n\x0bfixed_value\x18\x02\x20\x01(\tH\0R\nfix\
    edValueB\x07\xfaB\x04r\x02\x10\x01\x12\x80\x01\n\x0ffield_extracted\x18\
    \x03\x20\x01(\x0b2U.bitdrift_public.protobuf.workflow.v1.Workflow.Action\
    .ActionEmitMetric.FieldExtractedH\0R\x0efieldExtractedB\x0f\n\x08tag_typ\
    e\x12\x03\xf8B\x01\x1a\t\n\x07Counter\x1a\x0b\n\tHistogramB\x12\n\x0bmet\
    ric_type\x12\x03\xf8B\x01B\x1b\n\x14value_extractor_type\x12\x03\xf8B\
    \x01B\x12\n\x0baction_type\x12\x03\xf8B\x01\x1a\xc5\x02\n\tExecution\x12\
    ~\n\x13execution_exclusive\x18\x01\x20\x01(\x0b2K.bitdrift_public.protob\
    uf.workflow.v1.Workflow.Execution.ExecutionExclusiveH\0R\x12executionExc\
    lusive\x12{\n\x12execution_parallel\x18\x02\x20\x01(\x0b2J.bitdrift_publ\
    ic.protobuf.workflow.v1.Workflow.Execution.ExecutionParallelH\0R\x11exec\
    utionParallel\x1a\x14\n\x12ExecutionExclusive\x1a\x13\n\x11ExecutionPara\
    llelB\x10\n\x0eexecution_type\x1a6\n\x15LimitMatchedLogsCount\x12\x1d\n\
    \x05count\x18\x01\x20\x01(\rR\x05countB\x07\xfaB\x04*\x02\x20\0\x1a9\n\r\
    LimitDuration\x12(\n\x0bduration_ms\x18\x02\x20\x01(\x04R\ndurationMsB\
    \x07\xfaB\x042\x02\x20\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::validate::file_descriptor().clone());
            deps.push(super::log_matcher::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(WorkflowsConfiguration::generated_message_descriptor_data());
            messages.push(Workflow::generated_message_descriptor_data());
            messages.push(workflow::State::generated_message_descriptor_data());
            messages.push(workflow::Transition::generated_message_descriptor_data());
            messages.push(workflow::Rule::generated_message_descriptor_data());
            messages.push(workflow::RuleLogMatch::generated_message_descriptor_data());
            messages.push(workflow::RuleTimeout::generated_message_descriptor_data());
            messages.push(workflow::Action::generated_message_descriptor_data());
            messages.push(workflow::Execution::generated_message_descriptor_data());
            messages.push(workflow::LimitMatchedLogsCount::generated_message_descriptor_data());
            messages.push(workflow::LimitDuration::generated_message_descriptor_data());
            messages.push(workflow::action::ActionFlushBuffers::generated_message_descriptor_data());
            messages.push(workflow::action::ActionEmitMetric::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::Streaming::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::streaming::TerminationCriterion::generated_message_descriptor_data());
            messages.push(workflow::action::action_flush_buffers::streaming::termination_criterion::LogsCount::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::FieldExtracted::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::Tag::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::Counter::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::Histogram::generated_message_descriptor_data());
            messages.push(workflow::action::action_emit_metric::field_extracted::Exact::generated_message_descriptor_data());
            messages.push(workflow::execution::ExecutionExclusive::generated_message_descriptor_data());
            messages.push(workflow::execution::ExecutionParallel::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
