// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 29.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/matcher/v1/log_matcher.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogMatcher {
    // message oneof groups
    pub matcher: ::std::option::Option<log_matcher::Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogMatcher {
    fn default() -> &'a LogMatcher {
        <LogMatcher as ::protobuf::Message>::default_instance()
    }
}

impl LogMatcher {
    pub fn new() -> LogMatcher {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher base_matcher = 1;

    pub fn base_matcher(&self) -> &log_matcher::BaseLogMatcher {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(ref v)) => v,
            _ => <log_matcher::BaseLogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_base_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_base_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_base_matcher(&mut self, v: log_matcher::BaseLogMatcher) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_base_matcher(&mut self) -> &mut log_matcher::BaseLogMatcher {
        if let ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(log_matcher::BaseLogMatcher::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_base_matcher(&mut self) -> log_matcher::BaseLogMatcher {
        if self.has_base_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::BaseLogMatcher::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList or_matcher = 2;

    pub fn or_matcher(&self) -> &log_matcher::MatcherList {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_or_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_or_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_matcher(&mut self, v: log_matcher::MatcherList) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(log_matcher::MatcherList::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_or_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList and_matcher = 3;

    pub fn and_matcher(&self) -> &log_matcher::MatcherList {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_and_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_and_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_matcher(&mut self, v: log_matcher::MatcherList) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(log_matcher::MatcherList::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_and_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher not_matcher = 4;

    pub fn not_matcher(&self) -> &LogMatcher {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(ref v)) => v,
            _ => <LogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_not_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_not_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_matcher(&mut self, v: LogMatcher) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_matcher(&mut self) -> &mut LogMatcher {
        if let ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(LogMatcher::new())));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_matcher(&mut self) -> LogMatcher {
        if self.has_not_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(v)) => *v,
                _ => panic!(),
            }
        } else {
            LogMatcher::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::BaseLogMatcher>(
            "base_matcher",
            LogMatcher::has_base_matcher,
            LogMatcher::base_matcher,
            LogMatcher::mut_base_matcher,
            LogMatcher::set_base_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "or_matcher",
            LogMatcher::has_or_matcher,
            LogMatcher::or_matcher,
            LogMatcher::mut_or_matcher,
            LogMatcher::set_or_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "and_matcher",
            LogMatcher::has_and_matcher,
            LogMatcher::and_matcher,
            LogMatcher::mut_and_matcher,
            LogMatcher::set_and_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogMatcher>(
            "not_matcher",
            LogMatcher::has_not_matcher,
            LogMatcher::not_matcher,
            LogMatcher::mut_not_matcher,
            LogMatcher::set_not_matcher,
        ));
        oneofs.push(log_matcher::Matcher::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogMatcher>(
            "LogMatcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogMatcher {
    const NAME: &'static str = "LogMatcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(is.read_message()?));
                },
                18 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(is.read_message()?));
                },
                26 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(is.read_message()?));
                },
                34 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(is.read_message()?)));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.matcher {
            match v {
                &log_matcher::Matcher::BaseMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::OrMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::AndMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::NotMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.matcher {
            match v {
                &log_matcher::Matcher::BaseMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &log_matcher::Matcher::OrMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &log_matcher::Matcher::AndMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &log_matcher::Matcher::NotMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, &**v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogMatcher {
        LogMatcher::new()
    }

    fn clear(&mut self) {
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogMatcher {
        static instance: LogMatcher = LogMatcher {
            matcher: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogMatcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogMatcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogMatcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogMatcher`
pub mod log_matcher {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.matcher)
    pub enum Matcher {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.base_matcher)
        BaseMatcher(BaseLogMatcher),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.or_matcher)
        OrMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.and_matcher)
        AndMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.not_matcher)
        NotMatcher(::std::boxed::Box<super::LogMatcher>),
    }

    impl ::protobuf::Oneof for Matcher {
    }

    impl ::protobuf::OneofFull for Matcher {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("matcher").unwrap()).clone()
        }
    }

    impl Matcher {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Matcher>("matcher")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BaseLogMatcher {
        // message oneof groups
        pub match_type: ::std::option::Option<base_log_matcher::Match_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BaseLogMatcher {
        fn default() -> &'a BaseLogMatcher {
            <BaseLogMatcher as ::protobuf::Message>::default_instance()
        }
    }

    impl BaseLogMatcher {
        pub fn new() -> BaseLogMatcher {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch message_match = 1;

        pub fn message_match(&self) -> &base_log_matcher::MessageMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref v)) => v,
                _ => <base_log_matcher::MessageMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_message_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_message_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_message_match(&mut self, v: base_log_matcher::MessageMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_message_match(&mut self) -> &mut base_log_matcher::MessageMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(base_log_matcher::MessageMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_message_match(&mut self) -> base_log_matcher::MessageMatch {
            if self.has_message_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::MessageMatch::new()
            }
        }

        // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch tag_match = 2;

        pub fn tag_match(&self) -> &base_log_matcher::TagMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref v)) => v,
                _ => <base_log_matcher::TagMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_tag_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_tag_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_tag_match(&mut self, v: base_log_matcher::TagMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_tag_match(&mut self) -> &mut base_log_matcher::TagMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(base_log_matcher::TagMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_tag_match(&mut self) -> base_log_matcher::TagMatch {
            if self.has_tag_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::TagMatch::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::MessageMatch>(
                "message_match",
                BaseLogMatcher::has_message_match,
                BaseLogMatcher::message_match,
                BaseLogMatcher::mut_message_match,
                BaseLogMatcher::set_message_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::TagMatch>(
                "tag_match",
                BaseLogMatcher::has_tag_match,
                BaseLogMatcher::tag_match,
                BaseLogMatcher::mut_tag_match,
                BaseLogMatcher::set_tag_match,
            ));
            oneofs.push(base_log_matcher::Match_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BaseLogMatcher>(
                "LogMatcher.BaseLogMatcher",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BaseLogMatcher {
        const NAME: &'static str = "BaseLogMatcher";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(is.read_message()?));
                    },
                    18 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BaseLogMatcher {
            BaseLogMatcher::new()
        }

        fn clear(&mut self) {
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BaseLogMatcher {
            static instance: BaseLogMatcher = BaseLogMatcher {
                match_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BaseLogMatcher {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BaseLogMatcher {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BaseLogMatcher {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BaseLogMatcher`
    pub mod base_log_matcher {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.match_type)
        pub enum Match_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.message_match)
            MessageMatch(MessageMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.tag_match)
            TagMatch(TagMatch),
        }

        impl ::protobuf::Oneof for Match_type {
        }

        impl ::protobuf::OneofFull for Match_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::BaseLogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("match_type").unwrap()).clone()
            }
        }

        impl Match_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Match_type>("match_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StringValueMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StringValueMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StringValueMatch.operator)
            pub operator: ::protobuf::EnumOrUnknown<Operator>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StringValueMatch.match_value)
            pub match_value: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StringValueMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StringValueMatch {
            fn default() -> &'a StringValueMatch {
                <StringValueMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl StringValueMatch {
            pub fn new() -> StringValueMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "operator",
                    |m: &StringValueMatch| { &m.operator },
                    |m: &mut StringValueMatch| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_value",
                    |m: &StringValueMatch| { &m.match_value },
                    |m: &mut StringValueMatch| { &mut m.match_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StringValueMatch>(
                    "LogMatcher.BaseLogMatcher.StringValueMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for StringValueMatch {
            const NAME: &'static str = "StringValueMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.operator = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.match_value = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    my_size += ::protobuf::rt::int32_size(1, self.operator.value());
                }
                if !self.match_value.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.match_value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.operator))?;
                }
                if !self.match_value.is_empty() {
                    os.write_string(2, &self.match_value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StringValueMatch {
                StringValueMatch::new()
            }

            fn clear(&mut self) {
                self.operator = ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED);
                self.match_value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StringValueMatch {
                static instance: StringValueMatch = StringValueMatch {
                    operator: ::protobuf::EnumOrUnknown::from_i32(0),
                    match_value: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for StringValueMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.StringValueMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StringValueMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for StringValueMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IntValueMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct IntValueMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IntValueMatch.operator)
            pub operator: ::protobuf::EnumOrUnknown<Operator>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IntValueMatch.match_value)
            pub match_value: i32,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IntValueMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a IntValueMatch {
            fn default() -> &'a IntValueMatch {
                <IntValueMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl IntValueMatch {
            pub fn new() -> IntValueMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "operator",
                    |m: &IntValueMatch| { &m.operator },
                    |m: &mut IntValueMatch| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_value",
                    |m: &IntValueMatch| { &m.match_value },
                    |m: &mut IntValueMatch| { &mut m.match_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntValueMatch>(
                    "LogMatcher.BaseLogMatcher.IntValueMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for IntValueMatch {
            const NAME: &'static str = "IntValueMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.operator = is.read_enum_or_unknown()?;
                        },
                        16 => {
                            self.match_value = is.read_int32()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    my_size += ::protobuf::rt::int32_size(1, self.operator.value());
                }
                if self.match_value != 0 {
                    my_size += ::protobuf::rt::int32_size(2, self.match_value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.operator))?;
                }
                if self.match_value != 0 {
                    os.write_int32(2, self.match_value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> IntValueMatch {
                IntValueMatch::new()
            }

            fn clear(&mut self) {
                self.operator = ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED);
                self.match_value = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static IntValueMatch {
                static instance: IntValueMatch = IntValueMatch {
                    operator: ::protobuf::EnumOrUnknown::from_i32(0),
                    match_value: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for IntValueMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.IntValueMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for IntValueMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for IntValueMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SemVerValueMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatch.operator)
            pub operator: ::protobuf::EnumOrUnknown<Operator>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatch.match_value)
            pub match_value: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SemVerValueMatch {
            fn default() -> &'a SemVerValueMatch {
                <SemVerValueMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl SemVerValueMatch {
            pub fn new() -> SemVerValueMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "operator",
                    |m: &SemVerValueMatch| { &m.operator },
                    |m: &mut SemVerValueMatch| { &mut m.operator },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "match_value",
                    |m: &SemVerValueMatch| { &m.match_value },
                    |m: &mut SemVerValueMatch| { &mut m.match_value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SemVerValueMatch>(
                    "LogMatcher.BaseLogMatcher.SemVerValueMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SemVerValueMatch {
            const NAME: &'static str = "SemVerValueMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.operator = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.match_value = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    my_size += ::protobuf::rt::int32_size(1, self.operator.value());
                }
                if !self.match_value.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.match_value);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.operator != ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.operator))?;
                }
                if !self.match_value.is_empty() {
                    os.write_string(2, &self.match_value)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SemVerValueMatch {
                SemVerValueMatch::new()
            }

            fn clear(&mut self) {
                self.operator = ::protobuf::EnumOrUnknown::new(Operator::OPERATOR_UNSPECIFIED);
                self.match_value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SemVerValueMatch {
                static instance: SemVerValueMatch = SemVerValueMatch {
                    operator: ::protobuf::EnumOrUnknown::from_i32(0),
                    match_value: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SemVerValueMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.SemVerValueMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SemVerValueMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SemVerValueMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch.string_value_match)
            pub string_value_match: ::protobuf::MessageField<StringValueMatch>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageMatch {
            fn default() -> &'a MessageMatch {
                <MessageMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl MessageMatch {
            pub fn new() -> MessageMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StringValueMatch>(
                    "string_value_match",
                    |m: &MessageMatch| { &m.string_value_match },
                    |m: &mut MessageMatch| { &mut m.string_value_match },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageMatch>(
                    "LogMatcher.BaseLogMatcher.MessageMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MessageMatch {
            const NAME: &'static str = "MessageMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.string_value_match)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.string_value_match.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.string_value_match.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageMatch {
                MessageMatch::new()
            }

            fn clear(&mut self) {
                self.string_value_match.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageMatch {
                static instance: MessageMatch = MessageMatch {
                    string_value_match: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MessageMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.MessageMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessageMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MessageMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IsSetMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct IsSetMatch {
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IsSetMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a IsSetMatch {
            fn default() -> &'a IsSetMatch {
                <IsSetMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl IsSetMatch {
            pub fn new() -> IsSetMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(0);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IsSetMatch>(
                    "LogMatcher.BaseLogMatcher.IsSetMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for IsSetMatch {
            const NAME: &'static str = "IsSetMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> IsSetMatch {
                IsSetMatch::new()
            }

            fn clear(&mut self) {
                self.special_fields.clear();
            }

            fn default_instance() -> &'static IsSetMatch {
                static instance: IsSetMatch = IsSetMatch {
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for IsSetMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.IsSetMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for IsSetMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for IsSetMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TagMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.tag_key)
            pub tag_key: ::std::string::String,
            // message oneof groups
            pub value_match: ::std::option::Option<tag_match::Value_match>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TagMatch {
            fn default() -> &'a TagMatch {
                <TagMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl TagMatch {
            pub fn new() -> TagMatch {
                ::std::default::Default::default()
            }

            // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StringValueMatch string_value_match = 2;

            pub fn string_value_match(&self) -> &StringValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(ref v)) => v,
                    _ => <StringValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_string_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_string_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_string_value_match(&mut self, v: StringValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_string_value_match(&mut self) -> &mut StringValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(StringValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_string_value_match(&mut self) -> StringValueMatch {
                if self.has_string_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    StringValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IntValueMatch int_value_match = 3;

            pub fn int_value_match(&self) -> &IntValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(ref v)) => v,
                    _ => <IntValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_int_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_int_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_int_value_match(&mut self, v: IntValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_int_value_match(&mut self) -> &mut IntValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(IntValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_int_value_match(&mut self) -> IntValueMatch {
                if self.has_int_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    IntValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatch sem_ver_value_match = 4;

            pub fn sem_ver_value_match(&self) -> &SemVerValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(ref v)) => v,
                    _ => <SemVerValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_sem_ver_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_sem_ver_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_sem_ver_value_match(&mut self, v: SemVerValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_sem_ver_value_match(&mut self) -> &mut SemVerValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(SemVerValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_sem_ver_value_match(&mut self) -> SemVerValueMatch {
                if self.has_sem_ver_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    SemVerValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IsSetMatch is_set_match = 5;

            pub fn is_set_match(&self) -> &IsSetMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(ref v)) => v,
                    _ => <IsSetMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_is_set_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_is_set_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_is_set_match(&mut self, v: IsSetMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_is_set_match(&mut self) -> &mut IsSetMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(IsSetMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_is_set_match(&mut self) -> IsSetMatch {
                if self.has_is_set_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    IsSetMatch::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tag_key",
                    |m: &TagMatch| { &m.tag_key },
                    |m: &mut TagMatch| { &mut m.tag_key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StringValueMatch>(
                    "string_value_match",
                    TagMatch::has_string_value_match,
                    TagMatch::string_value_match,
                    TagMatch::mut_string_value_match,
                    TagMatch::set_string_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IntValueMatch>(
                    "int_value_match",
                    TagMatch::has_int_value_match,
                    TagMatch::int_value_match,
                    TagMatch::mut_int_value_match,
                    TagMatch::set_int_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SemVerValueMatch>(
                    "sem_ver_value_match",
                    TagMatch::has_sem_ver_value_match,
                    TagMatch::sem_ver_value_match,
                    TagMatch::mut_sem_ver_value_match,
                    TagMatch::set_sem_ver_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, IsSetMatch>(
                    "is_set_match",
                    TagMatch::has_is_set_match,
                    TagMatch::is_set_match,
                    TagMatch::mut_is_set_match,
                    TagMatch::set_is_set_match,
                ));
                oneofs.push(tag_match::Value_match::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TagMatch>(
                    "LogMatcher.BaseLogMatcher.TagMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TagMatch {
            const NAME: &'static str = "TagMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.tag_key = is.read_string()?;
                        },
                        18 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(is.read_message()?));
                        },
                        26 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(is.read_message()?));
                        },
                        34 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(is.read_message()?));
                        },
                        42 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.tag_key.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.tag_key);
                }
                if let ::std::option::Option::Some(ref v) = self.value_match {
                    match v {
                        &tag_match::Value_match::StringValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::IntValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::SemVerValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::IsSetMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.tag_key.is_empty() {
                    os.write_string(1, &self.tag_key)?;
                }
                if let ::std::option::Option::Some(ref v) = self.value_match {
                    match v {
                        &tag_match::Value_match::StringValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                        &tag_match::Value_match::IntValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                        &tag_match::Value_match::SemVerValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                        },
                        &tag_match::Value_match::IsSetMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TagMatch {
                TagMatch::new()
            }

            fn clear(&mut self) {
                self.tag_key.clear();
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TagMatch {
                static instance: TagMatch = TagMatch {
                    tag_key: ::std::string::String::new(),
                    value_match: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TagMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.TagMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TagMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TagMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `TagMatch`
        pub mod tag_match {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.value_match)
            pub enum Value_match {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.string_value_match)
                StringValueMatch(super::StringValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.int_value_match)
                IntValueMatch(super::IntValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.sem_ver_value_match)
                SemVerValueMatch(super::SemVerValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.is_set_match)
                IsSetMatch(super::IsSetMatch),
            }

            impl ::protobuf::Oneof for Value_match {
            }

            impl ::protobuf::OneofFull for Value_match {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::TagMatch as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_match").unwrap()).clone()
                }
            }

            impl Value_match {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_match>("value_match")
                }
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator)
        pub enum Operator {
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_UNSPECIFIED)
            OPERATOR_UNSPECIFIED = 0,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_LESS_THAN)
            OPERATOR_LESS_THAN = 1,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_LESS_THAN_OR_EQUAL)
            OPERATOR_LESS_THAN_OR_EQUAL = 2,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_EQUALS)
            OPERATOR_EQUALS = 3,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_GREATER_THAN)
            OPERATOR_GREATER_THAN = 4,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_GREATER_THAN_OR_EQUAL)
            OPERATOR_GREATER_THAN_OR_EQUAL = 5,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_NOT_EQUALS)
            OPERATOR_NOT_EQUALS = 6,
            // @@protoc_insertion_point(enum_value:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Operator.OPERATOR_REGEX)
            OPERATOR_REGEX = 7,
        }

        impl ::protobuf::Enum for Operator {
            const NAME: &'static str = "Operator";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Operator> {
                match value {
                    0 => ::std::option::Option::Some(Operator::OPERATOR_UNSPECIFIED),
                    1 => ::std::option::Option::Some(Operator::OPERATOR_LESS_THAN),
                    2 => ::std::option::Option::Some(Operator::OPERATOR_LESS_THAN_OR_EQUAL),
                    3 => ::std::option::Option::Some(Operator::OPERATOR_EQUALS),
                    4 => ::std::option::Option::Some(Operator::OPERATOR_GREATER_THAN),
                    5 => ::std::option::Option::Some(Operator::OPERATOR_GREATER_THAN_OR_EQUAL),
                    6 => ::std::option::Option::Some(Operator::OPERATOR_NOT_EQUALS),
                    7 => ::std::option::Option::Some(Operator::OPERATOR_REGEX),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Operator> {
                match str {
                    "OPERATOR_UNSPECIFIED" => ::std::option::Option::Some(Operator::OPERATOR_UNSPECIFIED),
                    "OPERATOR_LESS_THAN" => ::std::option::Option::Some(Operator::OPERATOR_LESS_THAN),
                    "OPERATOR_LESS_THAN_OR_EQUAL" => ::std::option::Option::Some(Operator::OPERATOR_LESS_THAN_OR_EQUAL),
                    "OPERATOR_EQUALS" => ::std::option::Option::Some(Operator::OPERATOR_EQUALS),
                    "OPERATOR_GREATER_THAN" => ::std::option::Option::Some(Operator::OPERATOR_GREATER_THAN),
                    "OPERATOR_GREATER_THAN_OR_EQUAL" => ::std::option::Option::Some(Operator::OPERATOR_GREATER_THAN_OR_EQUAL),
                    "OPERATOR_NOT_EQUALS" => ::std::option::Option::Some(Operator::OPERATOR_NOT_EQUALS),
                    "OPERATOR_REGEX" => ::std::option::Option::Some(Operator::OPERATOR_REGEX),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Operator] = &[
                Operator::OPERATOR_UNSPECIFIED,
                Operator::OPERATOR_LESS_THAN,
                Operator::OPERATOR_LESS_THAN_OR_EQUAL,
                Operator::OPERATOR_EQUALS,
                Operator::OPERATOR_GREATER_THAN,
                Operator::OPERATOR_GREATER_THAN_OR_EQUAL,
                Operator::OPERATOR_NOT_EQUALS,
                Operator::OPERATOR_REGEX,
            ];
        }

        impl ::protobuf::EnumFull for Operator {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("LogMatcher.BaseLogMatcher.Operator").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Operator {
            fn default() -> Self {
                Operator::OPERATOR_UNSPECIFIED
            }
        }

        impl Operator {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Operator>("LogMatcher.BaseLogMatcher.Operator")
            }
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatcherList {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList.log_matchers)
        pub log_matchers: ::std::vec::Vec<super::LogMatcher>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatcherList {
        fn default() -> &'a MatcherList {
            <MatcherList as ::protobuf::Message>::default_instance()
        }
    }

    impl MatcherList {
        pub fn new() -> MatcherList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "log_matchers",
                |m: &MatcherList| { &m.log_matchers },
                |m: &mut MatcherList| { &mut m.log_matchers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatcherList>(
                "LogMatcher.MatcherList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatcherList {
        const NAME: &'static str = "MatcherList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.log_matchers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.log_matchers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.log_matchers {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatcherList {
            MatcherList::new()
        }

        fn clear(&mut self) {
            self.log_matchers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatcherList {
            static instance: MatcherList = MatcherList {
                log_matchers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatcherList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.MatcherList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatcherList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatcherList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n5bitdrift_public/protobuf/matcher/v1/log_matcher.proto\x12#bitdrift_pu\
    blic.protobuf.matcher.v1\x1a\x17validate/validate.proto\"\xc5\x11\n\nLog\
    Matcher\x12c\n\x0cbase_matcher\x18\x01\x20\x01(\x0b2>.bitdrift_public.pr\
    otobuf.matcher.v1.LogMatcher.BaseLogMatcherH\0R\x0bbaseMatcher\x12\\\n\n\
    or_matcher\x18\x02\x20\x01(\x0b2;.bitdrift_public.protobuf.matcher.v1.Lo\
    gMatcher.MatcherListH\0R\torMatcher\x12^\n\x0band_matcher\x18\x03\x20\
    \x01(\x0b2;.bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherListH\
    \0R\nandMatcher\x12R\n\x0bnot_matcher\x18\x04\x20\x01(\x0b2/.bitdrift_pu\
    blic.protobuf.matcher.v1.LogMatcherH\0R\nnotMatcher\x1a\xc2\r\n\x0eBaseL\
    ogMatcher\x12r\n\rmessage_match\x18\x01\x20\x01(\x0b2K.bitdrift_public.p\
    rotobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatchH\0R\x0cmessage\
    Match\x12f\n\ttag_match\x18\x02\x20\x01(\x0b2G.bitdrift_public.protobuf.\
    matcher.v1.LogMatcher.BaseLogMatcher.TagMatchH\0R\x08tagMatch\x1a\xab\
    \x01\n\x10StringValueMatch\x12m\n\x08operator\x18\x01\x20\x01(\x0e2G.bit\
    drift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.OperatorR\x08\
    operatorB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12(\n\x0bmatch_value\x18\x02\
    \x20\x01(\tR\nmatchValueB\x07\xfaB\x04r\x02\x10\x01\x1a\xa9\x01\n\rIntVa\
    lueMatch\x12m\n\x08operator\x18\x01\x20\x01(\x0e2G.bitdrift_public.proto\
    buf.matcher.v1.LogMatcher.BaseLogMatcher.OperatorR\x08operatorB\x08\xfaB\
    \x05\x82\x01\x02\x10\x01\x12)\n\x0bmatch_value\x18\x02\x20\x01(\x05R\nma\
    tchValueB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x1a\xab\x01\n\x10SemVerValueM\
    atch\x12m\n\x08operator\x18\x01\x20\x01(\x0e2G.bitdrift_public.protobuf.\
    matcher.v1.LogMatcher.BaseLogMatcher.OperatorR\x08operatorB\x08\xfaB\x05\
    \x82\x01\x02\x10\x01\x12(\n\x0bmatch_value\x18\x02\x20\x01(\tR\nmatchVal\
    ueB\x07\xfaB\x04r\x02\x10\x01\x1a\x8d\x01\n\x0cMessageMatch\x12}\n\x12st\
    ring_value_match\x18\x01\x20\x01(\x0b2O.bitdrift_public.protobuf.matcher\
    .v1.LogMatcher.BaseLogMatcher.StringValueMatchR\x10stringValueMatch\x1a\
    \x0c\n\nIsSetMatch\x1a\xad\x04\n\x08TagMatch\x12\"\n\x07tag_key\x18\x01\
    \x20\x01(\tR\x06tagKeyB\t\xfaB\x06r\x04\x10\x01\x18@\x12\x7f\n\x12string\
    _value_match\x18\x02\x20\x01(\x0b2O.bitdrift_public.protobuf.matcher.v1.\
    LogMatcher.BaseLogMatcher.StringValueMatchH\0R\x10stringValueMatch\x12v\
    \n\x0fint_value_match\x18\x03\x20\x01(\x0b2L.bitdrift_public.protobuf.ma\
    tcher.v1.LogMatcher.BaseLogMatcher.IntValueMatchH\0R\rintValueMatch\x12\
    \x80\x01\n\x13sem_ver_value_match\x18\x04\x20\x01(\x0b2O.bitdrift_public\
    .protobuf.matcher.v1.LogMatcher.BaseLogMatcher.SemVerValueMatchH\0R\x10s\
    emVerValueMatch\x12m\n\x0cis_set_match\x18\x05\x20\x01(\x0b2I.bitdrift_p\
    ublic.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.IsSetMatchH\0R\nisSe\
    tMatchB\x12\n\x0bvalue_match\x12\x03\xf8B\x01\"\xea\x01\n\x08Operator\
    \x12\x18\n\x14OPERATOR_UNSPECIFIED\x10\0\x12\x16\n\x12OPERATOR_LESS_THAN\
    \x10\x01\x12\x1f\n\x1bOPERATOR_LESS_THAN_OR_EQUAL\x10\x02\x12\x13\n\x0fO\
    PERATOR_EQUALS\x10\x03\x12\x19\n\x15OPERATOR_GREATER_THAN\x10\x04\x12\"\
    \n\x1eOPERATOR_GREATER_THAN_OR_EQUAL\x10\x05\x12\x17\n\x13OPERATOR_NOT_E\
    QUALS\x10\x06\x12\x12\n\x0eOPERATOR_REGEX\x10\x07\"\x04\x08\x08\x10\x08\
    \"\x04\x08\t\x10\tB\x11\n\nmatch_type\x12\x03\xf8B\x01\x1ak\n\x0bMatcher\
    List\x12\\\n\x0clog_matchers\x18\x01\x20\x03(\x0b2/.bitdrift_public.prot\
    obuf.matcher.v1.LogMatcherR\x0blogMatchersB\x08\xfaB\x05\x92\x01\x02\x08\
    \x02B\x0e\n\x07matcher\x12\x03\xf8B\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::validate::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(LogMatcher::generated_message_descriptor_data());
            messages.push(log_matcher::BaseLogMatcher::generated_message_descriptor_data());
            messages.push(log_matcher::MatcherList::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::StringValueMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::IntValueMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::SemVerValueMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::MessageMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::IsSetMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::TagMatch::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(log_matcher::base_log_matcher::Operator::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
