// proto - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

// This file is generated by rust-protobuf 4.0.0-alpha.0. Do not edit
// .proto file is parsed by protoc 33.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `bitdrift_public/protobuf/matcher/v1/log_matcher.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_4_0_0_ALPHA_0;

// @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LogMatcher {
    // message oneof groups
    pub matcher: ::std::option::Option<log_matcher::Matcher>,
    // special fields
    // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogMatcher {
    fn default() -> &'a LogMatcher {
        <LogMatcher as ::protobuf::Message>::default_instance()
    }
}

impl LogMatcher {
    pub fn new() -> LogMatcher {
        ::std::default::Default::default()
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher base_matcher = 1;

    pub fn base_matcher(&self) -> &log_matcher::BaseLogMatcher {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(ref v)) => v,
            _ => <log_matcher::BaseLogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_base_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_base_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_base_matcher(&mut self, v: log_matcher::BaseLogMatcher) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_base_matcher(&mut self) -> &mut log_matcher::BaseLogMatcher {
        if let ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(log_matcher::BaseLogMatcher::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_base_matcher(&mut self) -> log_matcher::BaseLogMatcher {
        if self.has_base_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::BaseLogMatcher::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList or_matcher = 2;

    pub fn or_matcher(&self) -> &log_matcher::MatcherList {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_or_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_or_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_matcher(&mut self, v: log_matcher::MatcherList) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(log_matcher::MatcherList::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_or_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList and_matcher = 3;

    pub fn and_matcher(&self) -> &log_matcher::MatcherList {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(ref v)) => v,
            _ => <log_matcher::MatcherList as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_and_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_and_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_matcher(&mut self, v: log_matcher::MatcherList) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_matcher(&mut self) -> &mut log_matcher::MatcherList {
        if let ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(log_matcher::MatcherList::new()));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_matcher(&mut self) -> log_matcher::MatcherList {
        if self.has_and_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(v)) => v,
                _ => panic!(),
            }
        } else {
            log_matcher::MatcherList::new()
        }
    }

    // .bitdrift_public.protobuf.matcher.v1.LogMatcher not_matcher = 4;

    pub fn not_matcher(&self) -> &LogMatcher {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(ref v)) => v,
            _ => <LogMatcher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_not_matcher(&mut self) {
        self.matcher = ::std::option::Option::None;
    }

    pub fn has_not_matcher(&self) -> bool {
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_matcher(&mut self, v: LogMatcher) {
        self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_matcher(&mut self) -> &mut LogMatcher {
        if let ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(_)) = self.matcher {
        } else {
            self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(LogMatcher::new())));
        }
        match self.matcher {
            ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_matcher(&mut self) -> LogMatcher {
        if self.has_not_matcher() {
            match self.matcher.take() {
                ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(v)) => *v,
                _ => panic!(),
            }
        } else {
            LogMatcher::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::BaseLogMatcher>(
            "base_matcher",
            LogMatcher::has_base_matcher,
            LogMatcher::base_matcher,
            LogMatcher::mut_base_matcher,
            LogMatcher::set_base_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "or_matcher",
            LogMatcher::has_or_matcher,
            LogMatcher::or_matcher,
            LogMatcher::mut_or_matcher,
            LogMatcher::set_or_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, log_matcher::MatcherList>(
            "and_matcher",
            LogMatcher::has_and_matcher,
            LogMatcher::and_matcher,
            LogMatcher::mut_and_matcher,
            LogMatcher::set_and_matcher,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LogMatcher>(
            "not_matcher",
            LogMatcher::has_not_matcher,
            LogMatcher::not_matcher,
            LogMatcher::mut_not_matcher,
            LogMatcher::set_not_matcher,
        ));
        oneofs.push(log_matcher::Matcher::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogMatcher>(
            "LogMatcher",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogMatcher {
    const NAME: &'static str = "LogMatcher";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::BaseMatcher(is.read_message()?));
                },
                18 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::OrMatcher(is.read_message()?));
                },
                26 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::AndMatcher(is.read_message()?));
                },
                34 => {
                    self.matcher = ::std::option::Option::Some(log_matcher::Matcher::NotMatcher(::std::boxed::Box::new(is.read_message()?)));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.matcher {
            match v {
                &log_matcher::Matcher::BaseMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::OrMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::AndMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &log_matcher::Matcher::NotMatcher(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.matcher {
            match v {
                &log_matcher::Matcher::BaseMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &log_matcher::Matcher::OrMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &log_matcher::Matcher::AndMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &log_matcher::Matcher::NotMatcher(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, &**v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogMatcher {
        LogMatcher::new()
    }

    fn clear(&mut self) {
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.matcher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogMatcher {
        static instance: LogMatcher = LogMatcher {
            matcher: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogMatcher {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogMatcher").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogMatcher {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LogMatcher`
pub mod log_matcher {

    #[derive(Clone,PartialEq,Debug)]
    // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.matcher)
    pub enum Matcher {
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.base_matcher)
        BaseMatcher(BaseLogMatcher),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.or_matcher)
        OrMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.and_matcher)
        AndMatcher(MatcherList),
        // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.not_matcher)
        NotMatcher(::std::boxed::Box<super::LogMatcher>),
    }

    impl ::protobuf::Oneof for Matcher {
    }

    impl ::protobuf::OneofFull for Matcher {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("matcher").unwrap()).clone()
        }
    }

    impl Matcher {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Matcher>("matcher")
        }
    }
    // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BaseLogMatcher {
        // message oneof groups
        pub match_type: ::std::option::Option<base_log_matcher::Match_type>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BaseLogMatcher {
        fn default() -> &'a BaseLogMatcher {
            <BaseLogMatcher as ::protobuf::Message>::default_instance()
        }
    }

    impl BaseLogMatcher {
        pub fn new() -> BaseLogMatcher {
            ::std::default::Default::default()
        }

        // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch message_match = 1;

        pub fn message_match(&self) -> &base_log_matcher::MessageMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref v)) => v,
                _ => <base_log_matcher::MessageMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_message_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_message_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_message_match(&mut self, v: base_log_matcher::MessageMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_message_match(&mut self) -> &mut base_log_matcher::MessageMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(base_log_matcher::MessageMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_message_match(&mut self) -> base_log_matcher::MessageMatch {
            if self.has_message_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::MessageMatch::new()
            }
        }

        // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch tag_match = 2;

        pub fn tag_match(&self) -> &base_log_matcher::TagMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref v)) => v,
                _ => <base_log_matcher::TagMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_tag_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_tag_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_tag_match(&mut self, v: base_log_matcher::TagMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_tag_match(&mut self) -> &mut base_log_matcher::TagMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(base_log_matcher::TagMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_tag_match(&mut self) -> base_log_matcher::TagMatch {
            if self.has_tag_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::TagMatch::new()
            }
        }

        // .bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch state_match = 4;

        pub fn state_match(&self) -> &base_log_matcher::StateMatch {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(ref v)) => v,
                _ => <base_log_matcher::StateMatch as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_state_match(&mut self) {
            self.match_type = ::std::option::Option::None;
        }

        pub fn has_state_match(&self) -> bool {
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_state_match(&mut self, v: base_log_matcher::StateMatch) {
            self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(v))
        }

        // Mutable pointer to the field.
        pub fn mut_state_match(&mut self) -> &mut base_log_matcher::StateMatch {
            if let ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(_)) = self.match_type {
            } else {
                self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(base_log_matcher::StateMatch::new()));
            }
            match self.match_type {
                ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_state_match(&mut self) -> base_log_matcher::StateMatch {
            if self.has_state_match() {
                match self.match_type.take() {
                    ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(v)) => v,
                    _ => panic!(),
                }
            } else {
                base_log_matcher::StateMatch::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::MessageMatch>(
                "message_match",
                BaseLogMatcher::has_message_match,
                BaseLogMatcher::message_match,
                BaseLogMatcher::mut_message_match,
                BaseLogMatcher::set_message_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::TagMatch>(
                "tag_match",
                BaseLogMatcher::has_tag_match,
                BaseLogMatcher::tag_match,
                BaseLogMatcher::mut_tag_match,
                BaseLogMatcher::set_tag_match,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, base_log_matcher::StateMatch>(
                "state_match",
                BaseLogMatcher::has_state_match,
                BaseLogMatcher::state_match,
                BaseLogMatcher::mut_state_match,
                BaseLogMatcher::set_state_match,
            ));
            oneofs.push(base_log_matcher::Match_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BaseLogMatcher>(
                "LogMatcher.BaseLogMatcher",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BaseLogMatcher {
        const NAME: &'static str = "BaseLogMatcher";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::MessageMatch(is.read_message()?));
                    },
                    18 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::TagMatch(is.read_message()?));
                    },
                    34 => {
                        self.match_type = ::std::option::Option::Some(base_log_matcher::Match_type::StateMatch(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &base_log_matcher::Match_type::StateMatch(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.match_type {
                match v {
                    &base_log_matcher::Match_type::MessageMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &base_log_matcher::Match_type::TagMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &base_log_matcher::Match_type::StateMatch(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BaseLogMatcher {
            BaseLogMatcher::new()
        }

        fn clear(&mut self) {
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.match_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BaseLogMatcher {
            static instance: BaseLogMatcher = BaseLogMatcher {
                match_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BaseLogMatcher {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BaseLogMatcher {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BaseLogMatcher {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BaseLogMatcher`
    pub mod base_log_matcher {

        #[derive(Clone,PartialEq,Debug)]
        // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.match_type)
        pub enum Match_type {
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.message_match)
            MessageMatch(MessageMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.tag_match)
            TagMatch(TagMatch),
            // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.state_match)
            StateMatch(StateMatch),
        }

        impl ::protobuf::Oneof for Match_type {
        }

        impl ::protobuf::OneofFull for Match_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::BaseLogMatcher as ::protobuf::MessageFull>::descriptor().oneof_by_name("match_type").unwrap()).clone()
            }
        }

        impl Match_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Match_type>("match_type")
            }
        }
        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch.string_value_match)
            pub string_value_match: ::protobuf::MessageField<super::super::super::value_matcher::StringValueMatch>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.MessageMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageMatch {
            fn default() -> &'a MessageMatch {
                <MessageMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl MessageMatch {
            pub fn new() -> MessageMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::value_matcher::StringValueMatch>(
                    "string_value_match",
                    |m: &MessageMatch| { &m.string_value_match },
                    |m: &mut MessageMatch| { &mut m.string_value_match },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageMatch>(
                    "LogMatcher.BaseLogMatcher.MessageMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MessageMatch {
            const NAME: &'static str = "MessageMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.string_value_match)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.string_value_match.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.string_value_match.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageMatch {
                MessageMatch::new()
            }

            fn clear(&mut self) {
                self.string_value_match.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageMatch {
                static instance: MessageMatch = MessageMatch {
                    string_value_match: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MessageMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.MessageMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessageMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MessageMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TagMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.tag_key)
            pub tag_key: ::std::string::String,
            // message oneof groups
            pub value_match: ::std::option::Option<tag_match::Value_match>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TagMatch {
            fn default() -> &'a TagMatch {
                <TagMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl TagMatch {
            pub fn new() -> TagMatch {
                ::std::default::Default::default()
            }

            // .bitdrift_public.protobuf.value_matcher.v1.StringValueMatch string_value_match = 2;

            pub fn string_value_match(&self) -> &super::super::super::value_matcher::StringValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(ref v)) => v,
                    _ => <super::super::super::value_matcher::StringValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_string_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_string_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_string_value_match(&mut self, v: super::super::super::value_matcher::StringValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_string_value_match(&mut self) -> &mut super::super::super::value_matcher::StringValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(super::super::super::value_matcher::StringValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_string_value_match(&mut self) -> super::super::super::value_matcher::StringValueMatch {
                if self.has_string_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::super::value_matcher::StringValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.value_matcher.v1.IntValueMatch int_value_match = 3;

            pub fn int_value_match(&self) -> &super::super::super::value_matcher::IntValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(ref v)) => v,
                    _ => <super::super::super::value_matcher::IntValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_int_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_int_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_int_value_match(&mut self, v: super::super::super::value_matcher::IntValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_int_value_match(&mut self) -> &mut super::super::super::value_matcher::IntValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(super::super::super::value_matcher::IntValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_int_value_match(&mut self) -> super::super::super::value_matcher::IntValueMatch {
                if self.has_int_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::super::value_matcher::IntValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.value_matcher.v1.SemVerValueMatch sem_ver_value_match = 4;

            pub fn sem_ver_value_match(&self) -> &super::super::super::value_matcher::SemVerValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(ref v)) => v,
                    _ => <super::super::super::value_matcher::SemVerValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_sem_ver_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_sem_ver_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_sem_ver_value_match(&mut self, v: super::super::super::value_matcher::SemVerValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_sem_ver_value_match(&mut self) -> &mut super::super::super::value_matcher::SemVerValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(super::super::super::value_matcher::SemVerValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_sem_ver_value_match(&mut self) -> super::super::super::value_matcher::SemVerValueMatch {
                if self.has_sem_ver_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::super::value_matcher::SemVerValueMatch::new()
                }
            }

            // .bitdrift_public.protobuf.value_matcher.v1.IsSetMatch is_set_match = 5;

            pub fn is_set_match(&self) -> &super::super::super::value_matcher::IsSetMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(ref v)) => v,
                    _ => <super::super::super::value_matcher::IsSetMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_is_set_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_is_set_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_is_set_match(&mut self, v: super::super::super::value_matcher::IsSetMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_is_set_match(&mut self) -> &mut super::super::super::value_matcher::IsSetMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(super::super::super::value_matcher::IsSetMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_is_set_match(&mut self) -> super::super::super::value_matcher::IsSetMatch {
                if self.has_is_set_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::super::value_matcher::IsSetMatch::new()
                }
            }

            // .bitdrift_public.protobuf.value_matcher.v1.DoubleValueMatch double_value_match = 6;

            pub fn double_value_match(&self) -> &super::super::super::value_matcher::DoubleValueMatch {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(ref v)) => v,
                    _ => <super::super::super::value_matcher::DoubleValueMatch as ::protobuf::Message>::default_instance(),
                }
            }

            pub fn clear_double_value_match(&mut self) {
                self.value_match = ::std::option::Option::None;
            }

            pub fn has_double_value_match(&self) -> bool {
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(..)) => true,
                    _ => false,
                }
            }

            // Param is passed by value, moved
            pub fn set_double_value_match(&mut self, v: super::super::super::value_matcher::DoubleValueMatch) {
                self.value_match = ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(v))
            }

            // Mutable pointer to the field.
            pub fn mut_double_value_match(&mut self) -> &mut super::super::super::value_matcher::DoubleValueMatch {
                if let ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(_)) = self.value_match {
                } else {
                    self.value_match = ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(super::super::super::value_matcher::DoubleValueMatch::new()));
                }
                match self.value_match {
                    ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(ref mut v)) => v,
                    _ => panic!(),
                }
            }

            // Take field
            pub fn take_double_value_match(&mut self) -> super::super::super::value_matcher::DoubleValueMatch {
                if self.has_double_value_match() {
                    match self.value_match.take() {
                        ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(v)) => v,
                        _ => panic!(),
                    }
                } else {
                    super::super::super::value_matcher::DoubleValueMatch::new()
                }
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(1);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tag_key",
                    |m: &TagMatch| { &m.tag_key },
                    |m: &mut TagMatch| { &mut m.tag_key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::super::value_matcher::StringValueMatch>(
                    "string_value_match",
                    TagMatch::has_string_value_match,
                    TagMatch::string_value_match,
                    TagMatch::mut_string_value_match,
                    TagMatch::set_string_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::super::value_matcher::IntValueMatch>(
                    "int_value_match",
                    TagMatch::has_int_value_match,
                    TagMatch::int_value_match,
                    TagMatch::mut_int_value_match,
                    TagMatch::set_int_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::super::value_matcher::SemVerValueMatch>(
                    "sem_ver_value_match",
                    TagMatch::has_sem_ver_value_match,
                    TagMatch::sem_ver_value_match,
                    TagMatch::mut_sem_ver_value_match,
                    TagMatch::set_sem_ver_value_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::super::value_matcher::IsSetMatch>(
                    "is_set_match",
                    TagMatch::has_is_set_match,
                    TagMatch::is_set_match,
                    TagMatch::mut_is_set_match,
                    TagMatch::set_is_set_match,
                ));
                fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::super::super::value_matcher::DoubleValueMatch>(
                    "double_value_match",
                    TagMatch::has_double_value_match,
                    TagMatch::double_value_match,
                    TagMatch::mut_double_value_match,
                    TagMatch::set_double_value_match,
                ));
                oneofs.push(tag_match::Value_match::generated_oneof_descriptor_data());
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TagMatch>(
                    "LogMatcher.BaseLogMatcher.TagMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TagMatch {
            const NAME: &'static str = "TagMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.tag_key = is.read_string()?;
                        },
                        18 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::StringValueMatch(is.read_message()?));
                        },
                        26 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::IntValueMatch(is.read_message()?));
                        },
                        34 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::SemVerValueMatch(is.read_message()?));
                        },
                        42 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::IsSetMatch(is.read_message()?));
                        },
                        50 => {
                            self.value_match = ::std::option::Option::Some(tag_match::Value_match::DoubleValueMatch(is.read_message()?));
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.tag_key.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.tag_key);
                }
                if let ::std::option::Option::Some(ref v) = self.value_match {
                    match v {
                        &tag_match::Value_match::StringValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::IntValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::SemVerValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::IsSetMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                        &tag_match::Value_match::DoubleValueMatch(ref v) => {
                            let len = v.compute_size();
                            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                        },
                    };
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.tag_key.is_empty() {
                    os.write_string(1, &self.tag_key)?;
                }
                if let ::std::option::Option::Some(ref v) = self.value_match {
                    match v {
                        &tag_match::Value_match::StringValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                        },
                        &tag_match::Value_match::IntValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                        },
                        &tag_match::Value_match::SemVerValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                        },
                        &tag_match::Value_match::IsSetMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                        },
                        &tag_match::Value_match::DoubleValueMatch(ref v) => {
                            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                        },
                    };
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TagMatch {
                TagMatch::new()
            }

            fn clear(&mut self) {
                self.tag_key.clear();
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.value_match = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TagMatch {
                static instance: TagMatch = TagMatch {
                    tag_key: ::std::string::String::new(),
                    value_match: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TagMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.TagMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TagMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TagMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `TagMatch`
        pub mod tag_match {

            #[derive(Clone,PartialEq,Debug)]
            // @@protoc_insertion_point(oneof:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.value_match)
            pub enum Value_match {
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.string_value_match)
                StringValueMatch(super::super::super::super::value_matcher::StringValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.int_value_match)
                IntValueMatch(super::super::super::super::value_matcher::IntValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.sem_ver_value_match)
                SemVerValueMatch(super::super::super::super::value_matcher::SemVerValueMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.is_set_match)
                IsSetMatch(super::super::super::super::value_matcher::IsSetMatch),
                // @@protoc_insertion_point(oneof_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatch.double_value_match)
                DoubleValueMatch(super::super::super::super::value_matcher::DoubleValueMatch),
            }

            impl ::protobuf::Oneof for Value_match {
            }

            impl ::protobuf::OneofFull for Value_match {
                fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| <super::TagMatch as ::protobuf::MessageFull>::descriptor().oneof_by_name("value_match").unwrap()).clone()
                }
            }

            impl Value_match {
                pub(in super::super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                    ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Value_match>("value_match")
                }
            }
        }

        // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StateMatch {
            // message fields
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch.scope)
            pub scope: ::protobuf::EnumOrUnknown<super::super::super::scope::StateScope>,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch.state_key)
            pub state_key: ::std::string::String,
            // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch.state_value_match)
            pub state_value_match: ::protobuf::MessageField<super::super::super::matcher::StateValueMatch>,
            // special fields
            // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StateMatch {
            fn default() -> &'a StateMatch {
                <StateMatch as ::protobuf::Message>::default_instance()
            }
        }

        impl StateMatch {
            pub fn new() -> StateMatch {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "scope",
                    |m: &StateMatch| { &m.scope },
                    |m: &mut StateMatch| { &mut m.scope },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "state_key",
                    |m: &StateMatch| { &m.state_key },
                    |m: &mut StateMatch| { &mut m.state_key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::matcher::StateValueMatch>(
                    "state_value_match",
                    |m: &StateMatch| { &m.state_value_match },
                    |m: &mut StateMatch| { &mut m.state_value_match },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateMatch>(
                    "LogMatcher.BaseLogMatcher.StateMatch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for StateMatch {
            const NAME: &'static str = "StateMatch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.scope = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.state_key = is.read_string()?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.state_value_match)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.scope != ::protobuf::EnumOrUnknown::new(super::super::super::scope::StateScope::UNSPECIFIED) {
                    my_size += ::protobuf::rt::int32_size(1, self.scope.value());
                }
                if !self.state_key.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.state_key);
                }
                if let Some(v) = self.state_value_match.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.scope != ::protobuf::EnumOrUnknown::new(super::super::super::scope::StateScope::UNSPECIFIED) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.scope))?;
                }
                if !self.state_key.is_empty() {
                    os.write_string(2, &self.state_key)?;
                }
                if let Some(v) = self.state_value_match.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StateMatch {
                StateMatch::new()
            }

            fn clear(&mut self) {
                self.scope = ::protobuf::EnumOrUnknown::new(super::super::super::scope::StateScope::UNSPECIFIED);
                self.state_key.clear();
                self.state_value_match.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StateMatch {
                static instance: StateMatch = StateMatch {
                    scope: ::protobuf::EnumOrUnknown::from_i32(0),
                    state_key: ::std::string::String::new(),
                    state_value_match: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for StateMatch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LogMatcher.BaseLogMatcher.StateMatch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StateMatch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for StateMatch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatcherList {
        // message fields
        // @@protoc_insertion_point(field:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList.log_matchers)
        pub log_matchers: ::std::vec::Vec<super::LogMatcher>,
        // special fields
        // @@protoc_insertion_point(special_field:bitdrift_public.protobuf.matcher.v1.LogMatcher.MatcherList.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatcherList {
        fn default() -> &'a MatcherList {
            <MatcherList as ::protobuf::Message>::default_instance()
        }
    }

    impl MatcherList {
        pub fn new() -> MatcherList {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "log_matchers",
                |m: &MatcherList| { &m.log_matchers },
                |m: &mut MatcherList| { &mut m.log_matchers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatcherList>(
                "LogMatcher.MatcherList",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MatcherList {
        const NAME: &'static str = "MatcherList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.log_matchers.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.log_matchers {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.log_matchers {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatcherList {
            MatcherList::new()
        }

        fn clear(&mut self) {
            self.log_matchers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatcherList {
            static instance: MatcherList = MatcherList {
                log_matchers: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MatcherList {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LogMatcher.MatcherList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MatcherList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MatcherList {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n5bitdrift_public/protobuf/matcher/v1/log_matcher.proto\x12#bitdrift_pu\
    blic.protobuf.matcher.v1\x1a/bitdrift_public/protobuf/state/v1/matcher.p\
    roto\x1a-bitdrift_public/protobuf/state/v1/scope.proto\x1a=bitdrift_publ\
    ic/protobuf/value_matcher/v1/value_matcher.proto\x1a\x17validate/validat\
    e.proto\"\xab\x0e\n\nLogMatcher\x12c\n\x0cbase_matcher\x18\x01\x20\x01(\
    \x0b2>.bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcherH\0R\
    \x0bbaseMatcher\x12\\\n\nor_matcher\x18\x02\x20\x01(\x0b2;.bitdrift_publ\
    ic.protobuf.matcher.v1.LogMatcher.MatcherListH\0R\torMatcher\x12^\n\x0ba\
    nd_matcher\x18\x03\x20\x01(\x0b2;.bitdrift_public.protobuf.matcher.v1.Lo\
    gMatcher.MatcherListH\0R\nandMatcher\x12R\n\x0bnot_matcher\x18\x04\x20\
    \x01(\x0b2/.bitdrift_public.protobuf.matcher.v1.LogMatcherH\0R\nnotMatch\
    er\x1a\xa8\n\n\x0eBaseLogMatcher\x12r\n\rmessage_match\x18\x01\x20\x01(\
    \x0b2K.bitdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.Mes\
    sageMatchH\0R\x0cmessageMatch\x12f\n\ttag_match\x18\x02\x20\x01(\x0b2G.b\
    itdrift_public.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.TagMatchH\0\
    R\x08tagMatch\x12l\n\x0bstate_match\x18\x04\x20\x01(\x0b2I.bitdrift_publ\
    ic.protobuf.matcher.v1.LogMatcher.BaseLogMatcher.StateMatchH\0R\nstateMa\
    tch\x1ay\n\x0cMessageMatch\x12i\n\x12string_value_match\x18\x01\x20\x01(\
    \x0b2;.bitdrift_public.protobuf.value_matcher.v1.StringValueMatchR\x10st\
    ringValueMatch\x1a\xc9\x04\n\x08TagMatch\x12\"\n\x07tag_key\x18\x01\x20\
    \x01(\tR\x06tagKeyB\t\xfaB\x06r\x04\x10\x01\x18@\x12k\n\x12string_value_\
    match\x18\x02\x20\x01(\x0b2;.bitdrift_public.protobuf.value_matcher.v1.S\
    tringValueMatchH\0R\x10stringValueMatch\x12b\n\x0fint_value_match\x18\
    \x03\x20\x01(\x0b28.bitdrift_public.protobuf.value_matcher.v1.IntValueMa\
    tchH\0R\rintValueMatch\x12l\n\x13sem_ver_value_match\x18\x04\x20\x01(\
    \x0b2;.bitdrift_public.protobuf.value_matcher.v1.SemVerValueMatchH\0R\
    \x10semVerValueMatch\x12Y\n\x0cis_set_match\x18\x05\x20\x01(\x0b25.bitdr\
    ift_public.protobuf.value_matcher.v1.IsSetMatchH\0R\nisSetMatch\x12k\n\
    \x12double_value_match\x18\x06\x20\x01(\x0b2;.bitdrift_public.protobuf.v\
    alue_matcher.v1.DoubleValueMatchH\0R\x10doubleValueMatchB\x12\n\x0bvalue\
    _match\x12\x03\xf8B\x01\x1a\xeb\x01\n\nStateMatch\x12M\n\x05scope\x18\
    \x01\x20\x01(\x0e2-.bitdrift_public.protobuf.state.v1.StateScopeR\x05sco\
    peB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12$\n\tstate_key\x18\x02\x20\x01(\
    \tR\x08stateKeyB\x07\xfaB\x04r\x02\x10\x01\x12h\n\x11state_value_match\
    \x18\x03\x20\x01(\x0b22.bitdrift_public.protobuf.state.v1.StateValueMatc\
    hR\x0fstateValueMatchB\x08\xfaB\x05\x8a\x01\x02\x10\x01B\x11\n\nmatch_ty\
    pe\x12\x03\xf8B\x01J\x04\x08\x03\x10\x04\x1ak\n\x0bMatcherList\x12\\\n\
    \x0clog_matchers\x18\x01\x20\x03(\x0b2/.bitdrift_public.protobuf.matcher\
    .v1.LogMatcherR\x0blogMatchersB\x08\xfaB\x05\x92\x01\x02\x08\x02B\x0e\n\
    \x07matcher\x12\x03\xf8B\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(4);
            deps.push(super::matcher::file_descriptor().clone());
            deps.push(super::scope::file_descriptor().clone());
            deps.push(super::value_matcher::file_descriptor().clone());
            deps.push(super::validate::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(LogMatcher::generated_message_descriptor_data());
            messages.push(log_matcher::BaseLogMatcher::generated_message_descriptor_data());
            messages.push(log_matcher::MatcherList::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::MessageMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::TagMatch::generated_message_descriptor_data());
            messages.push(log_matcher::base_log_matcher::StateMatch::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
