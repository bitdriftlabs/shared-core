// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REPORT_BITDRIFT_PUBLIC_FBS_ISSUE_REPORTING_V1_H_
#define FLATBUFFERS_GENERATED_REPORT_BITDRIFT_PUBLIC_FBS_ISSUE_REPORTING_V1_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace bitdrift_public {
namespace fbs {
namespace issue_reporting {
namespace v1 {

struct Timestamp;

struct Memory;

struct AppBuildNumber;
struct AppBuildNumberBuilder;

struct AppMetrics;
struct AppMetricsBuilder;

struct OSBuild;
struct OSBuildBuilder;

struct PowerMetrics;
struct PowerMetricsBuilder;

struct Display;
struct DisplayBuilder;

struct DeviceMetrics;
struct DeviceMetricsBuilder;

struct SourceFile;
struct SourceFileBuilder;

struct CPURegister;
struct CPURegisterBuilder;

struct Frame;
struct FrameBuilder;

struct Thread;
struct ThreadBuilder;

struct ThreadDetails;
struct ThreadDetailsBuilder;

struct Error;
struct ErrorBuilder;

struct BinaryImage;
struct BinaryImageBuilder;

struct SDKInfo;
struct SDKInfoBuilder;

struct Report;
struct ReportBuilder;

inline const ::flatbuffers::TypeTable *TimestampTypeTable();

inline const ::flatbuffers::TypeTable *MemoryTypeTable();

inline const ::flatbuffers::TypeTable *AppBuildNumberTypeTable();

inline const ::flatbuffers::TypeTable *AppMetricsTypeTable();

inline const ::flatbuffers::TypeTable *OSBuildTypeTable();

inline const ::flatbuffers::TypeTable *PowerMetricsTypeTable();

inline const ::flatbuffers::TypeTable *DisplayTypeTable();

inline const ::flatbuffers::TypeTable *DeviceMetricsTypeTable();

inline const ::flatbuffers::TypeTable *SourceFileTypeTable();

inline const ::flatbuffers::TypeTable *CPURegisterTypeTable();

inline const ::flatbuffers::TypeTable *FrameTypeTable();

inline const ::flatbuffers::TypeTable *ThreadTypeTable();

inline const ::flatbuffers::TypeTable *ThreadDetailsTypeTable();

inline const ::flatbuffers::TypeTable *ErrorTypeTable();

inline const ::flatbuffers::TypeTable *BinaryImageTypeTable();

inline const ::flatbuffers::TypeTable *SDKInfoTypeTable();

inline const ::flatbuffers::TypeTable *ReportTypeTable();

enum ReportType : int8_t {
  ReportType_Unknown = 0,
  ReportType_AppNotResponding = 1,
  ReportType_HandledError = 2,
  ReportType_JVMCrash = 3,
  ReportType_MemoryTermination = 4,
  ReportType_NativeCrash = 5,
  ReportType_StrictModeViolation = 6,
  ReportType_MIN = ReportType_Unknown,
  ReportType_MAX = ReportType_StrictModeViolation
};

inline const ReportType (&EnumValuesReportType())[7] {
  static const ReportType values[] = {
    ReportType_Unknown,
    ReportType_AppNotResponding,
    ReportType_HandledError,
    ReportType_JVMCrash,
    ReportType_MemoryTermination,
    ReportType_NativeCrash,
    ReportType_StrictModeViolation
  };
  return values;
}

inline const char * const *EnumNamesReportType() {
  static const char * const names[8] = {
    "Unknown",
    "AppNotResponding",
    "HandledError",
    "JVMCrash",
    "MemoryTermination",
    "NativeCrash",
    "StrictModeViolation",
    nullptr
  };
  return names;
}

inline const char *EnumNameReportType(ReportType e) {
  if (::flatbuffers::IsOutRange(e, ReportType_Unknown, ReportType_StrictModeViolation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReportType()[index];
}

enum Platform : int8_t {
  Platform_Unknown = 0,
  Platform_Android = 1,
  Platform_iOS = 2,
  Platform_macOS = 3,
  Platform_MIN = Platform_Unknown,
  Platform_MAX = Platform_macOS
};

inline const Platform (&EnumValuesPlatform())[4] {
  static const Platform values[] = {
    Platform_Unknown,
    Platform_Android,
    Platform_iOS,
    Platform_macOS
  };
  return values;
}

inline const char * const *EnumNamesPlatform() {
  static const char * const names[5] = {
    "Unknown",
    "Android",
    "iOS",
    "macOS",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlatform(Platform e) {
  if (::flatbuffers::IsOutRange(e, Platform_Unknown, Platform_macOS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlatform()[index];
}

enum Architecture : int8_t {
  Architecture_Unknown = 0,
  Architecture_arm32 = 1,
  Architecture_arm64 = 2,
  Architecture_x86 = 3,
  Architecture_x86_64 = 4,
  Architecture_MIN = Architecture_Unknown,
  Architecture_MAX = Architecture_x86_64
};

inline const Architecture (&EnumValuesArchitecture())[5] {
  static const Architecture values[] = {
    Architecture_Unknown,
    Architecture_arm32,
    Architecture_arm64,
    Architecture_x86,
    Architecture_x86_64
  };
  return values;
}

inline const char * const *EnumNamesArchitecture() {
  static const char * const names[6] = {
    "Unknown",
    "arm32",
    "arm64",
    "x86",
    "x86_64",
    nullptr
  };
  return names;
}

inline const char *EnumNameArchitecture(Architecture e) {
  if (::flatbuffers::IsOutRange(e, Architecture_Unknown, Architecture_x86_64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArchitecture()[index];
}

enum FrameType : int8_t {
  FrameType_Unknown = 0,
  FrameType_JVM = 1,
  FrameType_DWARF = 2,
  FrameType_AndroidNative = 3,
  FrameType_MIN = FrameType_Unknown,
  FrameType_MAX = FrameType_AndroidNative
};

inline const FrameType (&EnumValuesFrameType())[4] {
  static const FrameType values[] = {
    FrameType_Unknown,
    FrameType_JVM,
    FrameType_DWARF,
    FrameType_AndroidNative
  };
  return values;
}

inline const char * const *EnumNamesFrameType() {
  static const char * const names[5] = {
    "Unknown",
    "JVM",
    "DWARF",
    "AndroidNative",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrameType(FrameType e) {
  if (::flatbuffers::IsOutRange(e, FrameType_Unknown, FrameType_AndroidNative)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrameType()[index];
}

enum ErrorRelation : int8_t {
  ErrorRelation_CausedBy = 1,
  ErrorRelation_MIN = ErrorRelation_CausedBy,
  ErrorRelation_MAX = ErrorRelation_CausedBy
};

inline const ErrorRelation (&EnumValuesErrorRelation())[1] {
  static const ErrorRelation values[] = {
    ErrorRelation_CausedBy
  };
  return values;
}

inline const char * const *EnumNamesErrorRelation() {
  static const char * const names[2] = {
    "CausedBy",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorRelation(ErrorRelation e) {
  if (::flatbuffers::IsOutRange(e, ErrorRelation_CausedBy, ErrorRelation_CausedBy)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ErrorRelation_CausedBy);
  return EnumNamesErrorRelation()[index];
}

enum PowerState : int8_t {
  PowerState_Unknown = 0,
  PowerState_RunningOnBattery = 1,
  PowerState_PluggedInNoBattery = 2,
  PowerState_PluggedInCharging = 3,
  PowerState_PluggedInCharged = 4,
  PowerState_MIN = PowerState_Unknown,
  PowerState_MAX = PowerState_PluggedInCharged
};

inline const PowerState (&EnumValuesPowerState())[5] {
  static const PowerState values[] = {
    PowerState_Unknown,
    PowerState_RunningOnBattery,
    PowerState_PluggedInNoBattery,
    PowerState_PluggedInCharging,
    PowerState_PluggedInCharged
  };
  return values;
}

inline const char * const *EnumNamesPowerState() {
  static const char * const names[6] = {
    "Unknown",
    "RunningOnBattery",
    "PluggedInNoBattery",
    "PluggedInCharging",
    "PluggedInCharged",
    nullptr
  };
  return names;
}

inline const char *EnumNamePowerState(PowerState e) {
  if (::flatbuffers::IsOutRange(e, PowerState_Unknown, PowerState_PluggedInCharged)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPowerState()[index];
}

enum NetworkState : int8_t {
  NetworkState_Unknown = 0,
  NetworkState_Disconnected = 1,
  NetworkState_Cellular = 2,
  NetworkState_WiFi = 3,
  NetworkState_MIN = NetworkState_Unknown,
  NetworkState_MAX = NetworkState_WiFi
};

inline const NetworkState (&EnumValuesNetworkState())[4] {
  static const NetworkState values[] = {
    NetworkState_Unknown,
    NetworkState_Disconnected,
    NetworkState_Cellular,
    NetworkState_WiFi
  };
  return values;
}

inline const char * const *EnumNamesNetworkState() {
  static const char * const names[5] = {
    "Unknown",
    "Disconnected",
    "Cellular",
    "WiFi",
    nullptr
  };
  return names;
}

inline const char *EnumNameNetworkState(NetworkState e) {
  if (::flatbuffers::IsOutRange(e, NetworkState_Unknown, NetworkState_WiFi)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNetworkState()[index];
}

enum Rotation : int8_t {
  Rotation_Unknown = 0,
  Rotation_Portrait = 1,
  Rotation_LandscapeRight = 2,
  Rotation_LandscapeLeft = 3,
  Rotation_PortraitUpsideDown = 4,
  Rotation_MIN = Rotation_Unknown,
  Rotation_MAX = Rotation_PortraitUpsideDown
};

inline const Rotation (&EnumValuesRotation())[5] {
  static const Rotation values[] = {
    Rotation_Unknown,
    Rotation_Portrait,
    Rotation_LandscapeRight,
    Rotation_LandscapeLeft,
    Rotation_PortraitUpsideDown
  };
  return values;
}

inline const char * const *EnumNamesRotation() {
  static const char * const names[6] = {
    "Unknown",
    "Portrait",
    "LandscapeRight",
    "LandscapeLeft",
    "PortraitUpsideDown",
    nullptr
  };
  return names;
}

inline const char *EnumNameRotation(Rotation e) {
  if (::flatbuffers::IsOutRange(e, Rotation_Unknown, Rotation_PortraitUpsideDown)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRotation()[index];
}

enum FrameStatus : int8_t {
  FrameStatus_Missing = 0,
  FrameStatus_Symbolicated = 1,
  FrameStatus_MissingSymbol = 2,
  FrameStatus_UnknownImage = 3,
  FrameStatus_Malformed = 4,
  FrameStatus_MIN = FrameStatus_Missing,
  FrameStatus_MAX = FrameStatus_Malformed
};

inline const FrameStatus (&EnumValuesFrameStatus())[5] {
  static const FrameStatus values[] = {
    FrameStatus_Missing,
    FrameStatus_Symbolicated,
    FrameStatus_MissingSymbol,
    FrameStatus_UnknownImage,
    FrameStatus_Malformed
  };
  return values;
}

inline const char * const *EnumNamesFrameStatus() {
  static const char * const names[6] = {
    "Missing",
    "Symbolicated",
    "MissingSymbol",
    "UnknownImage",
    "Malformed",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrameStatus(FrameStatus e) {
  if (::flatbuffers::IsOutRange(e, FrameStatus_Missing, FrameStatus_Malformed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFrameStatus()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Timestamp FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t seconds_;
  uint32_t nanos_;
  int32_t padding0__;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TimestampTypeTable();
  }
  Timestamp()
      : seconds_(0),
        nanos_(0),
        padding0__(0) {
    (void)padding0__;
  }
  Timestamp(uint64_t _seconds, uint32_t _nanos)
      : seconds_(::flatbuffers::EndianScalar(_seconds)),
        nanos_(::flatbuffers::EndianScalar(_nanos)),
        padding0__(0) {
    (void)padding0__;
  }
  uint64_t seconds() const {
    return ::flatbuffers::EndianScalar(seconds_);
  }
  uint32_t nanos() const {
    return ::flatbuffers::EndianScalar(nanos_);
  }
};
FLATBUFFERS_STRUCT_END(Timestamp, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Memory FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t total_;
  uint64_t free_;
  uint64_t used_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MemoryTypeTable();
  }
  Memory()
      : total_(0),
        free_(0),
        used_(0) {
  }
  Memory(uint64_t _total, uint64_t _free, uint64_t _used)
      : total_(::flatbuffers::EndianScalar(_total)),
        free_(::flatbuffers::EndianScalar(_free)),
        used_(::flatbuffers::EndianScalar(_used)) {
  }
  uint64_t total() const {
    return ::flatbuffers::EndianScalar(total_);
  }
  uint64_t free() const {
    return ::flatbuffers::EndianScalar(free_);
  }
  uint64_t used() const {
    return ::flatbuffers::EndianScalar(used_);
  }
};
FLATBUFFERS_STRUCT_END(Memory, 24);

struct AppBuildNumber FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AppBuildNumberBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AppBuildNumberTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION_CODE = 4,
    VT_CF_BUNDLE_VERSION = 6
  };
  int64_t version_code() const {
    return GetField<int64_t>(VT_VERSION_CODE, 0);
  }
  const ::flatbuffers::String *cf_bundle_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CF_BUNDLE_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VERSION_CODE, 8) &&
           VerifyOffset(verifier, VT_CF_BUNDLE_VERSION) &&
           verifier.VerifyString(cf_bundle_version()) &&
           verifier.EndTable();
  }
};

struct AppBuildNumberBuilder {
  typedef AppBuildNumber Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version_code(int64_t version_code) {
    fbb_.AddElement<int64_t>(AppBuildNumber::VT_VERSION_CODE, version_code, 0);
  }
  void add_cf_bundle_version(::flatbuffers::Offset<::flatbuffers::String> cf_bundle_version) {
    fbb_.AddOffset(AppBuildNumber::VT_CF_BUNDLE_VERSION, cf_bundle_version);
  }
  explicit AppBuildNumberBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AppBuildNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AppBuildNumber>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AppBuildNumber> CreateAppBuildNumber(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t version_code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cf_bundle_version = 0) {
  AppBuildNumberBuilder builder_(_fbb);
  builder_.add_version_code(version_code);
  builder_.add_cf_bundle_version(cf_bundle_version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AppBuildNumber> CreateAppBuildNumberDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t version_code = 0,
    const char *cf_bundle_version = nullptr) {
  auto cf_bundle_version__ = cf_bundle_version ? _fbb.CreateString(cf_bundle_version) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateAppBuildNumber(
      _fbb,
      version_code,
      cf_bundle_version__);
}

struct AppMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AppMetricsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return AppMetricsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APP_ID = 4,
    VT_MEMORY = 6,
    VT_VERSION = 8,
    VT_BUILD_NUMBER = 10,
    VT_RUNNING_STATE = 12
  };
  const ::flatbuffers::String *app_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APP_ID);
  }
  const bitdrift_public::fbs::issue_reporting::v1::Memory *memory() const {
    return GetStruct<const bitdrift_public::fbs::issue_reporting::v1::Memory *>(VT_MEMORY);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const bitdrift_public::fbs::issue_reporting::v1::AppBuildNumber *build_number() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::AppBuildNumber *>(VT_BUILD_NUMBER);
  }
  const ::flatbuffers::String *running_state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RUNNING_STATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APP_ID) &&
           verifier.VerifyString(app_id()) &&
           VerifyField<bitdrift_public::fbs::issue_reporting::v1::Memory>(verifier, VT_MEMORY, 8) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_BUILD_NUMBER) &&
           verifier.VerifyTable(build_number()) &&
           VerifyOffset(verifier, VT_RUNNING_STATE) &&
           verifier.VerifyString(running_state()) &&
           verifier.EndTable();
  }
};

struct AppMetricsBuilder {
  typedef AppMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_app_id(::flatbuffers::Offset<::flatbuffers::String> app_id) {
    fbb_.AddOffset(AppMetrics::VT_APP_ID, app_id);
  }
  void add_memory(const bitdrift_public::fbs::issue_reporting::v1::Memory *memory) {
    fbb_.AddStruct(AppMetrics::VT_MEMORY, memory);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(AppMetrics::VT_VERSION, version);
  }
  void add_build_number(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppBuildNumber> build_number) {
    fbb_.AddOffset(AppMetrics::VT_BUILD_NUMBER, build_number);
  }
  void add_running_state(::flatbuffers::Offset<::flatbuffers::String> running_state) {
    fbb_.AddOffset(AppMetrics::VT_RUNNING_STATE, running_state);
  }
  explicit AppMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AppMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AppMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AppMetrics> CreateAppMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> app_id = 0,
    const bitdrift_public::fbs::issue_reporting::v1::Memory *memory = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppBuildNumber> build_number = 0,
    ::flatbuffers::Offset<::flatbuffers::String> running_state = 0) {
  AppMetricsBuilder builder_(_fbb);
  builder_.add_running_state(running_state);
  builder_.add_build_number(build_number);
  builder_.add_version(version);
  builder_.add_memory(memory);
  builder_.add_app_id(app_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AppMetrics> CreateAppMetricsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *app_id = nullptr,
    const bitdrift_public::fbs::issue_reporting::v1::Memory *memory = nullptr,
    const char *version = nullptr,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppBuildNumber> build_number = 0,
    const char *running_state = nullptr) {
  auto app_id__ = app_id ? _fbb.CreateString(app_id) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto running_state__ = running_state ? _fbb.CreateString(running_state) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateAppMetrics(
      _fbb,
      app_id__,
      memory,
      version__,
      build_number,
      running_state__);
}

struct OSBuild FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OSBuildBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OSBuildTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_BRAND = 6,
    VT_FINGERPRINT = 8,
    VT_KERN_OSVERSION = 10
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::String *brand() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BRAND);
  }
  const ::flatbuffers::String *fingerprint() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FINGERPRINT);
  }
  const ::flatbuffers::String *kern_osversion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KERN_OSVERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_BRAND) &&
           verifier.VerifyString(brand()) &&
           VerifyOffset(verifier, VT_FINGERPRINT) &&
           verifier.VerifyString(fingerprint()) &&
           VerifyOffset(verifier, VT_KERN_OSVERSION) &&
           verifier.VerifyString(kern_osversion()) &&
           verifier.EndTable();
  }
};

struct OSBuildBuilder {
  typedef OSBuild Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(OSBuild::VT_VERSION, version);
  }
  void add_brand(::flatbuffers::Offset<::flatbuffers::String> brand) {
    fbb_.AddOffset(OSBuild::VT_BRAND, brand);
  }
  void add_fingerprint(::flatbuffers::Offset<::flatbuffers::String> fingerprint) {
    fbb_.AddOffset(OSBuild::VT_FINGERPRINT, fingerprint);
  }
  void add_kern_osversion(::flatbuffers::Offset<::flatbuffers::String> kern_osversion) {
    fbb_.AddOffset(OSBuild::VT_KERN_OSVERSION, kern_osversion);
  }
  explicit OSBuildBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OSBuild> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OSBuild>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OSBuild> CreateOSBuild(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> brand = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fingerprint = 0,
    ::flatbuffers::Offset<::flatbuffers::String> kern_osversion = 0) {
  OSBuildBuilder builder_(_fbb);
  builder_.add_kern_osversion(kern_osversion);
  builder_.add_fingerprint(fingerprint);
  builder_.add_brand(brand);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OSBuild> CreateOSBuildDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const char *brand = nullptr,
    const char *fingerprint = nullptr,
    const char *kern_osversion = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto brand__ = brand ? _fbb.CreateString(brand) : 0;
  auto fingerprint__ = fingerprint ? _fbb.CreateString(fingerprint) : 0;
  auto kern_osversion__ = kern_osversion ? _fbb.CreateString(kern_osversion) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateOSBuild(
      _fbb,
      version__,
      brand__,
      fingerprint__,
      kern_osversion__);
}

struct PowerMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PowerMetricsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PowerMetricsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER_STATE = 4,
    VT_CHARGE_PERCENT = 6
  };
  bitdrift_public::fbs::issue_reporting::v1::PowerState power_state() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::PowerState>(GetField<int8_t>(VT_POWER_STATE, 0));
  }
  uint8_t charge_percent() const {
    return GetField<uint8_t>(VT_CHARGE_PERCENT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_POWER_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHARGE_PERCENT, 1) &&
           verifier.EndTable();
  }
};

struct PowerMetricsBuilder {
  typedef PowerMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_power_state(bitdrift_public::fbs::issue_reporting::v1::PowerState power_state) {
    fbb_.AddElement<int8_t>(PowerMetrics::VT_POWER_STATE, static_cast<int8_t>(power_state), 0);
  }
  void add_charge_percent(uint8_t charge_percent) {
    fbb_.AddElement<uint8_t>(PowerMetrics::VT_CHARGE_PERCENT, charge_percent, 0);
  }
  explicit PowerMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PowerMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PowerMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PowerMetrics> CreatePowerMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bitdrift_public::fbs::issue_reporting::v1::PowerState power_state = bitdrift_public::fbs::issue_reporting::v1::PowerState_Unknown,
    uint8_t charge_percent = 0) {
  PowerMetricsBuilder builder_(_fbb);
  builder_.add_charge_percent(charge_percent);
  builder_.add_power_state(power_state);
  return builder_.Finish();
}

struct Display FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DisplayBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DisplayTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_DENSITY_DPI = 8
  };
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t density_dpi() const {
    return GetField<uint32_t>(VT_DENSITY_DPI, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_DENSITY_DPI, 4) &&
           verifier.EndTable();
  }
};

struct DisplayBuilder {
  typedef Display Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Display::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Display::VT_WIDTH, width, 0);
  }
  void add_density_dpi(uint32_t density_dpi) {
    fbb_.AddElement<uint32_t>(Display::VT_DENSITY_DPI, density_dpi, 0);
  }
  explicit DisplayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Display> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Display>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Display> CreateDisplay(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t height = 0,
    uint32_t width = 0,
    uint32_t density_dpi = 0) {
  DisplayBuilder builder_(_fbb);
  builder_.add_density_dpi(density_dpi);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

struct DeviceMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeviceMetricsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeviceMetricsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_TIMEZONE = 6,
    VT_POWER_METRICS = 8,
    VT_NETWORK_STATE = 10,
    VT_ROTATION = 12,
    VT_ARCH = 14,
    VT_DISPLAY = 16,
    VT_MANUFACTURER = 18,
    VT_MODEL = 20,
    VT_OS_BUILD = 22,
    VT_PLATFORM = 24,
    VT_CPU_ABIS = 26
  };
  const bitdrift_public::fbs::issue_reporting::v1::Timestamp *time() const {
    return GetStruct<const bitdrift_public::fbs::issue_reporting::v1::Timestamp *>(VT_TIME);
  }
  const ::flatbuffers::String *timezone() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMEZONE);
  }
  const bitdrift_public::fbs::issue_reporting::v1::PowerMetrics *power_metrics() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::PowerMetrics *>(VT_POWER_METRICS);
  }
  bitdrift_public::fbs::issue_reporting::v1::NetworkState network_state() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::NetworkState>(GetField<int8_t>(VT_NETWORK_STATE, 0));
  }
  bitdrift_public::fbs::issue_reporting::v1::Rotation rotation() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::Rotation>(GetField<int8_t>(VT_ROTATION, 0));
  }
  bitdrift_public::fbs::issue_reporting::v1::Architecture arch() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::Architecture>(GetField<int8_t>(VT_ARCH, 0));
  }
  const bitdrift_public::fbs::issue_reporting::v1::Display *display() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::Display *>(VT_DISPLAY);
  }
  const ::flatbuffers::String *manufacturer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANUFACTURER);
  }
  const ::flatbuffers::String *model() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODEL);
  }
  const bitdrift_public::fbs::issue_reporting::v1::OSBuild *os_build() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::OSBuild *>(VT_OS_BUILD);
  }
  bitdrift_public::fbs::issue_reporting::v1::Platform platform() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::Platform>(GetField<int8_t>(VT_PLATFORM, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cpu_abis() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CPU_ABIS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<bitdrift_public::fbs::issue_reporting::v1::Timestamp>(verifier, VT_TIME, 8) &&
           VerifyOffset(verifier, VT_TIMEZONE) &&
           verifier.VerifyString(timezone()) &&
           VerifyOffset(verifier, VT_POWER_METRICS) &&
           verifier.VerifyTable(power_metrics()) &&
           VerifyField<int8_t>(verifier, VT_NETWORK_STATE, 1) &&
           VerifyField<int8_t>(verifier, VT_ROTATION, 1) &&
           VerifyField<int8_t>(verifier, VT_ARCH, 1) &&
           VerifyOffset(verifier, VT_DISPLAY) &&
           verifier.VerifyTable(display()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(manufacturer()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyString(model()) &&
           VerifyOffset(verifier, VT_OS_BUILD) &&
           verifier.VerifyTable(os_build()) &&
           VerifyField<int8_t>(verifier, VT_PLATFORM, 1) &&
           VerifyOffset(verifier, VT_CPU_ABIS) &&
           verifier.VerifyVector(cpu_abis()) &&
           verifier.VerifyVectorOfStrings(cpu_abis()) &&
           verifier.EndTable();
  }
};

struct DeviceMetricsBuilder {
  typedef DeviceMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(const bitdrift_public::fbs::issue_reporting::v1::Timestamp *time) {
    fbb_.AddStruct(DeviceMetrics::VT_TIME, time);
  }
  void add_timezone(::flatbuffers::Offset<::flatbuffers::String> timezone) {
    fbb_.AddOffset(DeviceMetrics::VT_TIMEZONE, timezone);
  }
  void add_power_metrics(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::PowerMetrics> power_metrics) {
    fbb_.AddOffset(DeviceMetrics::VT_POWER_METRICS, power_metrics);
  }
  void add_network_state(bitdrift_public::fbs::issue_reporting::v1::NetworkState network_state) {
    fbb_.AddElement<int8_t>(DeviceMetrics::VT_NETWORK_STATE, static_cast<int8_t>(network_state), 0);
  }
  void add_rotation(bitdrift_public::fbs::issue_reporting::v1::Rotation rotation) {
    fbb_.AddElement<int8_t>(DeviceMetrics::VT_ROTATION, static_cast<int8_t>(rotation), 0);
  }
  void add_arch(bitdrift_public::fbs::issue_reporting::v1::Architecture arch) {
    fbb_.AddElement<int8_t>(DeviceMetrics::VT_ARCH, static_cast<int8_t>(arch), 0);
  }
  void add_display(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Display> display) {
    fbb_.AddOffset(DeviceMetrics::VT_DISPLAY, display);
  }
  void add_manufacturer(::flatbuffers::Offset<::flatbuffers::String> manufacturer) {
    fbb_.AddOffset(DeviceMetrics::VT_MANUFACTURER, manufacturer);
  }
  void add_model(::flatbuffers::Offset<::flatbuffers::String> model) {
    fbb_.AddOffset(DeviceMetrics::VT_MODEL, model);
  }
  void add_os_build(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::OSBuild> os_build) {
    fbb_.AddOffset(DeviceMetrics::VT_OS_BUILD, os_build);
  }
  void add_platform(bitdrift_public::fbs::issue_reporting::v1::Platform platform) {
    fbb_.AddElement<int8_t>(DeviceMetrics::VT_PLATFORM, static_cast<int8_t>(platform), 0);
  }
  void add_cpu_abis(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cpu_abis) {
    fbb_.AddOffset(DeviceMetrics::VT_CPU_ABIS, cpu_abis);
  }
  explicit DeviceMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceMetrics> CreateDeviceMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const bitdrift_public::fbs::issue_reporting::v1::Timestamp *time = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> timezone = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::PowerMetrics> power_metrics = 0,
    bitdrift_public::fbs::issue_reporting::v1::NetworkState network_state = bitdrift_public::fbs::issue_reporting::v1::NetworkState_Unknown,
    bitdrift_public::fbs::issue_reporting::v1::Rotation rotation = bitdrift_public::fbs::issue_reporting::v1::Rotation_Unknown,
    bitdrift_public::fbs::issue_reporting::v1::Architecture arch = bitdrift_public::fbs::issue_reporting::v1::Architecture_Unknown,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Display> display = 0,
    ::flatbuffers::Offset<::flatbuffers::String> manufacturer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> model = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::OSBuild> os_build = 0,
    bitdrift_public::fbs::issue_reporting::v1::Platform platform = bitdrift_public::fbs::issue_reporting::v1::Platform_Unknown,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cpu_abis = 0) {
  DeviceMetricsBuilder builder_(_fbb);
  builder_.add_cpu_abis(cpu_abis);
  builder_.add_os_build(os_build);
  builder_.add_model(model);
  builder_.add_manufacturer(manufacturer);
  builder_.add_display(display);
  builder_.add_power_metrics(power_metrics);
  builder_.add_timezone(timezone);
  builder_.add_time(time);
  builder_.add_platform(platform);
  builder_.add_arch(arch);
  builder_.add_rotation(rotation);
  builder_.add_network_state(network_state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DeviceMetrics> CreateDeviceMetricsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const bitdrift_public::fbs::issue_reporting::v1::Timestamp *time = nullptr,
    const char *timezone = nullptr,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::PowerMetrics> power_metrics = 0,
    bitdrift_public::fbs::issue_reporting::v1::NetworkState network_state = bitdrift_public::fbs::issue_reporting::v1::NetworkState_Unknown,
    bitdrift_public::fbs::issue_reporting::v1::Rotation rotation = bitdrift_public::fbs::issue_reporting::v1::Rotation_Unknown,
    bitdrift_public::fbs::issue_reporting::v1::Architecture arch = bitdrift_public::fbs::issue_reporting::v1::Architecture_Unknown,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Display> display = 0,
    const char *manufacturer = nullptr,
    const char *model = nullptr,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::OSBuild> os_build = 0,
    bitdrift_public::fbs::issue_reporting::v1::Platform platform = bitdrift_public::fbs::issue_reporting::v1::Platform_Unknown,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cpu_abis = nullptr) {
  auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
  auto manufacturer__ = manufacturer ? _fbb.CreateString(manufacturer) : 0;
  auto model__ = model ? _fbb.CreateString(model) : 0;
  auto cpu_abis__ = cpu_abis ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cpu_abis) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateDeviceMetrics(
      _fbb,
      time,
      timezone__,
      power_metrics,
      network_state,
      rotation,
      arch,
      display,
      manufacturer__,
      model__,
      os_build,
      platform,
      cpu_abis__);
}

struct SourceFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SourceFileBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SourceFileTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4,
    VT_LINE = 6,
    VT_COLUMN = 8
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  int64_t line() const {
    return GetField<int64_t>(VT_LINE, 0);
  }
  int64_t column() const {
    return GetField<int64_t>(VT_COLUMN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<int64_t>(verifier, VT_LINE, 8) &&
           VerifyField<int64_t>(verifier, VT_COLUMN, 8) &&
           verifier.EndTable();
  }
};

struct SourceFileBuilder {
  typedef SourceFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(SourceFile::VT_PATH, path);
  }
  void add_line(int64_t line) {
    fbb_.AddElement<int64_t>(SourceFile::VT_LINE, line, 0);
  }
  void add_column(int64_t column) {
    fbb_.AddElement<int64_t>(SourceFile::VT_COLUMN, column, 0);
  }
  explicit SourceFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SourceFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SourceFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SourceFile> CreateSourceFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    int64_t line = 0,
    int64_t column = 0) {
  SourceFileBuilder builder_(_fbb);
  builder_.add_column(column);
  builder_.add_line(line);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SourceFile> CreateSourceFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    int64_t line = 0,
    int64_t column = 0) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateSourceFile(
      _fbb,
      path__,
      line,
      column);
}

struct CPURegister FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CPURegisterBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return CPURegisterTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct CPURegisterBuilder {
  typedef CPURegister Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CPURegister::VT_NAME, name);
  }
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(CPURegister::VT_VALUE, value, 0);
  }
  explicit CPURegisterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CPURegister> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CPURegister>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CPURegister> CreateCPURegister(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint64_t value = 0) {
  CPURegisterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CPURegister> CreateCPURegisterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateCPURegister(
      _fbb,
      name__,
      value);
}

struct Frame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FrameTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CLASS_NAME = 6,
    VT_SYMBOL_NAME = 8,
    VT_SOURCE_FILE = 10,
    VT_IMAGE_ID = 12,
    VT_FRAME_ADDRESS = 14,
    VT_SYMBOL_ADDRESS = 16,
    VT_REGISTERS = 18,
    VT_STATE = 20,
    VT_FRAME_STATUS = 22,
    VT_ORIGINAL_INDEX = 24,
    VT_IN_APP = 26,
    VT_SYMBOLICATED_NAME = 28
  };
  bitdrift_public::fbs::issue_reporting::v1::FrameType type() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::FrameType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *class_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASS_NAME);
  }
  const ::flatbuffers::String *symbol_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL_NAME);
  }
  const bitdrift_public::fbs::issue_reporting::v1::SourceFile *source_file() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::SourceFile *>(VT_SOURCE_FILE);
  }
  const ::flatbuffers::String *image_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGE_ID);
  }
  uint64_t frame_address() const {
    return GetField<uint64_t>(VT_FRAME_ADDRESS, 0);
  }
  uint64_t symbol_address() const {
    return GetField<uint64_t>(VT_SYMBOL_ADDRESS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>> *registers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>> *>(VT_REGISTERS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *state() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STATE);
  }
  bitdrift_public::fbs::issue_reporting::v1::FrameStatus frame_status() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::FrameStatus>(GetField<int8_t>(VT_FRAME_STATUS, 0));
  }
  uint64_t original_index() const {
    return GetField<uint64_t>(VT_ORIGINAL_INDEX, 0);
  }
  bool in_app() const {
    return GetField<uint8_t>(VT_IN_APP, 0) != 0;
  }
  const ::flatbuffers::String *symbolicated_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOLICATED_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CLASS_NAME) &&
           verifier.VerifyString(class_name()) &&
           VerifyOffset(verifier, VT_SYMBOL_NAME) &&
           verifier.VerifyString(symbol_name()) &&
           VerifyOffset(verifier, VT_SOURCE_FILE) &&
           verifier.VerifyTable(source_file()) &&
           VerifyOffset(verifier, VT_IMAGE_ID) &&
           verifier.VerifyString(image_id()) &&
           VerifyField<uint64_t>(verifier, VT_FRAME_ADDRESS, 8) &&
           VerifyField<uint64_t>(verifier, VT_SYMBOL_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_REGISTERS) &&
           verifier.VerifyVector(registers()) &&
           verifier.VerifyVectorOfTables(registers()) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyVector(state()) &&
           verifier.VerifyVectorOfStrings(state()) &&
           VerifyField<int8_t>(verifier, VT_FRAME_STATUS, 1) &&
           VerifyField<uint64_t>(verifier, VT_ORIGINAL_INDEX, 8) &&
           VerifyField<uint8_t>(verifier, VT_IN_APP, 1) &&
           VerifyOffset(verifier, VT_SYMBOLICATED_NAME) &&
           verifier.VerifyString(symbolicated_name()) &&
           verifier.EndTable();
  }
};

struct FrameBuilder {
  typedef Frame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(bitdrift_public::fbs::issue_reporting::v1::FrameType type) {
    fbb_.AddElement<int8_t>(Frame::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_class_name(::flatbuffers::Offset<::flatbuffers::String> class_name) {
    fbb_.AddOffset(Frame::VT_CLASS_NAME, class_name);
  }
  void add_symbol_name(::flatbuffers::Offset<::flatbuffers::String> symbol_name) {
    fbb_.AddOffset(Frame::VT_SYMBOL_NAME, symbol_name);
  }
  void add_source_file(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SourceFile> source_file) {
    fbb_.AddOffset(Frame::VT_SOURCE_FILE, source_file);
  }
  void add_image_id(::flatbuffers::Offset<::flatbuffers::String> image_id) {
    fbb_.AddOffset(Frame::VT_IMAGE_ID, image_id);
  }
  void add_frame_address(uint64_t frame_address) {
    fbb_.AddElement<uint64_t>(Frame::VT_FRAME_ADDRESS, frame_address, 0);
  }
  void add_symbol_address(uint64_t symbol_address) {
    fbb_.AddElement<uint64_t>(Frame::VT_SYMBOL_ADDRESS, symbol_address, 0);
  }
  void add_registers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>>> registers) {
    fbb_.AddOffset(Frame::VT_REGISTERS, registers);
  }
  void add_state(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> state) {
    fbb_.AddOffset(Frame::VT_STATE, state);
  }
  void add_frame_status(bitdrift_public::fbs::issue_reporting::v1::FrameStatus frame_status) {
    fbb_.AddElement<int8_t>(Frame::VT_FRAME_STATUS, static_cast<int8_t>(frame_status), 0);
  }
  void add_original_index(uint64_t original_index) {
    fbb_.AddElement<uint64_t>(Frame::VT_ORIGINAL_INDEX, original_index, 0);
  }
  void add_in_app(bool in_app) {
    fbb_.AddElement<uint8_t>(Frame::VT_IN_APP, static_cast<uint8_t>(in_app), 0);
  }
  void add_symbolicated_name(::flatbuffers::Offset<::flatbuffers::String> symbolicated_name) {
    fbb_.AddOffset(Frame::VT_SYMBOLICATED_NAME, symbolicated_name);
  }
  explicit FrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Frame> CreateFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bitdrift_public::fbs::issue_reporting::v1::FrameType type = bitdrift_public::fbs::issue_reporting::v1::FrameType_Unknown,
    ::flatbuffers::Offset<::flatbuffers::String> class_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> symbol_name = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SourceFile> source_file = 0,
    ::flatbuffers::Offset<::flatbuffers::String> image_id = 0,
    uint64_t frame_address = 0,
    uint64_t symbol_address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>>> registers = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> state = 0,
    bitdrift_public::fbs::issue_reporting::v1::FrameStatus frame_status = bitdrift_public::fbs::issue_reporting::v1::FrameStatus_Missing,
    uint64_t original_index = 0,
    bool in_app = false,
    ::flatbuffers::Offset<::flatbuffers::String> symbolicated_name = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_original_index(original_index);
  builder_.add_symbol_address(symbol_address);
  builder_.add_frame_address(frame_address);
  builder_.add_symbolicated_name(symbolicated_name);
  builder_.add_state(state);
  builder_.add_registers(registers);
  builder_.add_image_id(image_id);
  builder_.add_source_file(source_file);
  builder_.add_symbol_name(symbol_name);
  builder_.add_class_name(class_name);
  builder_.add_in_app(in_app);
  builder_.add_frame_status(frame_status);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Frame> CreateFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bitdrift_public::fbs::issue_reporting::v1::FrameType type = bitdrift_public::fbs::issue_reporting::v1::FrameType_Unknown,
    const char *class_name = nullptr,
    const char *symbol_name = nullptr,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SourceFile> source_file = 0,
    const char *image_id = nullptr,
    uint64_t frame_address = 0,
    uint64_t symbol_address = 0,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>> *registers = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *state = nullptr,
    bitdrift_public::fbs::issue_reporting::v1::FrameStatus frame_status = bitdrift_public::fbs::issue_reporting::v1::FrameStatus_Missing,
    uint64_t original_index = 0,
    bool in_app = false,
    const char *symbolicated_name = nullptr) {
  auto class_name__ = class_name ? _fbb.CreateString(class_name) : 0;
  auto symbol_name__ = symbol_name ? _fbb.CreateString(symbol_name) : 0;
  auto image_id__ = image_id ? _fbb.CreateString(image_id) : 0;
  auto registers__ = registers ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::CPURegister>>(*registers) : 0;
  auto state__ = state ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*state) : 0;
  auto symbolicated_name__ = symbolicated_name ? _fbb.CreateString(symbolicated_name) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateFrame(
      _fbb,
      type,
      class_name__,
      symbol_name__,
      source_file,
      image_id__,
      frame_address,
      symbol_address,
      registers__,
      state__,
      frame_status,
      original_index,
      in_app,
      symbolicated_name__);
}

struct Thread FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ThreadBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ThreadTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ACTIVE = 6,
    VT_INDEX = 8,
    VT_STATE = 10,
    VT_PRIORITY = 12,
    VT_QUALITY_OF_SERVICE = 14,
    VT_STACK_TRACE = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  uint32_t index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const ::flatbuffers::String *state() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE);
  }
  float priority() const {
    return GetField<float>(VT_PRIORITY, 0.0f);
  }
  int8_t quality_of_service() const {
    return GetField<int8_t>(VT_QUALITY_OF_SERVICE, -1);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *stack_trace() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *>(VT_STACK_TRACE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE, 1) &&
           VerifyField<uint32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_STATE) &&
           verifier.VerifyString(state()) &&
           VerifyField<float>(verifier, VT_PRIORITY, 4) &&
           VerifyField<int8_t>(verifier, VT_QUALITY_OF_SERVICE, 1) &&
           VerifyOffset(verifier, VT_STACK_TRACE) &&
           verifier.VerifyVector(stack_trace()) &&
           verifier.VerifyVectorOfTables(stack_trace()) &&
           verifier.EndTable();
  }
};

struct ThreadBuilder {
  typedef Thread Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Thread::VT_NAME, name);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(Thread::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_index(uint32_t index) {
    fbb_.AddElement<uint32_t>(Thread::VT_INDEX, index, 0);
  }
  void add_state(::flatbuffers::Offset<::flatbuffers::String> state) {
    fbb_.AddOffset(Thread::VT_STATE, state);
  }
  void add_priority(float priority) {
    fbb_.AddElement<float>(Thread::VT_PRIORITY, priority, 0.0f);
  }
  void add_quality_of_service(int8_t quality_of_service) {
    fbb_.AddElement<int8_t>(Thread::VT_QUALITY_OF_SERVICE, quality_of_service, -1);
  }
  void add_stack_trace(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>> stack_trace) {
    fbb_.AddOffset(Thread::VT_STACK_TRACE, stack_trace);
  }
  explicit ThreadBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Thread> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Thread>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Thread> CreateThread(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    bool active = false,
    uint32_t index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> state = 0,
    float priority = 0.0f,
    int8_t quality_of_service = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>> stack_trace = 0) {
  ThreadBuilder builder_(_fbb);
  builder_.add_stack_trace(stack_trace);
  builder_.add_priority(priority);
  builder_.add_state(state);
  builder_.add_index(index);
  builder_.add_name(name);
  builder_.add_quality_of_service(quality_of_service);
  builder_.add_active(active);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Thread> CreateThreadDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool active = false,
    uint32_t index = 0,
    const char *state = nullptr,
    float priority = 0.0f,
    int8_t quality_of_service = -1,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *stack_trace = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto state__ = state ? _fbb.CreateString(state) : 0;
  auto stack_trace__ = stack_trace ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>(*stack_trace) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateThread(
      _fbb,
      name__,
      active,
      index,
      state__,
      priority,
      quality_of_service,
      stack_trace__);
}

struct ThreadDetails FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ThreadDetailsBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ThreadDetailsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_THREADS = 6
  };
  uint16_t count() const {
    return GetField<uint16_t>(VT_COUNT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>> *threads() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>> *>(VT_THREADS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_COUNT, 2) &&
           VerifyOffset(verifier, VT_THREADS) &&
           verifier.VerifyVector(threads()) &&
           verifier.VerifyVectorOfTables(threads()) &&
           verifier.EndTable();
  }
};

struct ThreadDetailsBuilder {
  typedef ThreadDetails Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_count(uint16_t count) {
    fbb_.AddElement<uint16_t>(ThreadDetails::VT_COUNT, count, 0);
  }
  void add_threads(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>>> threads) {
    fbb_.AddOffset(ThreadDetails::VT_THREADS, threads);
  }
  explicit ThreadDetailsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ThreadDetails> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ThreadDetails>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ThreadDetails> CreateThreadDetails(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>>> threads = 0) {
  ThreadDetailsBuilder builder_(_fbb);
  builder_.add_threads(threads);
  builder_.add_count(count);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ThreadDetails> CreateThreadDetailsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t count = 0,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>> *threads = nullptr) {
  auto threads__ = threads ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Thread>>(*threads) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateThreadDetails(
      _fbb,
      count,
      threads__);
}

struct Error FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ErrorBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ErrorTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_REASON = 6,
    VT_STACK_TRACE = 8,
    VT_RELATION_TO_NEXT = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *stack_trace() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *>(VT_STACK_TRACE);
  }
  bitdrift_public::fbs::issue_reporting::v1::ErrorRelation relation_to_next() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::ErrorRelation>(GetField<int8_t>(VT_RELATION_TO_NEXT, 1));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           VerifyOffset(verifier, VT_STACK_TRACE) &&
           verifier.VerifyVector(stack_trace()) &&
           verifier.VerifyVectorOfTables(stack_trace()) &&
           VerifyField<int8_t>(verifier, VT_RELATION_TO_NEXT, 1) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Error::VT_NAME, name);
  }
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(Error::VT_REASON, reason);
  }
  void add_stack_trace(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>> stack_trace) {
    fbb_.AddOffset(Error::VT_STACK_TRACE, stack_trace);
  }
  void add_relation_to_next(bitdrift_public::fbs::issue_reporting::v1::ErrorRelation relation_to_next) {
    fbb_.AddElement<int8_t>(Error::VT_RELATION_TO_NEXT, static_cast<int8_t>(relation_to_next), 1);
  }
  explicit ErrorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Error> CreateError(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>> stack_trace = 0,
    bitdrift_public::fbs::issue_reporting::v1::ErrorRelation relation_to_next = bitdrift_public::fbs::issue_reporting::v1::ErrorRelation_CausedBy) {
  ErrorBuilder builder_(_fbb);
  builder_.add_stack_trace(stack_trace);
  builder_.add_reason(reason);
  builder_.add_name(name);
  builder_.add_relation_to_next(relation_to_next);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Error> CreateErrorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *reason = nullptr,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>> *stack_trace = nullptr,
    bitdrift_public::fbs::issue_reporting::v1::ErrorRelation relation_to_next = bitdrift_public::fbs::issue_reporting::v1::ErrorRelation_CausedBy) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  auto stack_trace__ = stack_trace ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Frame>>(*stack_trace) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateError(
      _fbb,
      name__,
      reason__,
      stack_trace__,
      relation_to_next);
}

struct BinaryImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryImageBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return BinaryImageTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PATH = 6,
    VT_LOAD_ADDRESS = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  uint64_t load_address() const {
    return GetField<uint64_t>(VT_LOAD_ADDRESS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<uint64_t>(verifier, VT_LOAD_ADDRESS, 8) &&
           verifier.EndTable();
  }
};

struct BinaryImageBuilder {
  typedef BinaryImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(BinaryImage::VT_ID, id);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(BinaryImage::VT_PATH, path);
  }
  void add_load_address(uint64_t load_address) {
    fbb_.AddElement<uint64_t>(BinaryImage::VT_LOAD_ADDRESS, load_address, 0);
  }
  explicit BinaryImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryImage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryImage> CreateBinaryImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0,
    uint64_t load_address = 0) {
  BinaryImageBuilder builder_(_fbb);
  builder_.add_load_address(load_address);
  builder_.add_path(path);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BinaryImage> CreateBinaryImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *path = nullptr,
    uint64_t load_address = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateBinaryImage(
      _fbb,
      id__,
      path__,
      load_address);
}

struct SDKInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SDKInfoBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SDKInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VERSION = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           verifier.EndTable();
  }
};

struct SDKInfoBuilder {
  typedef SDKInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SDKInfo::VT_ID, id);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(SDKInfo::VT_VERSION, version);
  }
  explicit SDKInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SDKInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SDKInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SDKInfo> CreateSDKInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0) {
  SDKInfoBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SDKInfo> CreateSDKInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *version = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateSDKInfo(
      _fbb,
      id__,
      version__);
}

struct Report FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReportBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ReportTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SDK = 4,
    VT_TYPE = 6,
    VT_APP_METRICS = 8,
    VT_DEVICE_METRICS = 10,
    VT_ERRORS = 12,
    VT_THREAD_DETAILS = 14,
    VT_BINARY_IMAGES = 16
  };
  const bitdrift_public::fbs::issue_reporting::v1::SDKInfo *sdk() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::SDKInfo *>(VT_SDK);
  }
  bitdrift_public::fbs::issue_reporting::v1::ReportType type() const {
    return static_cast<bitdrift_public::fbs::issue_reporting::v1::ReportType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const bitdrift_public::fbs::issue_reporting::v1::AppMetrics *app_metrics() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::AppMetrics *>(VT_APP_METRICS);
  }
  const bitdrift_public::fbs::issue_reporting::v1::DeviceMetrics *device_metrics() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::DeviceMetrics *>(VT_DEVICE_METRICS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>> *errors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>> *>(VT_ERRORS);
  }
  const bitdrift_public::fbs::issue_reporting::v1::ThreadDetails *thread_details() const {
    return GetPointer<const bitdrift_public::fbs::issue_reporting::v1::ThreadDetails *>(VT_THREAD_DETAILS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>> *binary_images() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>> *>(VT_BINARY_IMAGES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SDK) &&
           verifier.VerifyTable(sdk()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_APP_METRICS) &&
           verifier.VerifyTable(app_metrics()) &&
           VerifyOffset(verifier, VT_DEVICE_METRICS) &&
           verifier.VerifyTable(device_metrics()) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.VerifyVector(errors()) &&
           verifier.VerifyVectorOfTables(errors()) &&
           VerifyOffset(verifier, VT_THREAD_DETAILS) &&
           verifier.VerifyTable(thread_details()) &&
           VerifyOffset(verifier, VT_BINARY_IMAGES) &&
           verifier.VerifyVector(binary_images()) &&
           verifier.VerifyVectorOfTables(binary_images()) &&
           verifier.EndTable();
  }
};

struct ReportBuilder {
  typedef Report Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sdk(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SDKInfo> sdk) {
    fbb_.AddOffset(Report::VT_SDK, sdk);
  }
  void add_type(bitdrift_public::fbs::issue_reporting::v1::ReportType type) {
    fbb_.AddElement<int8_t>(Report::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_app_metrics(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppMetrics> app_metrics) {
    fbb_.AddOffset(Report::VT_APP_METRICS, app_metrics);
  }
  void add_device_metrics(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::DeviceMetrics> device_metrics) {
    fbb_.AddOffset(Report::VT_DEVICE_METRICS, device_metrics);
  }
  void add_errors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>>> errors) {
    fbb_.AddOffset(Report::VT_ERRORS, errors);
  }
  void add_thread_details(::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::ThreadDetails> thread_details) {
    fbb_.AddOffset(Report::VT_THREAD_DETAILS, thread_details);
  }
  void add_binary_images(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>>> binary_images) {
    fbb_.AddOffset(Report::VT_BINARY_IMAGES, binary_images);
  }
  explicit ReportBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Report> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Report>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Report> CreateReport(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SDKInfo> sdk = 0,
    bitdrift_public::fbs::issue_reporting::v1::ReportType type = bitdrift_public::fbs::issue_reporting::v1::ReportType_Unknown,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppMetrics> app_metrics = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::DeviceMetrics> device_metrics = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>>> errors = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::ThreadDetails> thread_details = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>>> binary_images = 0) {
  ReportBuilder builder_(_fbb);
  builder_.add_binary_images(binary_images);
  builder_.add_thread_details(thread_details);
  builder_.add_errors(errors);
  builder_.add_device_metrics(device_metrics);
  builder_.add_app_metrics(app_metrics);
  builder_.add_sdk(sdk);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Report> CreateReportDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::SDKInfo> sdk = 0,
    bitdrift_public::fbs::issue_reporting::v1::ReportType type = bitdrift_public::fbs::issue_reporting::v1::ReportType_Unknown,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::AppMetrics> app_metrics = 0,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::DeviceMetrics> device_metrics = 0,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>> *errors = nullptr,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::ThreadDetails> thread_details = 0,
    const std::vector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>> *binary_images = nullptr) {
  auto errors__ = errors ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Error>>(*errors) : 0;
  auto binary_images__ = binary_images ? _fbb.CreateVector<::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::BinaryImage>>(*binary_images) : 0;
  return bitdrift_public::fbs::issue_reporting::v1::CreateReport(
      _fbb,
      sdk,
      type,
      app_metrics,
      device_metrics,
      errors__,
      thread_details,
      binary_images__);
}

inline const ::flatbuffers::TypeTable *ReportTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::ReportTypeTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "AppNotResponding",
    "HandledError",
    "JVMCrash",
    "MemoryTermination",
    "NativeCrash",
    "StrictModeViolation"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PlatformTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::PlatformTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Android",
    "iOS",
    "macOS"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ArchitectureTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::ArchitectureTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "arm32",
    "arm64",
    "x86",
    "x86_64"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FrameTypeTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::FrameTypeTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "JVM",
    "DWARF",
    "AndroidNative"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ErrorRelationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::ErrorRelationTypeTable
  };
  static const int64_t values[] = { 1 };
  static const char * const names[] = {
    "CausedBy"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PowerStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::PowerStateTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "RunningOnBattery",
    "PluggedInNoBattery",
    "PluggedInCharging",
    "PluggedInCharged"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *NetworkStateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::NetworkStateTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Disconnected",
    "Cellular",
    "WiFi"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *RotationTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::RotationTypeTable
  };
  static const char * const names[] = {
    "Unknown",
    "Portrait",
    "LandscapeRight",
    "LandscapeLeft",
    "PortraitUpsideDown"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FrameStatusTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::FrameStatusTypeTable
  };
  static const char * const names[] = {
    "Missing",
    "Symbolicated",
    "MissingSymbol",
    "UnknownImage",
    "Malformed"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *TimestampTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16 };
  static const char * const names[] = {
    "seconds",
    "nanos"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *MemoryTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const int64_t values[] = { 0, 8, 16, 24 };
  static const char * const names[] = {
    "total",
    "free",
    "used"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 3, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AppBuildNumberTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "version_code",
    "cf_bundle_version"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *AppMetricsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::MemoryTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::AppBuildNumberTypeTable
  };
  static const char * const names[] = {
    "app_id",
    "memory",
    "version",
    "build_number",
    "running_state"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OSBuildTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "version",
    "brand",
    "fingerprint",
    "kern_osversion"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PowerMetricsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_UCHAR, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::PowerStateTypeTable
  };
  static const char * const names[] = {
    "power_state",
    "charge_percent"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DisplayTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "height",
    "width",
    "density_dpi"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *DeviceMetricsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_CHAR, 0, 2 },
    { ::flatbuffers::ET_CHAR, 0, 3 },
    { ::flatbuffers::ET_CHAR, 0, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 6 },
    { ::flatbuffers::ET_CHAR, 0, 7 },
    { ::flatbuffers::ET_STRING, 1, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::TimestampTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::PowerMetricsTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::NetworkStateTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::RotationTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::ArchitectureTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::DisplayTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::OSBuildTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::PlatformTypeTable
  };
  static const char * const names[] = {
    "time",
    "timezone",
    "power_metrics",
    "network_state",
    "rotation",
    "arch",
    "display",
    "manufacturer",
    "model",
    "os_build",
    "platform",
    "cpu_abis"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 12, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SourceFileTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 },
    { ::flatbuffers::ET_LONG, 0, -1 }
  };
  static const char * const names[] = {
    "path",
    "line",
    "column"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *CPURegisterTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "value"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *FrameTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 2 },
    { ::flatbuffers::ET_STRING, 1, -1 },
    { ::flatbuffers::ET_CHAR, 0, 3 },
    { ::flatbuffers::ET_ULONG, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::FrameTypeTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::SourceFileTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::CPURegisterTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::FrameStatusTypeTable
  };
  static const char * const names[] = {
    "type",
    "class_name",
    "symbol_name",
    "source_file",
    "image_id",
    "frame_address",
    "symbol_address",
    "registers",
    "state",
    "frame_status",
    "original_index",
    "in_app",
    "symbolicated_name"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 13, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ThreadTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_BOOL, 0, -1 },
    { ::flatbuffers::ET_UINT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_CHAR, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::FrameTypeTable
  };
  static const char * const names[] = {
    "name",
    "active",
    "index",
    "state",
    "priority",
    "quality_of_service",
    "stack_trace"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ThreadDetailsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_USHORT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::ThreadTypeTable
  };
  static const char * const names[] = {
    "count",
    "threads"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ErrorTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 },
    { ::flatbuffers::ET_CHAR, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::FrameTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::ErrorRelationTypeTable
  };
  static const char * const names[] = {
    "name",
    "reason",
    "stack_trace",
    "relation_to_next"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *BinaryImageTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "path",
    "load_address"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *SDKInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "version"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ReportTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 1 },
    { ::flatbuffers::ET_SEQUENCE, 0, 2 },
    { ::flatbuffers::ET_SEQUENCE, 0, 3 },
    { ::flatbuffers::ET_SEQUENCE, 1, 4 },
    { ::flatbuffers::ET_SEQUENCE, 0, 5 },
    { ::flatbuffers::ET_SEQUENCE, 1, 6 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bitdrift_public::fbs::issue_reporting::v1::SDKInfoTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::ReportTypeTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::AppMetricsTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::DeviceMetricsTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::ErrorTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::ThreadDetailsTypeTable,
    bitdrift_public::fbs::issue_reporting::v1::BinaryImageTypeTable
  };
  static const char * const names[] = {
    "sdk",
    "type",
    "app_metrics",
    "device_metrics",
    "errors",
    "thread_details",
    "binary_images"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const bitdrift_public::fbs::issue_reporting::v1::Report *GetReport(const void *buf) {
  return ::flatbuffers::GetRoot<bitdrift_public::fbs::issue_reporting::v1::Report>(buf);
}

inline const bitdrift_public::fbs::issue_reporting::v1::Report *GetSizePrefixedReport(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<bitdrift_public::fbs::issue_reporting::v1::Report>(buf);
}

inline bool VerifyReportBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bitdrift_public::fbs::issue_reporting::v1::Report>(nullptr);
}

inline bool VerifySizePrefixedReportBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bitdrift_public::fbs::issue_reporting::v1::Report>(nullptr);
}

inline void FinishReportBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Report> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedReportBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<bitdrift_public::fbs::issue_reporting::v1::Report> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace v1
}  // namespace issue_reporting
}  // namespace fbs
}  // namespace bitdrift_public

#endif  // FLATBUFFERS_GENERATED_REPORT_BITDRIFT_PUBLIC_FBS_ISSUE_REPORTING_V1_H_
